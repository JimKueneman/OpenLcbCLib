<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/drivers/canbus/can_main_statemachine.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c718a368270b13c54d94892d20736f45.html">drivers</a></li><li class="navelem"><a class="el" href="dir_858afec057d05dde4e87dd686afd4670.html">canbus</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">can_main_statemachine.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main CAN layer state machine for orchestrating message dispatch and node management.  
<a href="#details">More...</a></p>

<p><a href="can__main__statemachine_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__can__main__statemachine__t.html">interface_can_main_statemachine_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface structure for CAN main state machine callback functions.  <a href="structinterface__can__main__statemachine__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a360ebdb7ef110fdd62097a5fc56310f1" id="r_a360ebdb7ef110fdd62097a5fc56310f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a360ebdb7ef110fdd62097a5fc56310f1">CanMainStatemachine_initialize</a> (const <a class="el" href="structinterface__can__main__statemachine__t.html">interface_can_main_statemachine_t</a> *interface_can_main_statemachine)</td></tr>
<tr class="memdesc:a360ebdb7ef110fdd62097a5fc56310f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CAN Main State Machine.  <br /></td></tr>
<tr class="separator:a360ebdb7ef110fdd62097a5fc56310f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdef5a88eff72849f2506381fe1742f" id="r_a9bdef5a88eff72849f2506381fe1742f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bdef5a88eff72849f2506381fe1742f">CanMainStateMachine_run</a> (void)</td></tr>
<tr class="memdesc:a9bdef5a88eff72849f2506381fe1742f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes one iteration of the main CAN state machine.  <br /></td></tr>
<tr class="separator:a9bdef5a88eff72849f2506381fe1742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514df581e108e12f527d4de248458357" id="r_a514df581e108e12f527d4de248458357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="can__types_8h.html#ad52cca2be7565c8d23f3cc4d83cbc19e">can_statemachine_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a514df581e108e12f527d4de248458357">CanMainStateMachine_get_can_statemachine_info</a> (void)</td></tr>
<tr class="memdesc:a514df581e108e12f527d4de248458357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides read access to internal state machine context.  <br /></td></tr>
<tr class="separator:a514df581e108e12f527d4de248458357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7be0999c73da181407f0ce473b4574" id="r_a4c7be0999c73da181407f0ce473b4574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c7be0999c73da181407f0ce473b4574">CanMainStatemachine_handle_duplicate_aliases</a> (void)</td></tr>
<tr class="memdesc:a4c7be0999c73da181407f0ce473b4574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles all detected duplicate alias conflicts.  <br /></td></tr>
<tr class="separator:a4c7be0999c73da181407f0ce473b4574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefbd0fe819bfc0be958202dca4bbab8" id="r_acefbd0fe819bfc0be958202dca4bbab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acefbd0fe819bfc0be958202dca4bbab8">CanMainStatemachine_handle_login_outgoing_can_message</a> (void)</td></tr>
<tr class="memdesc:acefbd0fe819bfc0be958202dca4bbab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits pending login-related CAN messages.  <br /></td></tr>
<tr class="separator:acefbd0fe819bfc0be958202dca4bbab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619bfa722d577c1295ae862500aef386" id="r_a619bfa722d577c1295ae862500aef386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619bfa722d577c1295ae862500aef386">CanMainStatemachine_handle_outgoing_can_message</a> (void)</td></tr>
<tr class="memdesc:a619bfa722d577c1295ae862500aef386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits pending outgoing CAN messages from FIFO.  <br /></td></tr>
<tr class="separator:a619bfa722d577c1295ae862500aef386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaf91c98c9fd3469d6f2fa9b5a3eaf0" id="r_acfaf91c98c9fd3469d6f2fa9b5a3eaf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfaf91c98c9fd3469d6f2fa9b5a3eaf0">CanMainStatemachine_handle_try_enumerate_first_node</a> (void)</td></tr>
<tr class="memdesc:acfaf91c98c9fd3469d6f2fa9b5a3eaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins node enumeration and processes first node.  <br /></td></tr>
<tr class="separator:acfaf91c98c9fd3469d6f2fa9b5a3eaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326e8a6b5051c0b6821a460fab2ba410" id="r_a326e8a6b5051c0b6821a460fab2ba410"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326e8a6b5051c0b6821a460fab2ba410">CanMainStatemachine_handle_try_enumerate_next_node</a> (void)</td></tr>
<tr class="memdesc:a326e8a6b5051c0b6821a460fab2ba410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continues node enumeration to next node.  <br /></td></tr>
<tr class="separator:a326e8a6b5051c0b6821a460fab2ba410"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main CAN layer state machine for orchestrating message dispatch and node management. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</li>
</ul>
</dd></dl>
<p>This module implements the primary CAN layer dispatcher that coordinates alias management, login processing, and message routing across all virtual nodes. It handles duplicate alias detection, manages outgoing message queues, and orchestrates the login state machine for node initialization.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a360ebdb7ef110fdd62097a5fc56310f1" name="a360ebdb7ef110fdd62097a5fc56310f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360ebdb7ef110fdd62097a5fc56310f1">&#9670;&#160;</a></span>CanMainStatemachine_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CanMainStatemachine_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__can__main__statemachine__t.html">interface_can_main_statemachine_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_can_main_statemachine</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the CAN Main State Machine. </p>
<p>Registers the application's callback interface with the main state machine and prepares internal buffers for operation. Must be called once during application initialization before calling CanMainStateMachine_run.</p>
<p>The interface structure must contain valid (non-NULL) function pointers for all required callbacks. The interface provides:</p><ul>
<li>Resource locking for thread safety</li>
<li>CAN message transmission</li>
<li>Node management and enumeration</li>
<li>Alias mapping operations</li>
<li>Login state machine integration</li>
<li>Internal operation handlers for testing</li>
</ul>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Required before any CAN communication can occur</li>
<li>Must be called after buffer stores are initialized</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_can_main_statemachine</td><td>Pointer to populated interface structure containing all required callback function pointers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>interface_can_main_statemachine must remain valid for lifetime of application </dd>
<dd>
All function pointers in interface must be non-NULL </dd>
<dd>
MUST be called exactly once during initialization </dd>
<dd>
NOT thread-safe - call before starting interrupts/threads</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call after CanBufferStore_initialize and CanBufferFifo_initialize </dd>
<dd>
Call after CanLoginStateMachine_initialize </dd>
<dd>
Call before starting CAN reception</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html" title="Interface structure for CAN main state machine callback functions.">interface_can_main_statemachine_t</a> - Interface structure definition </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#a9bdef5a88eff72849f2506381fe1742f" title="Executes one iteration of the main CAN state machine.">CanMainStateMachine_run</a> - Main execution loop</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Store pointer to dependency interface for later use</li>
<li>Clear login outgoing message buffer to zero</li>
<li>Link login message buffer to state machine info structure</li>
<li>Clear all state machine info fields:<ul>
<li>Set openlcb_node to NULL (no active node)</li>
<li>Set login_outgoing_can_msg_valid to false</li>
<li>Set enumerating to false</li>
<li>Set outgoing_can_msg to NULL</li>
</ul>
</li>
</ol>
<p>The login message buffer is statically allocated to avoid runtime allocation overhead during login processing.</p>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Required before any CAN communication can occur</li>
<li>Must be called after buffer stores are initialized</li>
</ul>
<pre class="fragment">* @param interface_can_main_statemachine Pointer to populated dependency interface
* structure containing all required function implementations
* </pre><dl class="section warning"><dt>Warning</dt><dd>MUST be called exactly once during initialization </dd>
<dd>
NOT thread-safe - call before starting interrupts/threads</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call after <a class="el" href="can__buffer__store_8c.html#a49fcb6055f37edb9e56977295cd0eaf2" title="Initializes the CAN Buffer Store.">CanBufferStore_initialize()</a> and <a class="el" href="can__buffer__fifo_8c.html#ab0652f39f104350007ad642b955ddbad" title="Initializes the CAN Message Buffer FIFO.">CanBufferFifo_initialize()</a> </dd>
<dd>
All function pointers in interface must be non-NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__main__statemachine_8c.html#a9bdef5a88eff72849f2506381fe1742f" title="Executes one iteration of the main CAN state machine.">CanMainStateMachine_run</a> </dd>
<dd>
<a class="el" href="structinterface__can__main__statemachine__t.html" title="Interface structure for CAN main state machine callback functions.">interface_can_main_statemachine_t</a> </dd></dl>

</div>
</div>
<a id="a9bdef5a88eff72849f2506381fe1742f" name="a9bdef5a88eff72849f2506381fe1742f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdef5a88eff72849f2506381fe1742f">&#9670;&#160;</a></span>CanMainStateMachine_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CanMainStateMachine_run </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes one iteration of the main CAN state machine. </p>
<p>Implements cooperative multitasking by processing one operation per call and returning immediately. Handles duplicate alias detection, outgoing message transmission, login message processing, and node enumeration in priority order.</p>
<p>Processing sequence per iteration:</p><ol type="1">
<li>Check for and handle duplicate aliases (critical - highest priority)</li>
<li>Transmit pending outgoing CAN messages from FIFO</li>
<li>Transmit pending login messages (CID, RID, AMD frames)</li>
<li>Enumerate and process first node (start enumeration)</li>
<li>Enumerate and process next node (continue enumeration)</li>
</ol>
<p>Each operation:</p><ul>
<li>Returns immediately after completion</li>
<li>May lock shared resources briefly</li>
<li>Processes exactly one item/node per call</li>
</ul>
<p>The state machine cycles through all operations continuously, providing cooperative multitasking with application code. Nodes are processed round-robin through their login sequences until all reach permitted state.</p>
<p>Use cases:</p><ul>
<li>Called continuously from main application loop</li>
<li>Cooperative multitasking with other application code</li>
<li>Non-blocking state machine advancement</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Must be called frequently (as fast as possible in main loop) </dd>
<dd>
Assumes CanMainStatemachine_initialize was already called </dd>
<dd>
NOT thread-safe - call from single context only</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Returns after processing one operation for cooperative multitasking </dd>
<dd>
Each operation may lock shared resources briefly (microseconds) </dd>
<dd>
Processes all operations in sequence before repeating</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call as frequently as possible in main loop </dd>
<dd>
No blocking waits - always returns immediately </dd>
<dd>
Lock duration is minimal to prevent frame drops</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__main__statemachine_8c.html#a360ebdb7ef110fdd62097a5fc56310f1" title="Initializes the CAN Main State Machine.">CanMainStatemachine_initialize</a> - Must be called first </dd>
<dd>
<a class="el" href="structinterface__can__main__statemachine__t.html" title="Interface structure for CAN main state machine callback functions.">interface_can_main_statemachine_t</a> - Callback interface</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Call handle_duplicate_aliases():<ul>
<li>If returns true (duplicates processed), return</li>
</ul>
</li>
<li>Call handle_outgoing_can_message():<ul>
<li>If returns true (message transmitted or pending), return</li>
</ul>
</li>
<li>Call handle_login_outgoing_can_message():<ul>
<li>If returns true (login message transmitted or pending), return</li>
</ul>
</li>
<li>Call handle_try_enumerate_first_node():<ul>
<li>If returns true (first node processed or none exist), return</li>
</ul>
</li>
<li>Call handle_try_enumerate_next_node():<ul>
<li>If returns true (no more nodes), return</li>
<li>If returns false (more nodes exist), will continue on next iteration</li>
</ul>
</li>
</ol>
<p>Each function processes one discrete operation and returns. This cooperative multitasking pattern allows other application code to execute between operations.</p>
<p>Priority order ensures critical operations (duplicate alias handling, message transmission) complete before lower-priority operations (node enumeration).</p>
<p>Use cases:</p><ul>
<li>Called continuously from main application loop</li>
<li>Cooperative multitasking with other application code</li>
<li>Non-blocking state machine advancement</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Must be called frequently (as fast as possible in main loop) </dd>
<dd>
Assumes <a class="el" href="can__main__statemachine_8c.html#a360ebdb7ef110fdd62097a5fc56310f1" title="Initializes the CAN Main State Machine.">CanMainStatemachine_initialize()</a> was already called</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns after processing one operation for cooperative multitasking </dd>
<dd>
Each operation may lock shared resources briefly</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__main__statemachine_8c.html#a360ebdb7ef110fdd62097a5fc56310f1" title="Initializes the CAN Main State Machine.">CanMainStatemachine_initialize</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#a4c7be0999c73da181407f0ce473b4574" title="Handles all detected duplicate alias conflicts.">CanMainStatemachine_handle_duplicate_aliases</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#a619bfa722d577c1295ae862500aef386" title="Transmits pending outgoing CAN messages from FIFO.">CanMainStatemachine_handle_outgoing_can_message</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#acefbd0fe819bfc0be958202dca4bbab8" title="Transmits pending login-related CAN messages.">CanMainStatemachine_handle_login_outgoing_can_message</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#acfaf91c98c9fd3469d6f2fa9b5a3eaf0" title="Begins node enumeration and processes first node.">CanMainStatemachine_handle_try_enumerate_first_node</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#a326e8a6b5051c0b6821a460fab2ba410" title="Continues node enumeration to next node.">CanMainStatemachine_handle_try_enumerate_next_node</a> </dd></dl>

</div>
</div>
<a id="a514df581e108e12f527d4de248458357" name="a514df581e108e12f527d4de248458357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514df581e108e12f527d4de248458357">&#9670;&#160;</a></span>CanMainStateMachine_get_can_statemachine_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="can__types_8h.html#ad52cca2be7565c8d23f3cc4d83cbc19e">can_statemachine_info_t</a> * CanMainStateMachine_get_can_statemachine_info </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides read access to internal state machine context. </p>
<p>Returns pointer to the internal state structure containing current node being processed, login message buffer, and outgoing message pointer. Primarily used for debugging and unit testing.</p>
<p>The returned structure includes:</p><ul>
<li>Pointer to current node being processed</li>
<li>Login outgoing message buffer</li>
<li>Login message valid flag</li>
<li>Outgoing CAN message pointer</li>
<li>Enumeration flag</li>
</ul>
<p>Use cases:</p><ul>
<li>Unit test verification of state machine behavior</li>
<li>Debugging state machine operation</li>
<li>Test coverage of edge cases</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal can_statemachine_info_t structure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For debugging and testing only - do not modify returned structure </dd>
<dd>
NOT thread-safe - lock resources before accessing</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Provides read-only access to live state machine context </dd>
<dd>
Returned pointer valid only during execution</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use for testing and debugging purposes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__types_8h.html#ad52cca2be7565c8d23f3cc4d83cbc19e">can_statemachine_info_t</a> - State machine context structure</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Return pointer to static _can_statemachine_info structure</li>
</ol>
<p>The returned structure contains live state machine context including current node being processed, login message buffer, and outgoing message pointer.</p>
<p>Use cases:</p><ul>
<li>Unit test verification of state machine behavior</li>
<li>Debugging state machine operation</li>
<li>Test coverage of edge cases</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal can_statemachine_info_t structure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For debugging and testing only - do not modify returned structure </dd>
<dd>
NOT thread-safe - lock resources before accessing</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides read-only access to live state machine context</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__types_8h.html#ad52cca2be7565c8d23f3cc4d83cbc19e">can_statemachine_info_t</a> </dd></dl>

</div>
</div>
<a id="a4c7be0999c73da181407f0ce473b4574" name="a4c7be0999c73da181407f0ce473b4574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7be0999c73da181407f0ce473b4574">&#9670;&#160;</a></span>CanMainStatemachine_handle_duplicate_aliases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanMainStatemachine_handle_duplicate_aliases </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles all detected duplicate alias conflicts. </p>
<p>Scans alias mapping table for duplicate flags, unregisters conflicting aliases, and resets affected nodes to Inhibited state forcing alias reallocation. Returns true if any duplicates were found and processed.</p>
<p>When duplicate detected:</p><ul>
<li>Alias is unregistered from mapping table</li>
<li>Affected node is reset to Inhibited state</li>
<li>Node permitted flag cleared</li>
<li>Node must reallocate new alias through complete login sequence</li>
</ul>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of duplicate alias handling</li>
<li>Debugging alias conflicts</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if duplicate aliases were found and processed, false if none detected</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Locks shared resources during operation </dd>
<dd>
Affected nodes will temporarily go offline during realias </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Clears has_duplicate_alias flag after processing </dd>
<dd>
May affect multiple nodes if multiple duplicates exist</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Entire login sequence must be repeated for affected nodes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#acdd549c43e6e2393090daf202ee785cf" title="Callback to process duplicate alias conflicts.">interface_can_main_statemachine_t::handle_duplicate_aliases</a> </dd>
<dd>
<a class="el" href="alias__mappings_8c.html#a9f08c60c95f97546d47c8386270cc8b4" title="Deregisters an existing Alias/NodeID pair.">AliasMappings_unregister</a> - Removes alias mapping</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize result to false</li>
<li>Lock shared resources to prevent concurrent access</li>
<li>Get alias mapping info structure from interface</li>
<li>Check if has_duplicate_alias flag is set:<ul>
<li>If set, call _process_duplicate_aliases() to handle them</li>
<li>Set result to true</li>
</ul>
</li>
<li>Unlock shared resources</li>
<li>Return result flag</li>
</ol>
<p>Locking is required because alias mapping table is shared between CAN receive interrupt (which sets duplicate flags) and main loop (which processes them).</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of duplicate alias handling</li>
<li>Debugging alias conflicts</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if duplicate aliases were found and processed, false if none detected</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Locks shared resources during operation </dd>
<dd>
Affected nodes will temporarily go offline during realias</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Clears has_duplicate_alias flag after processing</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#acdd549c43e6e2393090daf202ee785cf" title="Callback to process duplicate alias conflicts.">interface_can_main_statemachine_t.handle_duplicate_aliases</a> </dd>
<dd>
<a class="el" href="alias__mappings_8c.html#a9f08c60c95f97546d47c8386270cc8b4" title="Deregisters an existing Alias/NodeID pair.">AliasMappings_unregister</a> </dd>
<dd>
_process_duplicate_aliases </dd></dl>

</div>
</div>
<a id="acefbd0fe819bfc0be958202dca4bbab8" name="acefbd0fe819bfc0be958202dca4bbab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefbd0fe819bfc0be958202dca4bbab8">&#9670;&#160;</a></span>CanMainStatemachine_handle_login_outgoing_can_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanMainStatemachine_handle_login_outgoing_can_message </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmits pending login-related CAN messages. </p>
<p>Attempts to transmit login message (CID, RID, AMD) if one is pending. Returns true if a message was pending regardless of transmission success. Message remains pending until successfully transmitted.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of login message transmission</li>
<li>Debugging alias allocation sequence</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if login message was pending (whether sent or not), false if no message pending</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Clears valid flag only after successful transmission </dd>
<dd>
May be called multiple times until transmission succeeds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Handles CID, RID, and AMD frames from login state machine</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#a28e939b74de1df461b469f2ddf7d663c" title="Callback to transmit pending login CAN messages.">interface_can_main_statemachine_t::handle_login_outgoing_can_message</a> </dd>
<dd>
<a class="el" href="can__login__statemachine_8c.html#a19d57826974209f27f8883a2fa443aae" title="Runs the CAN login state machine.">CanLoginStateMachine_run</a> - Generates login messages</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if login_outgoing_can_msg_valid flag is set:<ul>
<li>If set, message is pending transmission</li>
<li>Call interface send_can_message() with login message buffer</li>
<li>If transmission successful:<ul>
<li>Clear login_outgoing_can_msg_valid flag</li>
</ul>
</li>
<li>Return true (message was pending)</li>
</ul>
</li>
<li>Return false (no message pending)</li>
</ol>
<p>The login message buffer is statically allocated and reused for each login frame (CID7, CID6, CID5, CID4, RID, AMD). Valid flag indicates message is ready to send.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of login message transmission</li>
<li>Debugging alias allocation sequence</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if login message was pending (whether sent or not), false if no message pending</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Clears valid flag only after successful transmission </dd>
<dd>
May be called multiple times until transmission succeeds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#a28e939b74de1df461b469f2ddf7d663c" title="Callback to transmit pending login CAN messages.">interface_can_main_statemachine_t.handle_login_outgoing_can_message</a> </dd>
<dd>
<a class="el" href="can__login__statemachine_8c.html#a19d57826974209f27f8883a2fa443aae" title="Runs the CAN login state machine.">CanLoginStateMachine_run</a> </dd></dl>

</div>
</div>
<a id="a619bfa722d577c1295ae862500aef386" name="a619bfa722d577c1295ae862500aef386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619bfa722d577c1295ae862500aef386">&#9670;&#160;</a></span>CanMainStatemachine_handle_outgoing_can_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanMainStatemachine_handle_outgoing_can_message </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmits pending outgoing CAN messages from FIFO. </p>
<p>Pops one message from outgoing CAN FIFO and attempts transmission. If transmission succeeds, message is freed back to buffer pool. If transmission fails, message remains in working buffer for retry on next call.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of message transmission</li>
<li>Debugging message flow</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if message was in FIFO (whether sent or not), false if FIFO empty</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Locks shared resources during FIFO access </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Frees buffer only after successful transmission </dd>
<dd>
May be called multiple times until transmission succeeds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Works with outgoing FIFO populated by Rx handlers</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#a21202484ac69bd5be4a3304038cf2f5f" title="Callback to transmit pending outgoing CAN messages.">interface_can_main_statemachine_t::handle_outgoing_can_message</a> </dd>
<dd>
<a class="el" href="can__buffer__fifo_8c.html#a2ffec18f770ac9eeb09eb5efc586addc" title="Pops a CAN message off the FIFO buffer.">CanBufferFifo_pop</a> - Retrieves message from FIFO </dd>
<dd>
<a class="el" href="can__buffer__store_8c.html#ad95fb1127ec823f0cc9117848b78e5a7" title="Frees a CAN buffer back to the pool.">CanBufferStore_free_buffer</a> - Returns buffer to pool</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if working buffer already has a message:<ul>
<li>If NULL, need to pop from FIFO</li>
<li>Lock shared resources</li>
<li>Pop message from CAN buffer FIFO</li>
<li>Unlock shared resources</li>
<li>Store popped message in working buffer</li>
</ul>
</li>
<li>Check if working buffer has message:<ul>
<li>Call interface send_can_message() with message</li>
<li>If transmission successful:<ul>
<li>Lock shared resources</li>
<li>Free buffer back to CAN buffer store</li>
<li>Unlock shared resources</li>
<li>Clear working buffer pointer to NULL</li>
</ul>
</li>
<li>Return true (message was pending)</li>
</ul>
</li>
<li>Return false (no message pending)</li>
</ol>
<p>The working buffer prevents message loss if transmission fails due to full hardware buffer. Message remains in working buffer for retry on next call.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of message transmission</li>
<li>Debugging message flow</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if message was in FIFO (whether sent or not), false if FIFO empty</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Locks shared resources during FIFO access</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Frees buffer only after successful transmission </dd>
<dd>
May be called multiple times until transmission succeeds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#a21202484ac69bd5be4a3304038cf2f5f" title="Callback to transmit pending outgoing CAN messages.">interface_can_main_statemachine_t.handle_outgoing_can_message</a> </dd>
<dd>
<a class="el" href="can__buffer__fifo_8c.html#a2ffec18f770ac9eeb09eb5efc586addc" title="Pops a CAN message off the FIFO buffer.">CanBufferFifo_pop</a> </dd>
<dd>
<a class="el" href="can__buffer__store_8c.html#ad95fb1127ec823f0cc9117848b78e5a7" title="Frees a CAN buffer back to the pool.">CanBufferStore_free_buffer</a> </dd></dl>

</div>
</div>
<a id="acfaf91c98c9fd3469d6f2fa9b5a3eaf0" name="acfaf91c98c9fd3469d6f2fa9b5a3eaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfaf91c98c9fd3469d6f2fa9b5a3eaf0">&#9670;&#160;</a></span>CanMainStatemachine_handle_try_enumerate_first_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanMainStatemachine_handle_try_enumerate_first_node </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins node enumeration and processes first node. </p>
<p>Gets first node from node pool and processes it through appropriate state machine based on login status. If node has not completed login (run_state &lt; RUNSTATE_LOAD_INITIALIZATION_COMPLETE), runs login state machine. Returns true indicating enumeration started.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of node enumeration</li>
<li>Debugging multi-node operation</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if first node was found and processed (or none exist), false if enumeration already active</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only processes node if not already enumerating </dd>
<dd>
Supports multiple virtual nodes up to USER_DEFINED_NODE_BUFFER_DEPTH</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Enumeration key 0 reserved for CAN main state machine</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#ace54b5c03eafd093615c3de2f76587b1" title="Callback to begin node enumeration and process first node.">interface_can_main_statemachine_t::handle_try_enumerate_first_node</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#a326e8a6b5051c0b6821a460fab2ba410" title="Continues node enumeration to next node.">CanMainStatemachine_handle_try_enumerate_next_node</a> - Continue enumeration </dd>
<dd>
<a class="el" href="group__user__config__constants.html#ga02b00dd66a6ba4b9d405bdff61cc5171" title="Maximum number of virtual nodes that can be allocated.">USER_DEFINED_NODE_BUFFER_DEPTH</a> - Maximum nodes supported</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if currently enumerating a node:<ul>
<li>If openlcb_node is NULL, no active enumeration</li>
<li>Get first node using interface-&gt;openlcb_node_get_first()</li>
<li>Store node pointer in state machine info</li>
<li>If no nodes exist (NULL returned):<ul>
<li>Return true (done, nothing to process)</li>
</ul>
</li>
<li>Check if node is still in login sequence:<ul>
<li>If run_state &lt; RUNSTATE_LOAD_INITIALIZATION_COMPLETE</li>
<li>Call login state machine via interface</li>
</ul>
</li>
<li>Return true (first node processed)</li>
</ul>
</li>
<li>Return false (already enumerating)</li>
</ol>
<p>Node enumeration allows processing multiple virtual nodes. Each node may be in different states (logging in, initialized, running).</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of node enumeration</li>
<li>Debugging multi-node operation</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if first node was found and processed (or none exist), false if enumeration already active</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Only processes node if not already enumerating </dd>
<dd>
Supports multiple virtual nodes up to USER_DEFINED_NODE_BUFFER_DEPTH</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#ace54b5c03eafd093615c3de2f76587b1" title="Callback to begin node enumeration and process first node.">interface_can_main_statemachine_t.handle_try_enumerate_first_node</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#a326e8a6b5051c0b6821a460fab2ba410" title="Continues node enumeration to next node.">CanMainStatemachine_handle_try_enumerate_next_node</a> </dd>
<dd>
<a class="el" href="group__user__config__constants.html#ga02b00dd66a6ba4b9d405bdff61cc5171" title="Maximum number of virtual nodes that can be allocated.">USER_DEFINED_NODE_BUFFER_DEPTH</a> </dd>
<dd>
<a class="el" href="group__node__enum__keys.html#gacbaa33daf2692ac9f60b92a5a3a0c916" title="Enumeration key used by CAN state machine.">CAN_STATEMACHINE_NODE_ENUMRATOR_KEY</a> </dd></dl>

</div>
</div>
<a id="a326e8a6b5051c0b6821a460fab2ba410" name="a326e8a6b5051c0b6821a460fab2ba410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326e8a6b5051c0b6821a460fab2ba410">&#9670;&#160;</a></span>CanMainStatemachine_handle_try_enumerate_next_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanMainStatemachine_handle_try_enumerate_next_node </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Continues node enumeration to next node. </p>
<p>Gets next node from node pool and processes it through appropriate state machine based on login status. If node has not completed login (run_state &lt; RUNSTATE_LOAD_INITIALIZATION_COMPLETE), runs login state machine. Returns true if no more nodes remain, false to continue enumeration.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of node enumeration</li>
<li>Debugging multi-node operation</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if no more nodes available (enumeration complete), false if more nodes to process</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Works in conjunction with handle_try_enumerate_first_node </dd>
<dd>
Supports multiple virtual nodes up to USER_DEFINED_NODE_BUFFER_DEPTH</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Round-robin processing ensures all nodes get equal time</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#a41dbaa73eb2229932ffc76416db879e7" title="Callback to continue node enumeration to next node.">interface_can_main_statemachine_t::handle_try_enumerate_next_node</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#acfaf91c98c9fd3469d6f2fa9b5a3eaf0" title="Begins node enumeration and processes first node.">CanMainStatemachine_handle_try_enumerate_first_node</a> - Start enumeration </dd>
<dd>
<a class="el" href="group__user__config__constants.html#ga02b00dd66a6ba4b9d405bdff61cc5171" title="Maximum number of virtual nodes that can be allocated.">USER_DEFINED_NODE_BUFFER_DEPTH</a> - Maximum nodes supported</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Get next node using interface-&gt;openlcb_node_get_next()</li>
<li>Store node pointer in state machine info</li>
<li>If no more nodes (NULL returned):<ul>
<li>Return true (enumeration complete)</li>
</ul>
</li>
<li>Check if node is still in login sequence:<ul>
<li>If run_state &lt; RUNSTATE_LOAD_INITIALIZATION_COMPLETE</li>
<li>Call login state machine via interface</li>
</ul>
</li>
<li>Return false (more nodes to process)</li>
</ol>
<p>Called after handle_try_enumerate_first_node() to process remaining nodes in the node pool. Continues until all nodes have been processed.</p>
<p>Use cases:</p><ul>
<li>Called by main state machine run loop</li>
<li>Unit testing of node enumeration</li>
<li>Debugging multi-node operation</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if no more nodes available (enumeration complete), false if more nodes to process</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing/debugging - normally called via interface function pointer </dd>
<dd>
Works in conjunction with handle_try_enumerate_first_node() </dd>
<dd>
Supports multiple virtual nodes up to USER_DEFINED_NODE_BUFFER_DEPTH</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__main__statemachine__t.html#a41dbaa73eb2229932ffc76416db879e7" title="Callback to continue node enumeration to next node.">interface_can_main_statemachine_t.handle_try_enumerate_next_node</a> </dd>
<dd>
<a class="el" href="can__main__statemachine_8c.html#acfaf91c98c9fd3469d6f2fa9b5a3eaf0" title="Begins node enumeration and processes first node.">CanMainStatemachine_handle_try_enumerate_first_node</a> </dd>
<dd>
<a class="el" href="group__user__config__constants.html#ga02b00dd66a6ba4b9d405bdff61cc5171" title="Maximum number of virtual nodes that can be allocated.">USER_DEFINED_NODE_BUFFER_DEPTH</a> </dd>
<dd>
<a class="el" href="group__node__enum__keys.html#gacbaa33daf2692ac9f60b92a5a3a0c916" title="Enumeration key used by CAN state machine.">CAN_STATEMACHINE_NODE_ENUMRATOR_KEY</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
