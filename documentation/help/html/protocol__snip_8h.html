<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/protocol_snip.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">protocol_snip.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Simple Node Information Protocol (SNIP) implementation.  
<a href="#details">More...</a></p>

<p><a href="protocol__snip_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__openlcb__protocol__snip__t.html">interface_openlcb_protocol_snip_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface structure for Simple Node Information Protocol (SNIP) handler.  <a href="structinterface__openlcb__protocol__snip__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a299e55a84322665954521e5e913372d8" id="r_a299e55a84322665954521e5e913372d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a299e55a84322665954521e5e913372d8">ProtocolSnip_initialize</a> (const <a class="el" href="structinterface__openlcb__protocol__snip__t.html">interface_openlcb_protocol_snip_t</a> *interface_openlcb_protocol_snip)</td></tr>
<tr class="memdesc:a299e55a84322665954521e5e913372d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Simple Node Information Protocol handler.  <br /></td></tr>
<tr class="separator:a299e55a84322665954521e5e913372d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4480bb3738c2db61ebf4ee6667c4eee3" id="r_a4480bb3738c2db61ebf4ee6667c4eee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3">ProtocolSnip_handle_simple_node_info_request</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a4480bb3738c2db61ebf4ee6667c4eee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Simple Node Information Request message.  <br /></td></tr>
<tr class="separator:a4480bb3738c2db61ebf4ee6667c4eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627c27accd1419434607d03030548079" id="r_a627c27accd1419434607d03030548079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627c27accd1419434607d03030548079">ProtocolSnip_handle_simple_node_info_reply</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a627c27accd1419434607d03030548079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Simple Node Information Reply message.  <br /></td></tr>
<tr class="separator:a627c27accd1419434607d03030548079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ec26901f3c7831ef7620dea7cc8d06" id="r_a14ec26901f3c7831ef7620dea7cc8d06"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ec26901f3c7831ef7620dea7cc8d06">ProtocolSnip_load_manufacturer_version_id</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a14ec26901f3c7831ef7620dea7cc8d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Manufacturer Version ID into SNIP reply message.  <br /></td></tr>
<tr class="separator:a14ec26901f3c7831ef7620dea7cc8d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd74deb933ebf436a89c4bd54f20ebe" id="r_a0dd74deb933ebf436a89c4bd54f20ebe"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd74deb933ebf436a89c4bd54f20ebe">ProtocolSnip_load_name</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a0dd74deb933ebf436a89c4bd54f20ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Manufacturer Name string into SNIP reply message.  <br /></td></tr>
<tr class="separator:a0dd74deb933ebf436a89c4bd54f20ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91990fd11c10daaad2092a284a893b16" id="r_a91990fd11c10daaad2092a284a893b16"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91990fd11c10daaad2092a284a893b16">ProtocolSnip_load_model</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a91990fd11c10daaad2092a284a893b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Manufacturer Model string into SNIP reply message.  <br /></td></tr>
<tr class="separator:a91990fd11c10daaad2092a284a893b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd70680bfcc3ef436ae004b06f7fb7cb" id="r_abd70680bfcc3ef436ae004b06f7fb7cb"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd70680bfcc3ef436ae004b06f7fb7cb">ProtocolSnip_load_hardware_version</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:abd70680bfcc3ef436ae004b06f7fb7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Manufacturer Hardware Version string into SNIP reply message.  <br /></td></tr>
<tr class="separator:abd70680bfcc3ef436ae004b06f7fb7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811f162e421877189fce8b6d01a0c5a8" id="r_a811f162e421877189fce8b6d01a0c5a8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a811f162e421877189fce8b6d01a0c5a8">ProtocolSnip_load_software_version</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a811f162e421877189fce8b6d01a0c5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Manufacturer Software Version string into SNIP reply message.  <br /></td></tr>
<tr class="separator:a811f162e421877189fce8b6d01a0c5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1fd41f4f0fa107b5cd64562562a222" id="r_a5c1fd41f4f0fa107b5cd64562562a222"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c1fd41f4f0fa107b5cd64562562a222">ProtocolSnip_load_user_version_id</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a5c1fd41f4f0fa107b5cd64562562a222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads User Version ID into SNIP reply message.  <br /></td></tr>
<tr class="separator:a5c1fd41f4f0fa107b5cd64562562a222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58e7ddcdcad7e8d80b616c5a2792607" id="r_af58e7ddcdcad7e8d80b616c5a2792607"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58e7ddcdcad7e8d80b616c5a2792607">ProtocolSnip_load_user_name</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:af58e7ddcdcad7e8d80b616c5a2792607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads User Name string into SNIP reply message from configuration memory.  <br /></td></tr>
<tr class="separator:af58e7ddcdcad7e8d80b616c5a2792607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47326821545e530aa5d9227892c46caa" id="r_a47326821545e530aa5d9227892c46caa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47326821545e530aa5d9227892c46caa">ProtocolSnip_load_user_description</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg, uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a47326821545e530aa5d9227892c46caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads User Description string into SNIP reply message from configuration memory.  <br /></td></tr>
<tr class="separator:a47326821545e530aa5d9227892c46caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd288bc1780719e4078408eef25b03" id="r_ad9dd288bc1780719e4078408eef25b03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9dd288bc1780719e4078408eef25b03">ProtocolSnip_validate_snip_reply</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *snip_reply_msg)</td></tr>
<tr class="memdesc:ad9dd288bc1780719e4078408eef25b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the format of a Simple Node Information reply message.  <br /></td></tr>
<tr class="separator:ad9dd288bc1780719e4078408eef25b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple Node Information Protocol (SNIP) implementation. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a299e55a84322665954521e5e913372d8" name="a299e55a84322665954521e5e913372d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299e55a84322665954521e5e913372d8">&#9670;&#160;</a></span>ProtocolSnip_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolSnip_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__openlcb__protocol__snip__t.html">interface_openlcb_protocol_snip_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_openlcb_protocol_snip</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the Simple Node Information Protocol handler. </p>
<p>Registers the application's callback interface with the SNIP protocol handler. Must be called once during system initialization before any SNIP messages are processed.</p>
<p>The interface provides access to configuration memory for reading user-editable node information (user name and user description).</p>
<p>Use cases:</p><ul>
<li>Called during application startup</li>
<li>Required before processing SNIP request messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_openlcb_protocol_snip</td><td>Pointer to callback interface structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>interface_openlcb_protocol_snip must remain valid for lifetime of application </dd>
<dd>
config_memory_read callback must not be NULL </dd>
<dd>
NOT thread-safe - call during single-threaded initialization only</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call before enabling message reception</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__snip__t.html" title="Interface structure for Simple Node Information Protocol (SNIP) handler.">interface_openlcb_protocol_snip_t</a> - Callback interface structure</dd></dl>
<p>Initializes the Simple Node Information Protocol handler.</p>
<p>Algorithm:</p><ol type="1">
<li>Store interface pointer in static variable</li>
<li>Make callback functions available to SNIP loader functions</li>
</ol>
<p>Use cases:</p><ul>
<li>Called once during application initialization</li>
<li>Must be called before processing any SNIP requests</li>
</ul>
<pre class="fragment">* @param interface_openlcb_protocol_snip Pointer to interface structure with callbacks
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd>
<dd>
Interface must remain valid for lifetime of application</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__snip__t.html" title="Interface structure for Simple Node Information Protocol (SNIP) handler.">interface_openlcb_protocol_snip_t</a> </dd></dl>

</div>
</div>
<a id="a4480bb3738c2db61ebf4ee6667c4eee3" name="a4480bb3738c2db61ebf4ee6667c4eee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4480bb3738c2db61ebf4ee6667c4eee3">&#9670;&#160;</a></span>ProtocolSnip_handle_simple_node_info_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolSnip_handle_simple_node_info_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Simple Node Information Request message. </p>
<p>Processes an incoming SNIP request (MTI 0x0DE8) and generates a SNIP reply containing all node identification information. Loads manufacturer data from node parameters and user data from configuration memory.</p>
<p>The reply message contains eight fields in sequence:</p><ol type="1">
<li>Manufacturer version ID (1 byte)</li>
<li>Manufacturer name (null-terminated string)</li>
<li>Model (null-terminated string)</li>
<li>Hardware version (null-terminated string)</li>
<li>Software version (null-terminated string)</li>
<li>User version ID (1 byte)</li>
<li>User name (null-terminated string from config memory)</li>
<li>User description (null-terminated string from config memory)</li>
</ol>
<p>Use cases:</p><ul>
<li>Configuration tools requesting node identification</li>
<li>Network browsers displaying node information</li>
<li>Diagnostic tools identifying nodes</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL </dd>
<dd>
config_memory_read callback must be valid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sets outgoing_msg_info.valid to true with SNIP reply </dd>
<dd>
Reply MTI is 0x0A08 (Simple Node Info Reply) </dd>
<dd>
Maximum SNIP reply length is 253 bytes</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Requires configuration memory read callback for user data</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a14ec26901f3c7831ef7620dea7cc8d06" title="Loads Manufacturer Version ID into SNIP reply message.">ProtocolSnip_load_manufacturer_version_id</a> - Loads manufacturer version </dd>
<dd>
<a class="el" href="#a0dd74deb933ebf436a89c4bd54f20ebe" title="Loads Manufacturer Name string into SNIP reply message.">ProtocolSnip_load_name</a> - Loads manufacturer name </dd>
<dd>
<a class="el" href="#a91990fd11c10daaad2092a284a893b16" title="Loads Manufacturer Model string into SNIP reply message.">ProtocolSnip_load_model</a> - Loads model string </dd>
<dd>
<a class="el" href="#abd70680bfcc3ef436ae004b06f7fb7cb" title="Loads Manufacturer Hardware Version string into SNIP reply message.">ProtocolSnip_load_hardware_version</a> - Loads hardware version </dd>
<dd>
<a class="el" href="#a811f162e421877189fce8b6d01a0c5a8" title="Loads Manufacturer Software Version string into SNIP reply message.">ProtocolSnip_load_software_version</a> - Loads software version </dd>
<dd>
<a class="el" href="#a5c1fd41f4f0fa107b5cd64562562a222" title="Loads User Version ID into SNIP reply message.">ProtocolSnip_load_user_version_id</a> - Loads user version </dd>
<dd>
<a class="el" href="#af58e7ddcdcad7e8d80b616c5a2792607" title="Loads User Name string into SNIP reply message from configuration memory.">ProtocolSnip_load_user_name</a> - Loads user name from config memory </dd>
<dd>
<a class="el" href="#a47326821545e530aa5d9227892c46caa" title="Loads User Description string into SNIP reply message from configuration memory.">ProtocolSnip_load_user_description</a> - Loads user description from config memory</dd></dl>
<p>Handles Simple Node Information Request message.</p>
<p>Algorithm:</p><ol type="1">
<li>Initialize payload offset to 0</li>
<li>Load OpenLCB message header with SNIP reply MTI</li>
<li>Call loader functions in sequence:<ul>
<li>Manufacturer Version ID (1 byte)</li>
<li>Manufacturer Name (max LEN_SNIP_NAME_BUFFER-1)</li>
<li>Model (max LEN_SNIP_MODEL_BUFFER-1)</li>
<li>Hardware Version (max LEN_SNIP_HARDWARE_VERSION_BUFFER-1)</li>
<li>Software Version (max LEN_SNIP_SOFTWARE_VERSION_BUFFER-1)</li>
<li>User Version ID (1 byte)</li>
<li>User Name (max LEN_SNIP_USER_NAME_BUFFER-1)</li>
<li>User Description (max LEN_SNIP_USER_DESCRIPTION_BUFFER-1)</li>
</ul>
</li>
<li>Set outgoing message valid flag</li>
</ol>
<p>Use cases:</p><ul>
<li>Processing MTI_SIMPLE_NODE_INFO_REQUEST</li>
<li>Responding to SNIP queries from other nodes</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd>
<dd>
Node must be initialized</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each loader function updates the offset </dd>
<dd>
Reply is sent to the requesting node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mti__snip.html#gadd8a52b3e09f012fba40d438144f5996" title="Response with SNIP data (manufacturer and user info)">MTI_SIMPLE_NODE_INFO_REPLY</a> </dd></dl>

</div>
</div>
<a id="a627c27accd1419434607d03030548079" name="a627c27accd1419434607d03030548079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627c27accd1419434607d03030548079">&#9670;&#160;</a></span>ProtocolSnip_handle_simple_node_info_reply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolSnip_handle_simple_node_info_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Simple Node Information Reply message. </p>
<p>Processes an incoming SNIP reply (MTI 0x0A08) from another node on the network. This handler is used when this node acts as a configuration tool requesting information from other nodes.</p>
<p>Use cases:</p><ul>
<li>Configuration tool receiving node identification data</li>
<li>Network browser collecting node information</li>
<li>Diagnostic tool cataloging network nodes</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Application should parse SNIP data from incoming message payload</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad9dd288bc1780719e4078408eef25b03" title="Validates the format of a Simple Node Information reply message.">ProtocolSnip_validate_snip_reply</a> - Validates <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467abe8ba0ab660a42ba2ab8aa7cdc1aa98c">SNIP</a> reply format</dd></dl>
<p>Handles Simple Node Information Reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Set outgoing message valid flag to false (no reply needed)</li>
</ol>
<p>Use cases:</p><ul>
<li>Processing MTI_SIMPLE_NODE_INFO_REPLY from other nodes</li>
<li>Receiving SNIP information from queried nodes</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context
* </pre><dl class="section note"><dt>Note</dt><dd>This is a stub - application can override to process replies </dd>
<dd>
No outgoing message generated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mti__snip.html#gadd8a52b3e09f012fba40d438144f5996" title="Response with SNIP data (manufacturer and user info)">MTI_SIMPLE_NODE_INFO_REPLY</a> </dd></dl>

</div>
</div>
<a id="a14ec26901f3c7831ef7620dea7cc8d06" name="a14ec26901f3c7831ef7620dea7cc8d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ec26901f3c7831ef7620dea7cc8d06">&#9670;&#160;</a></span>ProtocolSnip_load_manufacturer_version_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_manufacturer_version_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads Manufacturer Version ID into SNIP reply message. </p>
<p>Copies the manufacturer version ID byte from the node parameters into the outgoing message payload at the specified offset. The version ID is a single byte indicating the version of the manufacturer information structure.</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>First field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing manufacturer version in parameters </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where version byte should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (typically 1 for version byte)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (always 1 for version ID)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
Version byte is typically 0x04 for current SNIP specification</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply</dd></dl>
<p>Loads Manufacturer Version ID into SNIP reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Check if requested_bytes &gt; 0</li>
<li>If yes: Call _process_snip_version with manufacturer version byte</li>
<li>If no: Return 0</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value, or 0 if no bytes requested</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_version </dd></dl>

</div>
</div>
<a id="a0dd74deb933ebf436a89c4bd54f20ebe" name="a0dd74deb933ebf436a89c4bd54f20ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd74deb933ebf436a89c4bd54f20ebe">&#9670;&#160;</a></span>ProtocolSnip_load_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads Manufacturer Name string into SNIP reply message. </p>
<p>Copies the manufacturer name string from node parameters into the outgoing message payload at the specified offset. The string is null-terminated and typically contains the company or organization name that manufactured the node.</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Second field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing manufacturer name in parameters </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where string should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (includes null terminator)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (may be less than requested if string is shorter)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
String is null-terminated in the payload </dd>
<dd>
If string exceeds requested_bytes, it may be truncated without null terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply</dd></dl>
<p>Loads Manufacturer Name string into SNIP reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Call _process_snip_string with manufacturer name from node parameters</li>
<li>String is limited to LEN_SNIP_NAME_BUFFER size</li>
<li>Return updated offset value</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_string </dd></dl>

</div>
</div>
<a id="a91990fd11c10daaad2092a284a893b16" name="a91990fd11c10daaad2092a284a893b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91990fd11c10daaad2092a284a893b16">&#9670;&#160;</a></span>ProtocolSnip_load_model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads Manufacturer Model string into SNIP reply message. </p>
<p>Copies the model name string from node parameters into the outgoing message payload at the specified offset. The string is null-terminated and typically contains the product model name or number.</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Third field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing model name in parameters </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where string should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (includes null terminator)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (may be less than requested if string is shorter)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
String is null-terminated in the payload </dd>
<dd>
If string exceeds requested_bytes, it may be truncated without null terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply</dd></dl>
<p>Loads Manufacturer Model string into SNIP reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Call _process_snip_string with model string from node parameters</li>
<li>String is limited to LEN_SNIP_MODEL_BUFFER size</li>
<li>Return updated offset value</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_string </dd></dl>

</div>
</div>
<a id="abd70680bfcc3ef436ae004b06f7fb7cb" name="abd70680bfcc3ef436ae004b06f7fb7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd70680bfcc3ef436ae004b06f7fb7cb">&#9670;&#160;</a></span>ProtocolSnip_load_hardware_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_hardware_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads Manufacturer Hardware Version string into SNIP reply message. </p>
<p>Copies the hardware version string from node parameters into the outgoing message payload at the specified offset. The string is null-terminated and typically contains hardware revision information (e.g., "1.0", "Rev A", "v2.1").</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Fourth field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing hardware version in parameters </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where string should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (includes null terminator)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (may be less than requested if string is shorter)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
String is null-terminated in the payload </dd>
<dd>
If string exceeds requested_bytes, it may be truncated without null terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply</dd></dl>
<p>Loads Manufacturer Hardware Version string into SNIP reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Call _process_snip_string with hardware version from node parameters</li>
<li>String is limited to LEN_SNIP_HARDWARE_VERSION_BUFFER size</li>
<li>Return updated offset value</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_string </dd></dl>

</div>
</div>
<a id="a811f162e421877189fce8b6d01a0c5a8" name="a811f162e421877189fce8b6d01a0c5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811f162e421877189fce8b6d01a0c5a8">&#9670;&#160;</a></span>ProtocolSnip_load_software_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_software_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads Manufacturer Software Version string into SNIP reply message. </p>
<p>Copies the software version string from node parameters into the outgoing message payload at the specified offset. The string is null-terminated and typically contains firmware or software version information (e.g., "1.0.5", "v2.3 beta").</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Fifth field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing software version in parameters </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where string should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (includes null terminator)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (may be less than requested if string is shorter)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
String is null-terminated in the payload </dd>
<dd>
If string exceeds requested_bytes, it may be truncated without null terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply</dd></dl>
<p>Loads Manufacturer Software Version string into SNIP reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Call _process_snip_string with software version from node parameters</li>
<li>String is limited to LEN_SNIP_SOFTWARE_VERSION_BUFFER size</li>
<li>Return updated offset value</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_string </dd></dl>

</div>
</div>
<a id="a5c1fd41f4f0fa107b5cd64562562a222" name="a5c1fd41f4f0fa107b5cd64562562a222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1fd41f4f0fa107b5cd64562562a222">&#9670;&#160;</a></span>ProtocolSnip_load_user_version_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_user_version_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads User Version ID into SNIP reply message. </p>
<p>Copies the user version ID byte from node parameters into the outgoing message payload at the specified offset. The version ID is a single byte indicating the version of the user information structure.</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Sixth field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing user version in parameters </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where version byte should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (typically 1 for version byte)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (always 1 for version ID)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
Version byte is typically 0x02 for current SNIP specification</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply</dd></dl>
<p>Loads User Version ID into SNIP reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Check if requested_bytes &gt; 0</li>
<li>If yes: Call _process_snip_version with user version byte</li>
<li>If no: Return 0</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value, or 0 if no bytes requested</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_version </dd></dl>

</div>
</div>
<a id="af58e7ddcdcad7e8d80b616c5a2792607" name="af58e7ddcdcad7e8d80b616c5a2792607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58e7ddcdcad7e8d80b616c5a2792607">&#9670;&#160;</a></span>ProtocolSnip_load_user_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_user_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads User Name string into SNIP reply message from configuration memory. </p>
<p>Reads the user-assigned name from configuration memory and copies it into the outgoing message payload at the specified offset. The string is null-terminated and contains a user-editable friendly name for the node (e.g., "East Yard Turnout 1").</p>
<p>Uses the config_memory_read callback to access the ACDI User address space at USER_DEFINED_CONFIG_MEM_USER_NAME_ADDRESS. The user name can be edited via configuration tools or the Memory Configuration Protocol.</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Seventh field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node for configuration memory access </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where string should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (includes null terminator)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (may be less than requested if string is shorter)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds </dd>
<dd>
config_memory_read callback must be valid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
String is null-terminated in the payload </dd>
<dd>
Default maximum length is 63 bytes </dd>
<dd>
If string exceeds requested_bytes, it may be truncated without null terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply </dd>
<dd>
<a class="el" href="structinterface__openlcb__protocol__snip__t.html" title="Interface structure for Simple Node Information Protocol (SNIP) handler.">interface_openlcb_protocol_snip_t</a> - Provides config_memory_read callback</dd></dl>
<p>Loads User Name string into SNIP reply message from configuration memory.</p>
<p>Algorithm:</p><ol type="1">
<li>Calculate data address (USER_DEFINED_CONFIG_MEM_USER_NAME_ADDRESS)</li>
<li>Add low_address offset if valid</li>
<li>Read string from configuration memory using callback</li>
<li>Call _process_snip_string with read data</li>
<li>String is limited to LEN_SNIP_USER_NAME_BUFFER size</li>
<li>Return updated offset value</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated </dd>
<dd>
User name is read from configuration memory, not node parameters</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_string </dd>
<dd>
<a class="el" href="group__user__config__constants.html#ga5ac77ac899b0afb5faeba64e61eda7b9" title="Address in Configuration Memory for user-defined node name.">USER_DEFINED_CONFIG_MEM_USER_NAME_ADDRESS</a> </dd></dl>

</div>
</div>
<a id="a47326821545e530aa5d9227892c46caa" name="a47326821545e530aa5d9227892c46caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47326821545e530aa5d9227892c46caa">&#9670;&#160;</a></span>ProtocolSnip_load_user_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolSnip_load_user_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>outgoing_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads User Description string into SNIP reply message from configuration memory. </p>
<p>Reads the user-assigned description from configuration memory and copies it into the outgoing message payload at the specified offset. The string is null-terminated and contains a user-editable description of the node (e.g., "Controls turnout motor 1").</p>
<p>Uses the config_memory_read callback to access the ACDI User address space at USER_DEFINED_CONFIG_MEM_USER_DESCRIPTION_ADDRESS. The user description can be edited via configuration tools or the Memory Configuration Protocol.</p>
<p>Use cases:</p><ul>
<li>Building SNIP reply message</li>
<li>Eighth (final) field in SNIP data sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node for configuration memory access </td></tr>
    <tr><td class="paramname">outgoing_msg</td><td>Pointer to message being constructed with SNIP data </td></tr>
    <tr><td class="paramname">offset</td><td>Payload index where string should be written </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Maximum number of bytes to copy (includes null terminator)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually copied (may be less than requested if string is shorter)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All parameters must NOT be NULL </dd>
<dd>
offset must be valid within message payload bounds </dd>
<dd>
config_memory_read callback must be valid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically updates outgoing_msg payload_count </dd>
<dd>
String is null-terminated in the payload </dd>
<dd>
Default maximum length is 64 bytes </dd>
<dd>
If string exceeds requested_bytes, it may be truncated without null terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4480bb3738c2db61ebf4ee6667c4eee3" title="Handles Simple Node Information Request message.">ProtocolSnip_handle_simple_node_info_request</a> - Uses this to build reply </dd>
<dd>
<a class="el" href="structinterface__openlcb__protocol__snip__t.html" title="Interface structure for Simple Node Information Protocol (SNIP) handler.">interface_openlcb_protocol_snip_t</a> - Provides config_memory_read callback</dd></dl>
<p>Loads User Description string into SNIP reply message from configuration memory.</p>
<p>Algorithm:</p><ol type="1">
<li>Calculate data address (USER_DEFINED_CONFIG_MEM_USER_DESCRIPTION_ADDRESS)</li>
<li>Add low_address offset if valid</li>
<li>Read string from configuration memory using callback</li>
<li>Call _process_snip_string with read data</li>
<li>String is limited to LEN_SNIP_USER_DESCRIPTION_BUFFER size</li>
<li>Return updated offset value</li>
</ol>
<p>Use cases:</p><ul>
<li>Building SNIP reply messages</li>
<li>Responding to Simple Node Info Request</li>
</ul>
<pre class="fragment">* @param openlcb_node Node being requested for the information
* </pre> <pre class="fragment">* @param outgoing_msg Message to load the information into its payload
* </pre> <pre class="fragment">* @param offset The payload index to copy the information to
* </pre> <pre class="fragment">* @param requested_bytes The max number of bytes to copy
* </pre><dl class="section return"><dt>Returns</dt><dd>Updated offset value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The OpenLCB message's Payload Count is auto-updated </dd>
<dd>
User description is read from configuration memory, not node parameters</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_process_snip_string </dd>
<dd>
<a class="el" href="group__user__config__constants.html#ga88abaa583b85af01cfe62c2e34fd0437" title="Address in Configuration Memory for user description.">USER_DEFINED_CONFIG_MEM_USER_DESCRIPTION_ADDRESS</a> </dd></dl>

</div>
</div>
<a id="ad9dd288bc1780719e4078408eef25b03" name="ad9dd288bc1780719e4078408eef25b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dd288bc1780719e4078408eef25b03">&#9670;&#160;</a></span>ProtocolSnip_validate_snip_reply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtocolSnip_validate_snip_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>snip_reply_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the format of a Simple Node Information reply message. </p>
<p>Checks that a SNIP reply message conforms to the protocol specification by verifying:</p><ul>
<li>Message MTI is correct (0x0A08)</li>
<li>Payload length is within valid range</li>
<li>Payload contains exactly 6 null terminators (separating 6 string fields)</li>
</ul>
<p>Use cases:</p><ul>
<li>Validating received SNIP replies before parsing</li>
<li>Detecting malformed SNIP data</li>
<li>Configuration tool data validation</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snip_reply_msg</td><td>Pointer to message to validate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if message is a valid SNIP reply, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>snip_reply_msg must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid SNIP format has 8 fields: 2 version bytes + 6 null-terminated strings </dd>
<dd>
Maximum SNIP reply length is 253 bytes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a627c27accd1419434607d03030548079" title="Handles Simple Node Information Reply message.">ProtocolSnip_handle_simple_node_info_reply</a> - Should validate before parsing</dd></dl>
<p>Validates the format of a Simple Node Information reply message.</p>
<p>Algorithm:</p><ol type="1">
<li>Check payload size doesn't exceed LEN_MESSAGE_BYTES_SNIP</li>
<li>Verify MTI is MTI_SIMPLE_NODE_INFO_REPLY</li>
<li>Count null terminators in payload</li>
<li>Verify exactly 6 null terminators present (one per field after version bytes)</li>
</ol>
<p>Use cases:</p><ul>
<li>Validating received SNIP replies</li>
<li>Detecting malformed SNIP messages</li>
</ul>
<pre class="fragment">* @param snip_reply_msg Pointer to message to validate
* </pre><dl class="section return"><dt>Returns</dt><dd>true if message is valid SNIP reply, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns false for oversized payloads </dd>
<dd>
Returns false for incorrect MTI </dd>
<dd>
Returns false if null terminator count is not 6</dd></dl>
<dl class="section note"><dt>Note</dt><dd>SNIP format requires exactly 6 null-terminated strings</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mti__snip.html#gadd8a52b3e09f012fba40d438144f5996" title="Response with SNIP data (manufacturer and user info)">MTI_SIMPLE_NODE_INFO_REPLY</a> </dd>
<dd>
<a class="el" href="group__buffer__size__constants.html#gac622153763bbbd4970a00d7ec2f7f737" title="SNIP message payload size (also covers Events with Payload)">LEN_MESSAGE_BYTES_SNIP</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
