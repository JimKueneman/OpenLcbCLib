<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: interface_can_rx_statemachine_t Struct Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">interface_can_rx_statemachine_t Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Interface structure for CAN receive state machine callback functions.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:acc847b73ff968af8107375cff87361d4" id="r_acc847b73ff968af8107375cff87361d4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc847b73ff968af8107375cff87361d4">handle_can_legacy_snip</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td></tr>
<tr class="memdesc:acc847b73ff968af8107375cff87361d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle legacy SNIP messages without framing bits.  <br /></td></tr>
<tr class="separator:acc847b73ff968af8107375cff87361d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1973119244adeb99dd8b457819402769" id="r_a1973119244adeb99dd8b457819402769"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1973119244adeb99dd8b457819402769">handle_single_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td></tr>
<tr class="memdesc:a1973119244adeb99dd8b457819402769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle single-frame OpenLCB messages.  <br /></td></tr>
<tr class="separator:a1973119244adeb99dd8b457819402769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c3866a768988783ce81268322f5513" id="r_a76c3866a768988783ce81268322f5513"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76c3866a768988783ce81268322f5513">handle_first_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td></tr>
<tr class="memdesc:a76c3866a768988783ce81268322f5513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle first frame of multi-frame messages.  <br /></td></tr>
<tr class="separator:a76c3866a768988783ce81268322f5513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c30ca82b5ef1ec2a9994ecb03ff0dfc" id="r_a3c30ca82b5ef1ec2a9994ecb03ff0dfc"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c30ca82b5ef1ec2a9994ecb03ff0dfc">handle_middle_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index)</td></tr>
<tr class="memdesc:a3c30ca82b5ef1ec2a9994ecb03ff0dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle middle frames of multi-frame messages.  <br /></td></tr>
<tr class="separator:a3c30ca82b5ef1ec2a9994ecb03ff0dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1c71b477d43270b643f6fa9d403afe" id="r_afa1c71b477d43270b643f6fa9d403afe"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1c71b477d43270b643f6fa9d403afe">handle_last_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index)</td></tr>
<tr class="memdesc:afa1c71b477d43270b643f6fa9d403afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle last frame of multi-frame messages.  <br /></td></tr>
<tr class="separator:afa1c71b477d43270b643f6fa9d403afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abd7c437fda69edaa4266d367980989" id="r_a0abd7c437fda69edaa4266d367980989"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0abd7c437fda69edaa4266d367980989">handle_stream_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td></tr>
<tr class="memdesc:a0abd7c437fda69edaa4266d367980989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle stream protocol CAN frames.  <br /></td></tr>
<tr class="separator:a0abd7c437fda69edaa4266d367980989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef989e56f82c30837a1b0fffe625afd0" id="r_aef989e56f82c30837a1b0fffe625afd0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef989e56f82c30837a1b0fffe625afd0">handle_rid_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:aef989e56f82c30837a1b0fffe625afd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle RID (Reserve ID) CAN control frames.  <br /></td></tr>
<tr class="separator:aef989e56f82c30837a1b0fffe625afd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da304fae443a31b42e0fe0ce1d5aeb5" id="r_a2da304fae443a31b42e0fe0ce1d5aeb5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2da304fae443a31b42e0fe0ce1d5aeb5">handle_amd_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:a2da304fae443a31b42e0fe0ce1d5aeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle AMD (Alias Map Definition) CAN control frames.  <br /></td></tr>
<tr class="separator:a2da304fae443a31b42e0fe0ce1d5aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307eca25fca1f8ffc86346d54fdedd45" id="r_a307eca25fca1f8ffc86346d54fdedd45"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307eca25fca1f8ffc86346d54fdedd45">handle_ame_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:a307eca25fca1f8ffc86346d54fdedd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle AME (Alias Map Enquiry) CAN control frames.  <br /></td></tr>
<tr class="separator:a307eca25fca1f8ffc86346d54fdedd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c3bdf270a4d79b8f9d33153f1b798c" id="r_a03c3bdf270a4d79b8f9d33153f1b798c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c3bdf270a4d79b8f9d33153f1b798c">handle_amr_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:a03c3bdf270a4d79b8f9d33153f1b798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle AMR (Alias Map Reset) CAN control frames.  <br /></td></tr>
<tr class="separator:a03c3bdf270a4d79b8f9d33153f1b798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec8b91f618746f781b94154313764ad" id="r_aaec8b91f618746f781b94154313764ad"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec8b91f618746f781b94154313764ad">handle_error_info_report_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:aaec8b91f618746f781b94154313764ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle error information report CAN control frames.  <br /></td></tr>
<tr class="separator:aaec8b91f618746f781b94154313764ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0e0cb0d2e7d8c2ceaf9e0837b51e25" id="r_a0d0e0cb0d2e7d8c2ceaf9e0837b51e25"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d0e0cb0d2e7d8c2ceaf9e0837b51e25">handle_cid_frame</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:a0d0e0cb0d2e7d8c2ceaf9e0837b51e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to handle CID (Check ID) CAN control frames.  <br /></td></tr>
<tr class="separator:a0d0e0cb0d2e7d8c2ceaf9e0837b51e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e0e61d6e690cb434694399ee865976" id="r_a91e0e61d6e690cb434694399ee865976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="can__types_8h.html#a6742a625d665303b409391926b8a65b1">alias_mapping_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e0e61d6e690cb434694399ee865976">alias_mapping_find_mapping_by_alias</a> )(uint16_t alias)</td></tr>
<tr class="memdesc:a91e0e61d6e690cb434694399ee865976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to find alias mapping by alias.  <br /></td></tr>
<tr class="separator:a91e0e61d6e690cb434694399ee865976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e23c8dcaedb643f11cb3c3791e7aad" id="r_a74e23c8dcaedb643f11cb3c3791e7aad"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74e23c8dcaedb643f11cb3c3791e7aad">on_receive</a> )(<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:a74e23c8dcaedb643f11cb3c3791e7aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional callback for application notification on frame reception.  <br /></td></tr>
<tr class="separator:a74e23c8dcaedb643f11cb3c3791e7aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface structure for CAN receive state machine callback functions. </p>
<p>This structure defines the callback interface for the CAN receive state machine, which serves as the primary entry point from the hardware CAN driver into the OpenLCB library. The state machine decodes incoming CAN frames, determines their type and purpose, and dispatches to appropriate message handlers for processing.</p>
<p>The CAN Rx state machine performs frame classification and routing:</p>
<p>CAN Frame Type Detection: The state machine examines the 29-bit CAN identifier to determine frame type:</p><ul>
<li>Bit 27 = 0: CAN control frame (CID, RID, AMD, AME, AMR, error)</li>
<li>Bit 27 = 1: OpenLCB message frame (requires further decoding)</li>
</ul>
<p>CAN Control Frame Routing (Bit 27 = 0):</p><ul>
<li>CID frames (0x07xx): Check ID during alias allocation → handle_cid_frame</li>
<li>RID frames (0x0700): Reserve ID claim → handle_rid_frame</li>
<li>AMD frames (0x0701): Alias Map Definition → handle_amd_frame</li>
<li>AME frames (0x0702): Alias Map Enquiry → handle_ame_frame</li>
<li>AMR frames (0x0703): Alias Map Reset → handle_amr_frame</li>
<li>Error frames (0x071x): Error information → handle_error_info_report_frame</li>
</ul>
<p>OpenLCB Message Frame Routing (Bit 27 = 1): The state machine extracts additional information from the CAN header:</p><ul>
<li>MTI (Message Type Indicator) from bits in header</li>
<li>Addressing (global vs addressed) from bit 3</li>
<li>Frame type (stream/datagram) from bit 12</li>
</ul>
<p>Multi-Frame Message Assembly: For OpenLCB messages, the state machine examines framing bits in first payload byte:</p><ul>
<li>00 (ONLY): Complete message in one frame → handle_single_frame</li>
<li>01 (FIRST): Start of multi-frame sequence → handle_first_frame</li>
<li>10 (LAST): Final frame of sequence → handle_last_frame</li>
<li>11 (MIDDLE): Continuation frame → handle_middle_frame</li>
</ul>
<p>Legacy Protocol Support:</p><ul>
<li>Legacy SNIP: Special handling for SNIP messages without framing bits Uses NULL byte counting instead of framing flags → handle_can_legacy_snip</li>
</ul>
<p>Stream Protocol Support:</p><ul>
<li>Stream frames: For continuous data transfer (future implementation) → handle_stream_frame</li>
</ul>
<p>Payload Offset Calculation: The state machine determines where OpenLCB data begins in CAN payload:</p><ul>
<li>Addressed messages: offset = 2 (first 2 bytes contain destination alias)</li>
<li>Global messages: offset = 0 (no destination, data starts immediately)</li>
</ul>
<p>Alias Mapping Integration: The state machine validates addressed messages by checking if destination alias belongs to one of our nodes before dispatching to handlers. Uses:</p><ul>
<li>alias_mapping_find_mapping_by_alias callback for validation</li>
</ul>
<p>All 13 required callbacks (12 message handlers + 1 alias lookup) must be provided for proper frame processing. One optional callback (on_receive) allows application notification for monitoring or statistics gathering.</p>
<p>The state machine is invoked from interrupt/thread context via CanRxStatemachine_incoming_can_driver_callback, which is called by the hardware driver when a frame is received.</p>
<dl class="section note"><dt>Note</dt><dd>13 callbacks are REQUIRED, 1 callback is Optional </dd>
<dd>
State machine called from interrupt/thread context </dd>
<dd>
Dispatches synchronously - handlers must execute quickly</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__rx__statemachine_8c.html#a90ffc180158c3b8810f3cd68fc904b65" title="Initializes the CAN Receive State Machine module.">CanRxStatemachine_initialize</a> </dd>
<dd>
<a class="el" href="can__rx__statemachine_8c.html#a1dc58af220edcb563f76d5efc256eafe" title="Main entry point for incoming CAN frames from hardware driver.">CanRxStatemachine_incoming_can_driver_callback</a> </dd>
<dd>
<a class="el" href="can__rx__message__handler_8h.html" title="Message handlers for processing received CAN frames.">can_rx_message_handler.h</a> - Message handler implementations </dd></dl>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="acc847b73ff968af8107375cff87361d4" name="acc847b73ff968af8107375cff87361d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc847b73ff968af8107375cff87361d4">&#9670;&#160;</a></span>handle_can_legacy_snip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_can_legacy_snip) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle legacy SNIP messages without framing bits. </p>
<p>This required callback processes SNIP (Simple Node Information Protocol) messages from early OpenLCB implementations that predate the standard multi-frame framing bit protocol. Instead of using framing bits, legacy SNIP uses NULL byte counting to detect message completion (exactly 6 NULL terminators required).</p>
<p>The callback should:</p><ul>
<li>Find or allocate in-progress SNIP message in buffer list</li>
<li>Append payload data to message</li>
<li>Count NULL bytes in accumulated payload</li>
<li>When 6 NULLs found, mark message complete and push to OpenLCB FIFO</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_can_legacy_snip</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Only used for MTI 0x0A08 (Simple Node Info Reply) from legacy nodes </dd></dl>

</div>
</div>
<a id="a1973119244adeb99dd8b457819402769" name="a1973119244adeb99dd8b457819402769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1973119244adeb99dd8b457819402769">&#9670;&#160;</a></span>handle_single_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_single_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle single-frame OpenLCB messages. </p>
<p>This required callback processes complete OpenLCB messages that fit entirely within one CAN frame. These are the most common message type for events, short commands, and replies.</p>
<p>The callback should:</p><ul>
<li>Allocate OpenLCB buffer of appropriate type</li>
<li>Extract source alias, destination alias (if addressed), and MTI from CAN header</li>
<li>Copy payload data from CAN frame to OpenLCB message</li>
<li>Push complete message to OpenLCB FIFO for protocol processing</li>
</ul>
<p>Framing bits for single-frame messages:</p><ul>
<li>00 (MULTIFRAME_ONLY) or no framing bits present</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_single_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Most common message type (events, short commands) </dd></dl>

</div>
</div>
<a id="a76c3866a768988783ce81268322f5513" name="a76c3866a768988783ce81268322f5513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c3866a768988783ce81268322f5513">&#9670;&#160;</a></span>handle_first_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_first_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle first frame of multi-frame messages. </p>
<p>This required callback processes the initial CAN frame of a multi-frame OpenLCB message sequence. Initiates message assembly by allocating buffer and storing first payload chunk.</p>
<p>The callback should:</p><ul>
<li>Allocate OpenLCB buffer of specified type (DATAGRAM, SNIP, etc.)</li>
<li>Extract source alias, destination alias (if addressed), and MTI from CAN header</li>
<li>Initialize OpenLCB message structure</li>
<li>Copy first payload chunk from CAN frame</li>
<li>Add message to buffer list for continued assembly</li>
</ul>
<p>Framing bits for first-frame messages:</p><ul>
<li>01 (MULTIFRAME_FIRST)</li>
</ul>
<p>Frame must be exactly 8 bytes total:</p><ul>
<li>Addressed: 2 bytes dest alias + 6 bytes data</li>
<li>Global: 8 bytes data</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_first_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Addressed frames have 2-byte destination overhead </dd></dl>

</div>
</div>
<a id="a3c30ca82b5ef1ec2a9994ecb03ff0dfc" name="a3c30ca82b5ef1ec2a9994ecb03ff0dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c30ca82b5ef1ec2a9994ecb03ff0dfc">&#9670;&#160;</a></span>handle_middle_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_middle_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle middle frames of multi-frame messages. </p>
<p>This required callback processes continuation frames in a multi-frame message sequence. Appends payload data to in-progress message being assembled in the buffer list.</p>
<p>The callback should:</p><ul>
<li>Find in-progress message in buffer list (match source, dest, MTI)</li>
<li>Append payload data from this frame to message</li>
<li>Verify frame is in correct sequence</li>
<li>Send rejection if no matching message found (out of sequence)</li>
</ul>
<p>Framing bits for middle-frame messages:</p><ul>
<li>11 (MULTIFRAME_MIDDLE)</li>
</ul>
<p>Frame must be exactly 8 bytes total:</p><ul>
<li>Addressed: 2 bytes dest alias + 6 bytes data</li>
<li>Global: 8 bytes data</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_middle_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
First frame must have been received before middle frames </dd></dl>

</div>
</div>
<a id="afa1c71b477d43270b643f6fa9d403afe" name="afa1c71b477d43270b643f6fa9d403afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1c71b477d43270b643f6fa9d403afe">&#9670;&#160;</a></span>handle_last_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_last_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle last frame of multi-frame messages. </p>
<p>This required callback processes the final CAN frame of a multi-frame message sequence. Completes message assembly and forwards to OpenLCB layer.</p>
<p>The callback should:</p><ul>
<li>Find in-progress message in buffer list (match source, dest, MTI)</li>
<li>Append final payload data from this frame</li>
<li>Mark message as complete</li>
<li>Remove from buffer list</li>
<li>Push to OpenLCB FIFO for protocol processing</li>
<li>Send rejection if no matching message found (out of sequence)</li>
</ul>
<p>Framing bits for last-frame messages:</p><ul>
<li>10 (MULTIFRAME_LAST)</li>
</ul>
<p>Frame may contain 0-8 bytes:</p><ul>
<li>Addressed: 2 bytes dest alias + 0-6 bytes data</li>
<li>Global: 0-8 bytes data</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_last_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Completes assembly and forwards message </dd></dl>

</div>
</div>
<a id="a0abd7c437fda69edaa4266d367980989" name="a0abd7c437fda69edaa4266d367980989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abd7c437fda69edaa4266d367980989">&#9670;&#160;</a></span>handle_stream_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_stream_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg, uint8_t can_buffer_start_index, <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> data_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle stream protocol CAN frames. </p>
<p>This required callback processes stream frames used for continuous high-throughput data transfer. Stream protocol is used for applications like firmware upgrades that require transferring large amounts of data efficiently.</p>
<p>The callback should:</p><ul>
<li>Process stream initiation, data, and completion frames</li>
<li>Handle stream flow control</li>
<li>Manage stream buffers</li>
</ul>
<p>Note: Stream protocol is currently not fully implemented. This is a placeholder for future functionality.</p>
<p>Typical implementation: CanRxMessageHandler_stream_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Currently unimplemented - placeholder for future use </dd></dl>

</div>
</div>
<a id="aef989e56f82c30837a1b0fffe625afd0" name="aef989e56f82c30837a1b0fffe625afd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef989e56f82c30837a1b0fffe625afd0">&#9670;&#160;</a></span>handle_rid_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_rid_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle RID (Reserve ID) CAN control frames. </p>
<p>This required callback processes RID frames which indicate a node has completed its CID sequence and is claiming its alias. If we already have this alias registered to one of our nodes, sends RID response to signal conflict.</p>
<p>The callback should:</p><ul>
<li>Extract alias from CAN identifier</li>
<li>Check if alias is already registered to our nodes</li>
<li>If conflict detected, send RID response frame</li>
</ul>
<p>RID frame format:</p><ul>
<li>CAN header: 0x0700 + alias</li>
<li>Payload: empty (0 bytes)</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_rid_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Part of CAN Frame Transfer Protocol alias allocation </dd></dl>

</div>
</div>
<a id="a2da304fae443a31b42e0fe0ce1d5aeb5" name="a2da304fae443a31b42e0fe0ce1d5aeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da304fae443a31b42e0fe0ce1d5aeb5">&#9670;&#160;</a></span>handle_amd_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_amd_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle AMD (Alias Map Definition) CAN control frames. </p>
<p>This required callback processes AMD frames which announce alias/NodeID mappings to the network. Checks for duplicate alias conditions and flags conflicts for main state machine resolution.</p>
<p>The callback should:</p><ul>
<li>Extract alias from CAN identifier</li>
<li>Extract 48-bit NodeID from 6-byte payload</li>
<li>Check for duplicate alias (same alias, different NodeID)</li>
<li>Flag duplicate if conflict detected</li>
</ul>
<p>AMD frame format:</p><ul>
<li>CAN header: 0x0701 + alias</li>
<li>Payload: 6 bytes of NodeID</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_amd_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Final step in CAN login sequence </dd></dl>

</div>
</div>
<a id="a307eca25fca1f8ffc86346d54fdedd45" name="a307eca25fca1f8ffc86346d54fdedd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307eca25fca1f8ffc86346d54fdedd45">&#9670;&#160;</a></span>handle_ame_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_ame_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle AME (Alias Map Enquiry) CAN control frames. </p>
<p>This required callback processes AME frames which request alias information from the network. Responds with AMD frames for our registered aliases.</p>
<p>The callback should:</p><ul>
<li>Check if AME is global (empty payload) or targeted (contains NodeID)</li>
<li>If global: send AMD for all our registered aliases</li>
<li>If targeted: send AMD only if NodeID matches one of our nodes</li>
</ul>
<p>AME frame format:</p><ul>
<li>CAN header: 0x0702 + alias (or 0 for global)</li>
<li>Payload: empty (global query) or 6 bytes NodeID (targeted query)</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_ame_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Gateways use AME to synchronize alias tables </dd></dl>

</div>
</div>
<a id="a03c3bdf270a4d79b8f9d33153f1b798c" name="a03c3bdf270a4d79b8f9d33153f1b798c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c3bdf270a4d79b8f9d33153f1b798c">&#9670;&#160;</a></span>handle_amr_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_amr_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle AMR (Alias Map Reset) CAN control frames. </p>
<p>This required callback processes AMR frames which command a node to release its alias. Checks for duplicate alias condition.</p>
<p>The callback should:</p><ul>
<li>Extract 48-bit NodeID from 6-byte payload</li>
<li>Check if NodeID matches any of our nodes</li>
<li>If match found, flag duplicate alias condition</li>
</ul>
<p>AMR frame format:</p><ul>
<li>CAN header: 0x0703 + alias</li>
<li>Payload: 6 bytes of NodeID</li>
</ul>
<p>Main state machine handles actual alias release and re-login.</p>
<p>Typical implementation: CanRxMessageHandler_amr_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Indicates alias conflict detected by another node </dd></dl>

</div>
</div>
<a id="aaec8b91f618746f781b94154313764ad" name="aaec8b91f618746f781b94154313764ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec8b91f618746f781b94154313764ad">&#9670;&#160;</a></span>handle_error_info_report_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_error_info_report_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle error information report CAN control frames. </p>
<p>This required callback processes error report frames from other nodes indicating network problems or protocol violations. Checks for duplicate alias condition.</p>
<p>The callback should:</p><ul>
<li>Extract error code and source information</li>
<li>Check for duplicate alias indicators</li>
<li>Flag duplicate if detected</li>
</ul>
<p>Error frame format:</p><ul>
<li>CAN header: 0x0710-0x0713 + alias</li>
<li>Payload: Error code and details</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_error_info_report_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Error reports are informational - no response required </dd></dl>

</div>
</div>
<a id="a0d0e0cb0d2e7d8c2ceaf9e0837b51e25" name="a0d0e0cb0d2e7d8c2ceaf9e0837b51e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0e0cb0d2e7d8c2ceaf9e0837b51e25">&#9670;&#160;</a></span>handle_cid_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handle_cid_frame) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to handle CID (Check ID) CAN control frames. </p>
<p>This required callback processes CID frames during another node's alias allocation sequence. If we have the alias being checked, sends RID response to indicate conflict.</p>
<p>The callback should:</p><ul>
<li>Extract alias from CAN identifier</li>
<li>Check if alias is registered to any of our nodes</li>
<li>If conflict, send RID response to signal alias in use</li>
</ul>
<p>CID sequence consists of 4 frames with NodeID fragments:</p><ul>
<li>CID7 (0x07xx): NodeID bits 47-36 in CAN header</li>
<li>CID6 (0x06xx): NodeID bits 35-24 in CAN header</li>
<li>CID5 (0x05xx): NodeID bits 23-12 in CAN header</li>
<li>CID4 (0x04xx): NodeID bits 11-0 in CAN header</li>
</ul>
<p>Typical implementation: CanRxMessageHandler_cid_frame</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Part of CAN Frame Transfer Protocol alias allocation </dd></dl>

</div>
</div>
<a id="a91e0e61d6e690cb434694399ee865976" name="a91e0e61d6e690cb434694399ee865976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e0e61d6e690cb434694399ee865976">&#9670;&#160;</a></span>alias_mapping_find_mapping_by_alias</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="can__types_8h.html#a6742a625d665303b409391926b8a65b1">alias_mapping_t</a> *(* alias_mapping_find_mapping_by_alias) (uint16_t alias)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to find alias mapping by alias. </p>
<p>This required callback searches the alias mapping table for an entry matching the specified 12-bit CAN alias. Used by state machine to validate that addressed messages are for one of our nodes before dispatching to handlers.</p>
<p>The callback should:</p><ul>
<li>Search alias mapping table for matching alias</li>
<li>Return pointer to mapping entry if found</li>
<li>Return NULL if alias not found</li>
</ul>
<p>Typical implementation: AliasMappings_find_mapping_by_alias</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd>
<dd>
Called before dispatching addressed messages to handlers </dd></dl>

</div>
</div>
<a id="a74e23c8dcaedb643f11cb3c3791e7aad" name="a74e23c8dcaedb643f11cb3c3791e7aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e23c8dcaedb643f11cb3c3791e7aad">&#9670;&#160;</a></span>on_receive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* on_receive) (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional callback for application notification on frame reception. </p>
<p>This optional callback provides immediate notification when a CAN frame is received, before any processing or routing occurs. Useful for monitoring, logging, statistics gathering, or LED indicators.</p>
<p>The callback is invoked in interrupt/thread context and must:</p><ul>
<li>Execute very quickly (microseconds, not milliseconds)</li>
<li>Not block execution</li>
<li>Not call blocking functions</li>
<li>Not perform lengthy processing</li>
</ul>
<p>Common uses:</p><ul>
<li>Increment frame counters</li>
<li>Toggle activity LEDs</li>
<li>Set flags for main loop processing</li>
<li>Timestamp frame arrival</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Optional - can be NULL if notification is not needed </dd>
<dd>
Called in interrupt/thread context - keep processing minimal </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/drivers/canbus/<a class="el" href="can__rx__statemachine_8h_source.html">can_rx_statemachine.h</a></li>
</ul>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
