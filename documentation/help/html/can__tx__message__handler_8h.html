<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/drivers/canbus/can_tx_message_handler.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c718a368270b13c54d94892d20736f45.html">drivers</a></li><li class="navelem"><a class="el" href="dir_858afec057d05dde4e87dd686afd4670.html">canbus</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">can_tx_message_handler.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Message handlers for CAN transmit operations.  
<a href="#details">More...</a></p>

<p><a href="can__tx__message__handler_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__can__tx__message__handler__t.html">interface_can_tx_message_handler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface structure for CAN transmit message handler callback functions.  <a href="structinterface__can__tx__message__handler__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4bde37fc36f08ccbbb7dd4a9a17b2713" id="r_a4bde37fc36f08ccbbb7dd4a9a17b2713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bde37fc36f08ccbbb7dd4a9a17b2713">CanTxMessageHandler_initialize</a> (const <a class="el" href="structinterface__can__tx__message__handler__t.html">interface_can_tx_message_handler_t</a> *interface_can_tx_message_handler)</td></tr>
<tr class="memdesc:a4bde37fc36f08ccbbb7dd4a9a17b2713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CAN transmit message handler module.  <br /></td></tr>
<tr class="separator:a4bde37fc36f08ccbbb7dd4a9a17b2713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d6a3b6fd0db4921dc8630934e68bba" id="r_a79d6a3b6fd0db4921dc8630934e68bba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79d6a3b6fd0db4921dc8630934e68bba">CanTxMessageHandler_addressed_msg_frame</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, <a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg_worker, uint16_t *openlcb_start_index)</td></tr>
<tr class="memdesc:a79d6a3b6fd0db4921dc8630934e68bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and transmits an addressed OpenLCB message as CAN frame(s)  <br /></td></tr>
<tr class="separator:a79d6a3b6fd0db4921dc8630934e68bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0281e625469a52aec7f1e85a464c6222" id="r_a0281e625469a52aec7f1e85a464c6222"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0281e625469a52aec7f1e85a464c6222">CanTxMessageHandler_unaddressed_msg_frame</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, <a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg_worker, uint16_t *openlcb_start_index)</td></tr>
<tr class="memdesc:a0281e625469a52aec7f1e85a464c6222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and transmits an unaddressed OpenLCB message as CAN frame(s)  <br /></td></tr>
<tr class="separator:a0281e625469a52aec7f1e85a464c6222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9223150ff58342659336a51f75caf5a" id="r_aa9223150ff58342659336a51f75caf5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9223150ff58342659336a51f75caf5a">CanTxMessageHandler_datagram_frame</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, <a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg_worker, uint16_t *openlcb_start_index)</td></tr>
<tr class="memdesc:aa9223150ff58342659336a51f75caf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and transmits a datagram OpenLCB message as CAN frame(s)  <br /></td></tr>
<tr class="separator:aa9223150ff58342659336a51f75caf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156df311b2fa14eea4912334cda0ca78" id="r_a156df311b2fa14eea4912334cda0ca78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a156df311b2fa14eea4912334cda0ca78">CanTxMessageHandler_stream_frame</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, <a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg_worker, uint16_t *openlcb_start_index)</td></tr>
<tr class="memdesc:a156df311b2fa14eea4912334cda0ca78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and transmits a stream OpenLCB message as CAN frame(s)  <br /></td></tr>
<tr class="separator:a156df311b2fa14eea4912334cda0ca78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99ced3d0e3dc246de366c88031b6596" id="r_aa99ced3d0e3dc246de366c88031b6596"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa99ced3d0e3dc246de366c88031b6596">CanTxMessageHandler_can_frame</a> (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:aa99ced3d0e3dc246de366c88031b6596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a pre-built CAN frame to the physical bus.  <br /></td></tr>
<tr class="separator:aa99ced3d0e3dc246de366c88031b6596"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Message handlers for CAN transmit operations. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</li>
</ul>
</dd></dl>
<p>Provides handlers for converting OpenLCB messages to CAN frames and transmitting them on the physical CAN bus. Handles multi-frame message fragmentation for addressed messages, unaddressed messages, datagrams, and streams.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4bde37fc36f08ccbbb7dd4a9a17b2713" name="a4bde37fc36f08ccbbb7dd4a9a17b2713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bde37fc36f08ccbbb7dd4a9a17b2713">&#9670;&#160;</a></span>CanTxMessageHandler_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CanTxMessageHandler_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__can__tx__message__handler__t.html">interface_can_tx_message_handler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_can_tx_message_handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the CAN transmit message handler module. </p>
<p>Registers the application's callback interface with the transmit message handlers. The interface provides the hardware transmission function and optional notification callback. Must be called during application startup before any CAN transmission occurs.</p>
<p>Use cases:</p><ul>
<li>Called once during application initialization</li>
<li>Required before any CAN message transmission</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_can_tx_message_handler</td><td>Pointer to interface structure containing required transmit_can_frame callback and optional on_transmit callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>interface_can_tx_message_handler must remain valid for lifetime of application </dd>
<dd>
transmit_can_frame callback must be valid (non-NULL) </dd>
<dd>
MUST be called during application initialization before any transmit operations </dd>
<dd>
NOT thread-safe - call only from main initialization context</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call after CAN hardware initialization but before CAN traffic begins </dd>
<dd>
Call before CanTxStatemachine_initialize</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__tx__message__handler__t.html" title="Interface structure for CAN transmit message handler callback functions.">interface_can_tx_message_handler_t</a> - Interface structure definition </dd>
<dd>
<a class="el" href="can__tx__statemachine_8c.html#acbe458eae799fff061319448b1855b3d" title="Initializes the CAN transmit state machine.">CanTxStatemachine_initialize</a> - Initialize transmit state machine</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Cast away const qualifier from interface pointer</li>
<li>Store interface pointer in static module variable</li>
</ol>
<p>Use cases:</p><ul>
<li>Called once during application initialization</li>
<li>Required before any CAN message transmission</li>
</ul>
<pre class="fragment">* @param interface_can_tx_message_handler Pointer to interface structure containing required function pointers
* </pre><dl class="section warning"><dt>Warning</dt><dd>MUST be called during application initialization before any transmit operations </dd>
<dd>
NOT thread-safe - call only from main initialization context</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call after CAN hardware initialization but before CAN traffic begins</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__tx__statemachine_8c.html#acbe458eae799fff061319448b1855b3d" title="Initializes the CAN transmit state machine.">CanTxStatemachine_initialize</a> - Initialize transmit state machine </dd></dl>

</div>
</div>
<a id="a79d6a3b6fd0db4921dc8630934e68bba" name="a79d6a3b6fd0db4921dc8630934e68bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d6a3b6fd0db4921dc8630934e68bba">&#9670;&#160;</a></span>CanTxMessageHandler_addressed_msg_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanTxMessageHandler_addressed_msg_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>can_msg_worker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>openlcb_start_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts and transmits an addressed OpenLCB message as CAN frame(s) </p>
<p>Handles fragmentation of addressed OpenLCB messages into one or more CAN frames with proper framing bit encoding. Addressed messages include a 12-bit destination alias in the first 2 bytes of each frame, leaving 6 bytes per frame for payload data.</p>
<p>For messages ≤6 bytes:</p><ul>
<li>Single frame with MULTIFRAME_ONLY (00) framing flags</li>
<li>Bytes 0-1: Destination alias with framing bits</li>
<li>Bytes 2-7: OpenLCB payload (up to 6 bytes)</li>
</ul>
<p>For messages &gt;6 bytes:</p><ul>
<li>FIRST frame: Bytes 0-1 destination, Bytes 2-7 first 6 payload bytes</li>
<li>MIDDLE frame(s): Bytes 0-1 destination, Bytes 2-7 next 6 payload bytes each</li>
<li>LAST frame: Bytes 0-1 destination, Bytes 2-X remaining payload (0-6 bytes)</li>
</ul>
<p>Use cases:</p><ul>
<li>Sending Protocol Support Inquiry to specific node</li>
<li>Sending Verify Node ID to specific node</li>
<li>Sending any message requiring destination address</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to OpenLCB message to transmit (must have dest_alias set) </td></tr>
    <tr><td class="paramname">can_msg_worker</td><td>Pointer to working CAN frame buffer for building frames </td></tr>
    <tr><td class="paramname">openlcb_start_index</td><td>Pointer to current position in OpenLCB payload (updated after successful transmission)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must NOT be NULL </dd>
<dd>
can_msg_worker must NOT be NULL </dd>
<dd>
openlcb_start_index must NOT be NULL </dd>
<dd>
Transmission failure leaves payload index unchanged - caller must retry </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>dest_alias in openlcb_msg must be valid (0x001-0xFFF) </dd>
<dd>
First two payload bytes reserved for destination alias in all frames </dd>
<dd>
Multi-frame messages use framing flags: only/first/middle/last </dd>
<dd>
Index is only updated on successful transmission</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Caller checks if (*openlcb_start_index == payload_count) to detect completion </dd>
<dd>
May need multiple calls to transmit complete multi-frame message</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0281e625469a52aec7f1e85a464c6222" title="Converts and transmits an unaddressed OpenLCB message as CAN frame(s)">CanTxMessageHandler_unaddressed_msg_frame</a> - For broadcast messages </dd>
<dd>
<a class="el" href="can__utilities_8c.html#a55b499e2a3270be5902c392ca29d1ce5" title="Copies payload data from OpenLCB message to CAN message.">CanUtilities_copy_openlcb_payload_to_can_payload</a> - Payload copying helper</dd></dl>
<p>Converts and transmits an addressed OpenLCB message as CAN frame(s)</p>
<p>Algorithm:</p><ol type="1">
<li>Load destination alias into first 2 payload bytes</li>
<li>Construct addressed message identifier with MTI</li>
<li>Copy OpenLCB payload to CAN payload starting at byte 2</li>
<li>Determine frame type based on total payload size:<ul>
<li>If ≤ 6 bytes: send as only frame</li>
<li>Else if at start (index &lt; 6): send as first frame</li>
<li>Else if more data remains: send as middle frame</li>
<li>Else: send as last frame</li>
</ul>
</li>
<li>If transmission successful:<ul>
<li>Increment payload index by bytes copied</li>
</ul>
</li>
<li>Return transmission result</li>
</ol>
<p>Use cases:</p><ul>
<li>Sending Protocol Support Inquiry to specific node</li>
<li>Sending Verify Node ID to specific node</li>
<li>Sending any message requiring destination address</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to OpenLCB message to transmit (must have dest_alias set)
* @param can_msg_worker Pointer to working CAN frame buffer for building frames
* @param openlcb_start_index Pointer to current position in OpenLCB payload (updated after transmission)
* </pre><dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Transmission failure leaves payload index unchanged - caller must retry </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>First two payload bytes reserved for destination alias in all frames </dd>
<dd>
Multi-frame messages use framing flags: only/first/middle/last</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0281e625469a52aec7f1e85a464c6222" title="Converts and transmits an unaddressed OpenLCB message as CAN frame(s)">CanTxMessageHandler_unaddressed_msg_frame</a> - For broadcast messages </dd>
<dd>
<a class="el" href="can__utilities_8c.html#a55b499e2a3270be5902c392ca29d1ce5" title="Copies payload data from OpenLCB message to CAN message.">CanUtilities_copy_openlcb_payload_to_can_payload</a> - Payload copying helper </dd></dl>

</div>
</div>
<a id="a0281e625469a52aec7f1e85a464c6222" name="a0281e625469a52aec7f1e85a464c6222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0281e625469a52aec7f1e85a464c6222">&#9670;&#160;</a></span>CanTxMessageHandler_unaddressed_msg_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanTxMessageHandler_unaddressed_msg_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>can_msg_worker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>openlcb_start_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts and transmits an unaddressed OpenLCB message as CAN frame(s) </p>
<p>Handles transmission of broadcast (unaddressed) OpenLCB messages that are received by all nodes on the network. These messages do not include a destination alias, allowing all 8 bytes of CAN frame payload for OpenLCB data.</p>
<p>Currently supports single-frame messages only:</p><ul>
<li>Bytes 0-7: OpenLCB payload (up to 8 bytes)</li>
<li>No framing bits required for single-frame</li>
</ul>
<p>Use cases:</p><ul>
<li>Broadcasting Initialization Complete</li>
<li>Broadcasting Producer/Consumer Event Reports</li>
<li>Broadcasting Verified Node ID</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to OpenLCB message to transmit (no dest_alias required) </td></tr>
    <tr><td class="paramname">can_msg_worker</td><td>Pointer to working CAN frame buffer for building frames </td></tr>
    <tr><td class="paramname">openlcb_start_index</td><td>Pointer to current position in OpenLCB payload (updated after successful transmission)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must NOT be NULL </dd>
<dd>
can_msg_worker must NOT be NULL </dd>
<dd>
openlcb_start_index must NOT be NULL </dd>
<dd>
Multi-frame unaddressed messages not currently implemented </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>All 8 payload bytes available (no destination alias overhead) </dd>
<dd>
Messages &gt;8 bytes will fail - check payload_count before calling</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Most broadcast messages fit in single frame (events, status reports)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a79d6a3b6fd0db4921dc8630934e68bba" title="Converts and transmits an addressed OpenLCB message as CAN frame(s)">CanTxMessageHandler_addressed_msg_frame</a> - For targeted messages</dd></dl>
<p>Converts and transmits an unaddressed OpenLCB message as CAN frame(s)</p>
<p>Algorithm:</p><ol type="1">
<li>Check if message fits in single frame (≤ 8 bytes):<ul>
<li>Copy OpenLCB payload to CAN payload</li>
<li>Construct unaddressed message identifier</li>
<li>Transmit frame</li>
<li>If successful: update payload index</li>
</ul>
</li>
<li>If multi-frame required:<ul>
<li>Currently not implemented (see TODO)</li>
</ul>
</li>
<li>Return transmission result</li>
</ol>
<p>Use cases:</p><ul>
<li>Broadcasting Initialization Complete</li>
<li>Broadcasting Producer/Consumer Event Reports</li>
<li>Broadcasting Verified Node ID</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to OpenLCB message to transmit (no dest_alias required)
* @param can_msg_worker Pointer to working CAN frame buffer for building frames
* @param openlcb_start_index Pointer to current position in OpenLCB payload (updated after transmission)
* </pre><dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Multi-frame unaddressed messages not currently implemented </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>All 8 payload bytes available (no destination alias overhead)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a79d6a3b6fd0db4921dc8630934e68bba" title="Converts and transmits an addressed OpenLCB message as CAN frame(s)">CanTxMessageHandler_addressed_msg_frame</a> - For targeted messages </dd></dl>

</div>
</div>
<a id="aa9223150ff58342659336a51f75caf5a" name="aa9223150ff58342659336a51f75caf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9223150ff58342659336a51f75caf5a">&#9670;&#160;</a></span>CanTxMessageHandler_datagram_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanTxMessageHandler_datagram_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>can_msg_worker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>openlcb_start_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts and transmits a datagram OpenLCB message as CAN frame(s) </p>
<p>Handles fragmentation of datagram messages (up to 72 bytes maximum) into multiple CAN frames using datagram frame format. Datagrams are used by protocols that need to transfer more data than fits in basic messages but don't require the high throughput of streams.</p>
<p>Frame sequence for datagrams:</p><ul>
<li>If ≤8 bytes: Single ONLY frame</li>
<li>If &gt;8 bytes: FIRST frame → MIDDLE frame(s) → LAST frame</li>
</ul>
<p>Each frame carries maximum payload:</p><ul>
<li>FIRST frame: 8 bytes</li>
<li>MIDDLE frames: 8 bytes each</li>
<li>LAST frame: Remaining bytes (1-8)</li>
</ul>
<p>Use cases:</p><ul>
<li>Sending Memory Configuration Protocol requests/replies</li>
<li>Sending Remote Button Protocol commands</li>
<li>Transmitting Configuration Definition Info (CDI)</li>
<li>Sending any datagram-based protocol data</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to OpenLCB datagram message to transmit </td></tr>
    <tr><td class="paramname">can_msg_worker</td><td>Pointer to working CAN frame buffer for building frames </td></tr>
    <tr><td class="paramname">openlcb_start_index</td><td>Pointer to current position in datagram payload (updated after successful transmission)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must NOT be NULL </dd>
<dd>
can_msg_worker must NOT be NULL </dd>
<dd>
openlcb_start_index must NOT be NULL </dd>
<dd>
Maximum datagram size is 72 bytes on CAN transport </dd>
<dd>
Transmission failure leaves payload index unchanged </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Frame sequence: only OR first→middle(s)→last </dd>
<dd>
All frames carry maximum 8 bytes except possibly last frame </dd>
<dd>
Datagrams require Datagram Received OK/Rejected acknowledgment</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Caller must check for Datagram OK/Rejected after complete transmission </dd>
<dd>
May require multiple calls to transmit complete datagram</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a156df311b2fa14eea4912334cda0ca78" title="Converts and transmits a stream OpenLCB message as CAN frame(s)">CanTxMessageHandler_stream_frame</a> - For streaming data </dd>
<dd>
<a class="el" href="protocol__datagram__handler_8h.html" title="OpenLCB datagram protocol handler interface.">protocol_datagram_handler.h</a> - Datagram protocol details</dd></dl>
<p>Converts and transmits a datagram OpenLCB message as CAN frame(s)</p>
<p>Algorithm:</p><ol type="1">
<li>Copy OpenLCB payload to CAN payload starting at current index</li>
<li>Determine frame type based on payload size and current position:<ul>
<li>If total payload ≤ 8 bytes: send as only frame</li>
<li>Else if at start (index &lt; 8): send as first frame</li>
<li>Else if more data remains: send as middle frame</li>
<li>Else: send as last frame</li>
</ul>
</li>
<li>If transmission successful:<ul>
<li>Increment payload index by bytes copied</li>
</ul>
</li>
<li>Return transmission result</li>
</ol>
<p>Use cases:</p><ul>
<li>Sending Memory Configuration Protocol requests</li>
<li>Sending Remote Button Protocol commands</li>
<li>Transmitting any datagram-based protocol data</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to OpenLCB datagram message to transmit
* @param can_msg_worker Pointer to working CAN frame buffer for building frames
* @param openlcb_start_index Pointer to current position in datagram payload (updated after transmission)
* </pre><dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Maximum datagram size is 72 bytes on CAN transport </dd>
<dd>
Transmission failure leaves payload index unchanged </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Frame sequence: only OR first→middle(s)→last </dd>
<dd>
All frames carry maximum 8 bytes except possibly last frame</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a156df311b2fa14eea4912334cda0ca78" title="Converts and transmits a stream OpenLCB message as CAN frame(s)">CanTxMessageHandler_stream_frame</a> - For streaming data </dd></dl>

</div>
</div>
<a id="a156df311b2fa14eea4912334cda0ca78" name="a156df311b2fa14eea4912334cda0ca78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156df311b2fa14eea4912334cda0ca78">&#9670;&#160;</a></span>CanTxMessageHandler_stream_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanTxMessageHandler_stream_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>can_msg_worker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>openlcb_start_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts and transmits a stream OpenLCB message as CAN frame(s) </p>
<p>Handles transmission of streaming data messages for high-throughput continuous data transfer. Stream protocol is designed for applications requiring efficient transfer of large amounts of data, such as firmware upgrades.</p>
<p>Stream protocol features (when fully implemented):</p><ul>
<li>Flow control for preventing receiver buffer overflow</li>
<li>High-throughput continuous transfer</li>
<li>Error detection and recovery</li>
<li>Progress monitoring</li>
</ul>
<p>Use cases (future):</p><ul>
<li>Firmware upgrade data transfer</li>
<li>Large configuration file transfers</li>
<li>Continuous sensor data streaming</li>
<li>Log file downloads</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to OpenLCB stream message to transmit </td></tr>
    <tr><td class="paramname">can_msg_worker</td><td>Pointer to working CAN frame buffer for building frames </td></tr>
    <tr><td class="paramname">openlcb_start_index</td><td>Pointer to current position in stream payload (updated after successful transmission)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently always returns true (placeholder implementation)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must NOT be NULL </dd>
<dd>
can_msg_worker must NOT be NULL </dd>
<dd>
openlcb_start_index must NOT be NULL </dd>
<dd>
Stream protocol NOT fully implemented - placeholder only </dd>
<dd>
Do not rely on this function for production stream transfers </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Function requires full implementation before production use </dd>
<dd>
Stream protocol complex - requires flow control, error handling</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Placeholder returns success without transmitting</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa9223150ff58342659336a51f75caf5a" title="Converts and transmits a datagram OpenLCB message as CAN frame(s)">CanTxMessageHandler_datagram_frame</a> - For datagram transfers</dd></dl>
<p>Converts and transmits a stream OpenLCB message as CAN frame(s)</p>
<p>Algorithm:</p><ol type="1">
<li>Return true immediately (placeholder implementation)</li>
</ol>
<p>Use cases:</p><ul>
<li>Firmware upgrade data transfer (when implemented)</li>
<li>Large file transfers (when implemented)</li>
<li>Continuous data streaming (when implemented)</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to OpenLCB stream message to transmit
* @param can_msg_worker Pointer to working CAN frame buffer for building frames
* @param openlcb_start_index Pointer to current position in stream payload (updated after transmission)
* </pre><dl class="section return"><dt>Returns</dt><dd>Currently always returns true (placeholder implementation)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Stream protocol NOT fully implemented - placeholder only </dd>
<dd>
Do not rely on this function for production stream transfers</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Function requires full implementation before use</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa9223150ff58342659336a51f75caf5a" title="Converts and transmits a datagram OpenLCB message as CAN frame(s)">CanTxMessageHandler_datagram_frame</a> - For datagram transfers </dd></dl>

</div>
</div>
<a id="aa99ced3d0e3dc246de366c88031b6596" name="aa99ced3d0e3dc246de366c88031b6596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99ced3d0e3dc246de366c88031b6596">&#9670;&#160;</a></span>CanTxMessageHandler_can_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CanTxMessageHandler_can_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>can_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmits a pre-built CAN frame to the physical bus. </p>
<p>Transmits a fully constructed CAN frame without any OpenLCB message processing or fragmentation. Used for CAN control frames and other low-level CAN operations that don't involve OpenLCB message conversion.</p>
<p>The frame must be completely built before calling:</p><ul>
<li>CAN identifier fully populated with correct bits</li>
<li>Payload bytes filled</li>
<li>Payload count set correctly</li>
</ul>
<p>Use cases:</p><ul>
<li>Transmitting CID frames during alias allocation (CID7, CID6, CID5, CID4)</li>
<li>Transmitting RID (Reserve ID) frame</li>
<li>Transmitting AMD (Alias Map Definition) frame</li>
<li>Sending AME (Alias Map Enquiry) responses</li>
<li>Direct CAN bus operations</li>
<li>Low-level protocol testing</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_msg</td><td>Pointer to CAN message buffer containing frame to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>can_msg must NOT be NULL </dd>
<dd>
Frame must be fully constructed before calling </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>No OpenLCB processing performed - raw CAN transmission </dd>
<dd>
No framing bit handling - transmits frame as-is </dd>
<dd>
Caller responsible for correct frame construction</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used primarily for CAN control frames during login</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__login__message__handler_8c.html#ad417a47b53614faa89382dd1f724c311" title="Handles the fourth state in the CAN login sequence.">CanLoginMessageHandler_state_load_cid07</a> - Builds CID frames </dd>
<dd>
<a class="el" href="can__login__message__handler_8c.html#a41f40ed325a32cf2f61fb66522c21977" title="Handles the ninth state in the CAN login sequence.">CanLoginMessageHandler_state_load_rid</a> - Builds RID frame </dd>
<dd>
<a class="el" href="can__login__message__handler_8c.html#a86ceb4c89ce3880a1a34fcd8805b4064" title="Handles the tenth and final state in the CAN login sequence.">CanLoginMessageHandler_state_load_amd</a> - Builds AMD frame</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Call internal transmit function which:<ul>
<li>Calls hardware transmit function</li>
<li>Invokes callback if transmission successful</li>
</ul>
</li>
<li>Return transmission result</li>
</ol>
<p>Use cases:</p><ul>
<li>Transmitting alias allocation frames during node login</li>
<li>Sending CAN control messages</li>
<li>Direct CAN bus operations</li>
</ul>
<pre class="fragment">* @param can_msg Pointer to CAN message buffer containing frame to transmit
* </pre><dl class="section return"><dt>Returns</dt><dd>True if frame transmitted successfully, false if transmission failed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Frame must be fully constructed before calling </dd>
<dd>
NOT thread-safe - serialize calls from multiple contexts</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>No OpenLCB processing performed - raw CAN transmission</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="can__tx__message__handler_8c.html#a79d6a3b6fd0db4921dc8630934e68bba" title="Converts and transmits addressed message as CAN frame(s)">CanTxMessageHandler_addressed_msg_frame</a> - For OpenLCB messages </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
