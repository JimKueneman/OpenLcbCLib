<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/openlcb_utilities.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">openlcb_utilities.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Common utility functions for OpenLCB message and buffer manipulation.  
<a href="#details">More...</a></p>

<p><a href="openlcb__utilities_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b320eb92f3b9990fb78b35e4a93b8c0" id="r_a6b320eb92f3b9990fb78b35e4a93b8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b320eb92f3b9990fb78b35e4a93b8c0">OpenLcbUtilities_load_openlcb_message</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint16_t source_alias, uint64_t source_id, uint16_t dest_alias, uint64_t dest_id, uint16_t mti)</td></tr>
<tr class="memdesc:a6b320eb92f3b9990fb78b35e4a93b8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an OpenLCB message structure with source, destination, and MTI.  <br /></td></tr>
<tr class="separator:a6b320eb92f3b9990fb78b35e4a93b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e94dfb13e33b2d191f446a38364b7e5" id="r_a5e94dfb13e33b2d191f446a38364b7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e94dfb13e33b2d191f446a38364b7e5">OpenLcbUtilities_copy_event_id_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, <a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="memdesc:a5e94dfb13e33b2d191f446a38364b7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an 8-byte event ID into the message payload.  <br /></td></tr>
<tr class="separator:a5e94dfb13e33b2d191f446a38364b7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdc740485642f016371b4604b93aa7f" id="r_aebdc740485642f016371b4604b93aa7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebdc740485642f016371b4604b93aa7f">OpenLcbUtilities_copy_node_id_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, <a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a> node_id, uint16_t offset)</td></tr>
<tr class="memdesc:aebdc740485642f016371b4604b93aa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 6-byte node ID into the message payload at a specified offset.  <br /></td></tr>
<tr class="separator:aebdc740485642f016371b4604b93aa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cef78b21287a901f256be421c689e0d" id="r_a8cef78b21287a901f256be421c689e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cef78b21287a901f256be421c689e0d">OpenLcbUtilities_copy_byte_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint8_t byte, uint16_t offset)</td></tr>
<tr class="memdesc:a8cef78b21287a901f256be421c689e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a single byte into the message payload at a specified offset.  <br /></td></tr>
<tr class="separator:a8cef78b21287a901f256be421c689e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153e53986f01cd7fb995277efcd5f022" id="r_a153e53986f01cd7fb995277efcd5f022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a153e53986f01cd7fb995277efcd5f022">OpenLcbUtilities_copy_word_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint16_t word, uint16_t offset)</td></tr>
<tr class="memdesc:a153e53986f01cd7fb995277efcd5f022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 16-bit word into the message payload at a specified offset.  <br /></td></tr>
<tr class="separator:a153e53986f01cd7fb995277efcd5f022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad234f0e994829310371761dde2a0fa1e" id="r_ad234f0e994829310371761dde2a0fa1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad234f0e994829310371761dde2a0fa1e">OpenLcbUtilities_copy_dword_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint32_t doubleword, uint16_t offset)</td></tr>
<tr class="memdesc:ad234f0e994829310371761dde2a0fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 32-bit doubleword into the message payload at a specified offset.  <br /></td></tr>
<tr class="separator:ad234f0e994829310371761dde2a0fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b8e79173b3eb1f1e36f620b2e7e4c4" id="r_a30b8e79173b3eb1f1e36f620b2e7e4c4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30b8e79173b3eb1f1e36f620b2e7e4c4">OpenLcbUtilities_copy_string_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, const char string[], uint16_t offset)</td></tr>
<tr class="memdesc:a30b8e79173b3eb1f1e36f620b2e7e4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a null-terminated string into the message payload.  <br /></td></tr>
<tr class="separator:a30b8e79173b3eb1f1e36f620b2e7e4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d5ca6fda22ae42d9b6efa8ca6dd81c" id="r_a39d5ca6fda22ae42d9b6efa8ca6dd81c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39d5ca6fda22ae42d9b6efa8ca6dd81c">OpenLcbUtilities_copy_byte_array_to_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, const uint8_t byte_array[], uint16_t offset, uint16_t requested_bytes)</td></tr>
<tr class="memdesc:a39d5ca6fda22ae42d9b6efa8ca6dd81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a byte array into the message payload.  <br /></td></tr>
<tr class="separator:a39d5ca6fda22ae42d9b6efa8ca6dd81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a0aa6ddbb623d5cab4308765c47477" id="r_a20a0aa6ddbb623d5cab4308765c47477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20a0aa6ddbb623d5cab4308765c47477">OpenLcbUtilities_clear_openlcb_message_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg)</td></tr>
<tr class="memdesc:a20a0aa6ddbb623d5cab4308765c47477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears only the payload portion of a message structure.  <br /></td></tr>
<tr class="separator:a20a0aa6ddbb623d5cab4308765c47477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9c2b155851377c1ce5eadca6a64a17" id="r_aae9c2b155851377c1ce5eadca6a64a17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae9c2b155851377c1ce5eadca6a64a17">OpenLcbUtilities_clear_openlcb_message</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg)</td></tr>
<tr class="memdesc:aae9c2b155851377c1ce5eadca6a64a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely clears and resets a message structure.  <br /></td></tr>
<tr class="separator:aae9c2b155851377c1ce5eadca6a64a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040663f01e6536b8f9fb5a77181e6015" id="r_a040663f01e6536b8f9fb5a77181e6015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a040663f01e6536b8f9fb5a77181e6015">OpenLcbUtilities_extract_node_id_from_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint16_t offset)</td></tr>
<tr class="memdesc:a040663f01e6536b8f9fb5a77181e6015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a 6-byte node ID from the message payload.  <br /></td></tr>
<tr class="separator:a040663f01e6536b8f9fb5a77181e6015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06eeb0060f209fa2a094e252473eb3e" id="r_ac06eeb0060f209fa2a094e252473eb3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06eeb0060f209fa2a094e252473eb3e">OpenLcbUtilities_extract_event_id_from_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg)</td></tr>
<tr class="memdesc:ac06eeb0060f209fa2a094e252473eb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an 8-byte event ID from the message payload.  <br /></td></tr>
<tr class="separator:ac06eeb0060f209fa2a094e252473eb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a665fc960f303e05a649d58ccd848e4" id="r_a6a665fc960f303e05a649d58ccd848e4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a665fc960f303e05a649d58ccd848e4">OpenLcbUtilities_extract_byte_from_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint16_t offset)</td></tr>
<tr class="memdesc:a6a665fc960f303e05a649d58ccd848e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a single byte from the message payload.  <br /></td></tr>
<tr class="separator:a6a665fc960f303e05a649d58ccd848e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a0c01d0fc5ca782be6b10773aceb4" id="r_a1f9a0c01d0fc5ca782be6b10773aceb4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f9a0c01d0fc5ca782be6b10773aceb4">OpenLcbUtilities_extract_word_from_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint16_t offset)</td></tr>
<tr class="memdesc:a1f9a0c01d0fc5ca782be6b10773aceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a 16-bit word from the message payload.  <br /></td></tr>
<tr class="separator:a1f9a0c01d0fc5ca782be6b10773aceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb46cc32b7e4fef78d264d5bc56ed08c" id="r_abb46cc32b7e4fef78d264d5bc56ed08c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb46cc32b7e4fef78d264d5bc56ed08c">OpenLcbUtilities_extract_dword_from_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg, uint16_t offset)</td></tr>
<tr class="memdesc:abb46cc32b7e4fef78d264d5bc56ed08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a 32-bit doubleword from the message payload.  <br /></td></tr>
<tr class="separator:abb46cc32b7e4fef78d264d5bc56ed08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763ed68f05ad99a4902de3826c2e005f" id="r_a763ed68f05ad99a4902de3826c2e005f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a763ed68f05ad99a4902de3826c2e005f">OpenLcbUtilities_count_nulls_in_openlcb_payload</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg)</td></tr>
<tr class="memdesc:a763ed68f05ad99a4902de3826c2e005f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of null bytes (0x00) in the message payload.  <br /></td></tr>
<tr class="separator:a763ed68f05ad99a4902de3826c2e005f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa13f6427e7abf03d5253dc0b95312da" id="r_aaa13f6427e7abf03d5253dc0b95312da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa13f6427e7abf03d5253dc0b95312da">OpenLcbUtilities_is_addressed_openlcb_message</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg)</td></tr>
<tr class="memdesc:aaa13f6427e7abf03d5253dc0b95312da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a message is addressed (not global)  <br /></td></tr>
<tr class="separator:aaa13f6427e7abf03d5253dc0b95312da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce2d7da1a094193ee6b5bc327911910" id="r_a8ce2d7da1a094193ee6b5bc327911910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce2d7da1a094193ee6b5bc327911910">OpenLcbUtilities_set_multi_frame_flag</a> (uint8_t *target, uint8_t flag)</td></tr>
<tr class="memdesc:a8ce2d7da1a094193ee6b5bc327911910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the multi-frame flag in a target byte.  <br /></td></tr>
<tr class="separator:a8ce2d7da1a094193ee6b5bc327911910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9204bcb0afbada951297d5be1d719b33" id="r_a9204bcb0afbada951297d5be1d719b33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9204bcb0afbada951297d5be1d719b33">OpenLcbUtilities_is_addressed_message_for_node</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *openlcb_msg)</td></tr>
<tr class="memdesc:a9204bcb0afbada951297d5be1d719b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an addressed message is for a specific node.  <br /></td></tr>
<tr class="separator:a9204bcb0afbada951297d5be1d719b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed21415edc11d38433021fca34e0d60d" id="r_aed21415edc11d38433021fca34e0d60d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed21415edc11d38433021fca34e0d60d">OpenLcbUtilities_is_producer_event_assigned_to_node</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint16_t *event_index)</td></tr>
<tr class="memdesc:aed21415edc11d38433021fca34e0d60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a producer event is assigned to a node.  <br /></td></tr>
<tr class="separator:aed21415edc11d38433021fca34e0d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf19f4c15949979c691d4141278ee22" id="r_a6cf19f4c15949979c691d4141278ee22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf19f4c15949979c691d4141278ee22">OpenLcbUtilities_is_consumer_event_assigned_to_node</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint16_t *event_index)</td></tr>
<tr class="memdesc:a6cf19f4c15949979c691d4141278ee22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a consumer event is assigned to a node.  <br /></td></tr>
<tr class="separator:a6cf19f4c15949979c691d4141278ee22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539043042b27fa7a28f82ff4f20278cd" id="r_a539043042b27fa7a28f82ff4f20278cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a539043042b27fa7a28f82ff4f20278cd">OpenLcbUtilities_calculate_memory_offset_into_node_space</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node)</td></tr>
<tr class="memdesc:a539043042b27fa7a28f82ff4f20278cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the memory offset for a node's configuration space.  <br /></td></tr>
<tr class="separator:a539043042b27fa7a28f82ff4f20278cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d58211f6431a39ab1f505e650e87be" id="r_a57d58211f6431a39ab1f505e650e87be"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d58211f6431a39ab1f505e650e87be">OpenLcbUtilities_payload_type_to_len</a> (<a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> payload_type)</td></tr>
<tr class="memdesc:a57d58211f6431a39ab1f505e650e87be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts payload type enum to byte length.  <br /></td></tr>
<tr class="separator:a57d58211f6431a39ab1f505e650e87be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adb3fe5dc4d64da02e252d5bfea2922" id="r_a8adb3fe5dc4d64da02e252d5bfea2922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8adb3fe5dc4d64da02e252d5bfea2922">OpenLcbUtilities_extract_node_id_from_config_mem_buffer</a> (<a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *buffer, uint8_t index)</td></tr>
<tr class="memdesc:a8adb3fe5dc4d64da02e252d5bfea2922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a 6-byte node ID from a configuration memory buffer.  <br /></td></tr>
<tr class="separator:a8adb3fe5dc4d64da02e252d5bfea2922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad8d02f8415a5ae8563b5f01dd26ad" id="r_a43ad8d02f8415a5ae8563b5f01dd26ad"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43ad8d02f8415a5ae8563b5f01dd26ad">OpenLcbUtilities_extract_word_from_config_mem_buffer</a> (<a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *buffer, uint8_t index)</td></tr>
<tr class="memdesc:a43ad8d02f8415a5ae8563b5f01dd26ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a 16-bit word from a configuration memory buffer.  <br /></td></tr>
<tr class="separator:a43ad8d02f8415a5ae8563b5f01dd26ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af892a2ef64dfd26cb36667a62ae0f8dc" id="r_af892a2ef64dfd26cb36667a62ae0f8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af892a2ef64dfd26cb36667a62ae0f8dc">OpenLcbUtilities_copy_node_id_to_config_mem_buffer</a> (<a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *buffer, <a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a> node_id, uint8_t index)</td></tr>
<tr class="memdesc:af892a2ef64dfd26cb36667a62ae0f8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 6-byte node ID into a configuration memory buffer.  <br /></td></tr>
<tr class="separator:af892a2ef64dfd26cb36667a62ae0f8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0305cbd41a639ad54ff12bd599cce9" id="r_aad0305cbd41a639ad54ff12bd599cce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad0305cbd41a639ad54ff12bd599cce9">OpenLcbUtilities_copy_event_id_to_config_mem_buffer</a> (<a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *buffer, <a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint8_t index)</td></tr>
<tr class="memdesc:aad0305cbd41a639ad54ff12bd599cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an 8-byte event ID into a configuration memory buffer.  <br /></td></tr>
<tr class="separator:aad0305cbd41a639ad54ff12bd599cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f602cb5ef7385e117f152614bd613b" id="r_a28f602cb5ef7385e117f152614bd613b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f602cb5ef7385e117f152614bd613b">OpenLcbUtilities_copy_config_mem_buffer_to_event_id</a> (<a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *buffer, uint8_t index)</td></tr>
<tr class="memdesc:a28f602cb5ef7385e117f152614bd613b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an 8-byte event ID from a configuration memory buffer.  <br /></td></tr>
<tr class="separator:a28f602cb5ef7385e117f152614bd613b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06296be3f07fd80febe7dec58eaa5028" id="r_a06296be3f07fd80febe7dec58eaa5028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06296be3f07fd80febe7dec58eaa5028">OpenLcbUtilities_load_config_mem_reply_write_fail_message_header</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *config_mem_write_request_info, uint16_t error_code)</td></tr>
<tr class="memdesc:a06296be3f07fd80febe7dec58eaa5028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a configuration memory write failure reply message header.  <br /></td></tr>
<tr class="separator:a06296be3f07fd80febe7dec58eaa5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c25886675aad1efa582cf2fc318833" id="r_aa2c25886675aad1efa582cf2fc318833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c25886675aad1efa582cf2fc318833">OpenLcbUtilities_load_config_mem_reply_write_ok_message_header</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *config_mem_write_request_info)</td></tr>
<tr class="memdesc:aa2c25886675aad1efa582cf2fc318833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a configuration memory write success reply message header.  <br /></td></tr>
<tr class="separator:aa2c25886675aad1efa582cf2fc318833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0acbbfd410c33c725f1be639783dbf7" id="r_ad0acbbfd410c33c725f1be639783dbf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0acbbfd410c33c725f1be639783dbf7">OpenLcbUtilities_load_config_mem_reply_read_fail_message_header</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__read__request__info__t.html">config_mem_read_request_info_t</a> *config_mem_read_request_info, uint16_t error_code)</td></tr>
<tr class="memdesc:ad0acbbfd410c33c725f1be639783dbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a configuration memory read failure reply message header.  <br /></td></tr>
<tr class="separator:ad0acbbfd410c33c725f1be639783dbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add25f972525f3d14f22f4657a74e0c9c" id="r_add25f972525f3d14f22f4657a74e0c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add25f972525f3d14f22f4657a74e0c9c">OpenLcbUtilities_load_config_mem_reply_read_ok_message_header</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__read__request__info__t.html">config_mem_read_request_info_t</a> *config_mem_read_request_info)</td></tr>
<tr class="memdesc:add25f972525f3d14f22f4657a74e0c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a configuration memory read success reply message header.  <br /></td></tr>
<tr class="separator:add25f972525f3d14f22f4657a74e0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b6a34610057c9cc23e130ddc33617f" id="r_a47b6a34610057c9cc23e130ddc33617f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b6a34610057c9cc23e130ddc33617f">OpenLcbUtilities_generate_event_range_id</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> base_event_id, <a class="el" href="openlcb__types_8h.html#a29cac8697a125631149cacda733a9faa">event_range_count_enum</a> count)</td></tr>
<tr class="separator:a47b6a34610057c9cc23e130ddc33617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96b7768edfeaf28e8a9474455f93659" id="r_ac96b7768edfeaf28e8a9474455f93659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac96b7768edfeaf28e8a9474455f93659">OpenLcbUtilities_is_event_id_in_consumer_ranges</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="separator:ac96b7768edfeaf28e8a9474455f93659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3895e8e4933d384cf8c626fa00f51c" id="r_aad3895e8e4933d384cf8c626fa00f51c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad3895e8e4933d384cf8c626fa00f51c">OpenLcbUtilities_is_event_id_in_producer_ranges</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, <a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="separator:aad3895e8e4933d384cf8c626fa00f51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3dedeec93238f781376e67143c010c" id="r_a9d3dedeec93238f781376e67143c010c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d3dedeec93238f781376e67143c010c">OpenLcbUtilities_is_broadcast_time_event</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="memdesc:a9d3dedeec93238f781376e67143c010c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an Event ID is a broadcast time event.  <br /></td></tr>
<tr class="separator:a9d3dedeec93238f781376e67143c010c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f31c219624dab8c2aa02e39c2bca96e" id="r_a2f31c219624dab8c2aa02e39c2bca96e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f31c219624dab8c2aa02e39c2bca96e">OpenLcbUtilities_extract_clock_id_from_time_event</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="memdesc:a2f31c219624dab8c2aa02e39c2bca96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts clock ID from broadcast time Event ID.  <br /></td></tr>
<tr class="separator:a2f31c219624dab8c2aa02e39c2bca96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf584d752ad0787034618a14f69c4a11" id="r_aaf584d752ad0787034618a14f69c4a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#ab52e2c84bc398c0dea7b742e92e2314a">broadcast_time_event_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf584d752ad0787034618a14f69c4a11">OpenLcbUtilities_get_broadcast_time_event_type</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="memdesc:aaf584d752ad0787034618a14f69c4a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type of broadcast time event from Event ID.  <br /></td></tr>
<tr class="separator:aaf584d752ad0787034618a14f69c4a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed514896d5573d06d6b41b5753091a08" id="r_aed514896d5573d06d6b41b5753091a08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed514896d5573d06d6b41b5753091a08">OpenLcbUtilities_extract_time_from_event_id</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint8_t *hour, uint8_t *minute)</td></tr>
<tr class="memdesc:aed514896d5573d06d6b41b5753091a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts time (hour/minute) from broadcast time Event ID.  <br /></td></tr>
<tr class="separator:aed514896d5573d06d6b41b5753091a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3b8179b16d53d28e90c3a5e1340193" id="r_afa3b8179b16d53d28e90c3a5e1340193"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa3b8179b16d53d28e90c3a5e1340193">OpenLcbUtilities_extract_date_from_event_id</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint8_t *month, uint8_t *day)</td></tr>
<tr class="memdesc:afa3b8179b16d53d28e90c3a5e1340193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts date (month/day) from broadcast time Event ID.  <br /></td></tr>
<tr class="separator:afa3b8179b16d53d28e90c3a5e1340193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc10b4f6a222e95a620a12d193a27c69" id="r_abc10b4f6a222e95a620a12d193a27c69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc10b4f6a222e95a620a12d193a27c69">OpenLcbUtilities_extract_year_from_event_id</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint16_t *year)</td></tr>
<tr class="memdesc:abc10b4f6a222e95a620a12d193a27c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts year from broadcast time Event ID.  <br /></td></tr>
<tr class="separator:abc10b4f6a222e95a620a12d193a27c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a2546a9cd1f6caf4fefc7c9471847e" id="r_a25a2546a9cd1f6caf4fefc7c9471847e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25a2546a9cd1f6caf4fefc7c9471847e">OpenLcbUtilities_extract_rate_from_event_id</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, int16_t *rate)</td></tr>
<tr class="memdesc:a25a2546a9cd1f6caf4fefc7c9471847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts clock rate from broadcast time Event ID.  <br /></td></tr>
<tr class="separator:a25a2546a9cd1f6caf4fefc7c9471847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0749230cbe60928a3f601a0d919fdd46" id="r_a0749230cbe60928a3f601a0d919fdd46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0749230cbe60928a3f601a0d919fdd46">OpenLcbUtilities_create_time_event_id</a> (uint64_t clock_id, uint8_t hour, uint8_t minute, bool is_set)</td></tr>
<tr class="memdesc:a0749230cbe60928a3f601a0d919fdd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a broadcast time Event ID for time events.  <br /></td></tr>
<tr class="separator:a0749230cbe60928a3f601a0d919fdd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3316cbf73ccec04d15b6f4a2285a7729" id="r_a3316cbf73ccec04d15b6f4a2285a7729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3316cbf73ccec04d15b6f4a2285a7729">OpenLcbUtilities_create_date_event_id</a> (uint64_t clock_id, uint8_t month, uint8_t day, bool is_set)</td></tr>
<tr class="memdesc:a3316cbf73ccec04d15b6f4a2285a7729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a broadcast time Event ID for date events.  <br /></td></tr>
<tr class="separator:a3316cbf73ccec04d15b6f4a2285a7729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fc8ec6df0324d5a8a2b96872fb999c" id="r_a57fc8ec6df0324d5a8a2b96872fb999c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57fc8ec6df0324d5a8a2b96872fb999c">OpenLcbUtilities_create_year_event_id</a> (uint64_t clock_id, uint16_t year, bool is_set)</td></tr>
<tr class="memdesc:a57fc8ec6df0324d5a8a2b96872fb999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a broadcast time Event ID for year events.  <br /></td></tr>
<tr class="separator:a57fc8ec6df0324d5a8a2b96872fb999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075cb9bc1895bda34727a603915c342" id="r_a4075cb9bc1895bda34727a603915c342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4075cb9bc1895bda34727a603915c342">OpenLcbUtilities_create_rate_event_id</a> (uint64_t clock_id, int16_t rate, bool is_set)</td></tr>
<tr class="memdesc:a4075cb9bc1895bda34727a603915c342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a broadcast time Event ID for rate events.  <br /></td></tr>
<tr class="separator:a4075cb9bc1895bda34727a603915c342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfdd3213341ea2e3aa3c04f1a991205" id="r_a4cfdd3213341ea2e3aa3c04f1a991205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cfdd3213341ea2e3aa3c04f1a991205">OpenLcbUtilities_create_command_event_id</a> (uint64_t clock_id, <a class="el" href="openlcb__types_8h.html#ab52e2c84bc398c0dea7b742e92e2314a">broadcast_time_event_type_enum</a> command)</td></tr>
<tr class="memdesc:a4cfdd3213341ea2e3aa3c04f1a991205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a broadcast time Event ID for command events.  <br /></td></tr>
<tr class="separator:a4cfdd3213341ea2e3aa3c04f1a991205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Train Search Event Utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions for encoding/decoding Train Search event IDs </p>
</div></td></tr>
<tr class="memitem:a72ea82898e834d55b36e11e07a83c04a" id="r_a72ea82898e834d55b36e11e07a83c04a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72ea82898e834d55b36e11e07a83c04a">OpenLcbUtilities_is_train_search_event</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="memdesc:a72ea82898e834d55b36e11e07a83c04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether an event ID belongs to the Train Search space.  <br /></td></tr>
<tr class="separator:a72ea82898e834d55b36e11e07a83c04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16df99aa78e31a3d04339e23d1f9db8" id="r_ac16df99aa78e31a3d04339e23d1f9db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac16df99aa78e31a3d04339e23d1f9db8">OpenLcbUtilities_extract_train_search_digits</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id, uint8_t *digits)</td></tr>
<tr class="memdesc:ac16df99aa78e31a3d04339e23d1f9db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts 6 search-query nibbles from a train search event ID.  <br /></td></tr>
<tr class="separator:ac16df99aa78e31a3d04339e23d1f9db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5eda1bd2c9a26747d3d239661d99b8a" id="r_aa5eda1bd2c9a26747d3d239661d99b8a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5eda1bd2c9a26747d3d239661d99b8a">OpenLcbUtilities_extract_train_search_flags</a> (<a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> event_id)</td></tr>
<tr class="memdesc:aa5eda1bd2c9a26747d3d239661d99b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the flags byte (byte 7) from a train search event ID.  <br /></td></tr>
<tr class="separator:aa5eda1bd2c9a26747d3d239661d99b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe285d8d2b51616c319f1e98983e1f7b" id="r_afe285d8d2b51616c319f1e98983e1f7b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe285d8d2b51616c319f1e98983e1f7b">OpenLcbUtilities_train_search_digits_to_address</a> (const uint8_t *digits)</td></tr>
<tr class="memdesc:afe285d8d2b51616c319f1e98983e1f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 6-nibble digit array to a numeric DCC address.  <br /></td></tr>
<tr class="separator:afe285d8d2b51616c319f1e98983e1f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1601d2fefb6a3693e58b50956e42376a" id="r_a1601d2fefb6a3693e58b50956e42376a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1601d2fefb6a3693e58b50956e42376a">OpenLcbUtilities_create_train_search_event_id</a> (uint16_t address, uint8_t flags)</td></tr>
<tr class="memdesc:a1601d2fefb6a3693e58b50956e42376a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a train search event ID from address and flags.  <br /></td></tr>
<tr class="separator:a1601d2fefb6a3693e58b50956e42376a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common utility functions for OpenLCB message and buffer manipulation. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>This module provides utility functions for working with OpenLCB messages, payloads, configuration memory buffers, and node structures. These are helper functions used throughout the OpenLCB library for data conversion, message construction, and buffer operations.</p>
<p>The utilities are organized into several categories:</p><ul>
<li>Message structure initialization and clearing</li>
<li>Payload data insertion (events, node IDs, integers, strings, byte arrays)</li>
<li>Payload data extraction (events, node IDs, integers)</li>
<li>Configuration memory buffer operations</li>
<li>Message classification and validation</li>
<li>Configuration memory reply message construction</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6b320eb92f3b9990fb78b35e4a93b8c0" name="a6b320eb92f3b9990fb78b35e4a93b8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b320eb92f3b9990fb78b35e4a93b8c0">&#9670;&#160;</a></span>OpenLcbUtilities_load_openlcb_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_load_openlcb_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>source_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>source_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>dest_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>dest_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mti</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes an OpenLCB message structure with source, destination, and MTI. </p>
<p>Loads the message header fields and clears the payload to zeros. This is the primary function for preparing a new message for transmission.</p>
<p>Use cases:</p><ul>
<li>Preparing outgoing messages in protocol handlers</li>
<li>Initializing reply messages in response to received messages</li>
<li>Setting up event producer/consumer messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure to initialize </td></tr>
    <tr><td class="paramname">source_alias</td><td>12-bit CAN alias of the source node </td></tr>
    <tr><td class="paramname">source_id</td><td>48-bit unique Node ID of the source node </td></tr>
    <tr><td class="paramname">dest_alias</td><td>12-bit CAN alias of the destination node (0 for global messages) </td></tr>
    <tr><td class="paramname">dest_id</td><td>48-bit unique Node ID of the destination node (0 for global messages) </td></tr>
    <tr><td class="paramname">mti</td><td>Message Type Indicator defining the message type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
The payload buffer size is determined by openlcb_msg-&gt;payload_type.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always call this before manually setting payload bytes to ensure the payload starts in a known cleared state.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message</a> - Complete message reset </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a20a0aa6ddbb623d5cab4308765c47477" title="Clears only the payload portion of a message structure.">OpenLcbUtilities_clear_openlcb_message_payload</a> - Payload-only reset</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Store dest_alias and dest_id</li>
<li>Store source_alias and source_id</li>
<li>Store mti (Message Type Indicator)</li>
<li>Set payload_count to 0</li>
<li>Set timerticks to 0</li>
<li>Get payload length from payload_type</li>
<li>Zero all payload bytes</li>
</ol>
<p>This is the primary function for preparing a new message for transmission.</p>
<p>Use cases:</p><ul>
<li>Preparing outgoing messages in protocol handlers</li>
<li>Initializing reply messages in response to received messages</li>
<li>Setting up event producer/consumer messages</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure to initialize
* </pre> <pre class="fragment">* @param source_alias 12-bit CAN alias of the source node
* </pre> <pre class="fragment">* @param source_id 48-bit unique Node ID of the source node
* </pre> <pre class="fragment">* @param dest_alias 12-bit CAN alias of the destination node (0 for global messages)
* </pre> <pre class="fragment">* @param dest_id 48-bit unique Node ID of the destination node (0 for global messages)
* </pre> <pre class="fragment">* @param mti Message Type Indicator defining the message type
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
The buffer size is determined by openlcb_msg-&gt;payload_type.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always call this before manually setting payload bytes to ensure the payload starts in a known cleared state.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message</a> - Complete message reset </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a20a0aa6ddbb623d5cab4308765c47477" title="Clears only the payload portion of a message structure.">OpenLcbUtilities_clear_openlcb_message_payload</a> - Payload-only reset </dd></dl>

</div>
</div>
<a id="a5e94dfb13e33b2d191f446a38364b7e5" name="a5e94dfb13e33b2d191f446a38364b7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e94dfb13e33b2d191f446a38364b7e5">&#9670;&#160;</a></span>OpenLcbUtilities_copy_event_id_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_event_id_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies an 8-byte event ID into the message payload. </p>
<p>Writes the event ID in big-endian format to the payload starting at offset 0. Increments payload_count by 8. Event IDs are 64-bit values that identify producer and consumer events per the Event Transport protocol.</p>
<p>Use cases:</p><ul>
<li>Building Producer Identified messages</li>
<li>Building Consumer Identified messages</li>
<li>Building Producer/Consumer Event Report messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">event_id</td><td>64-bit event identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least 8 bytes available.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This function always writes to offset 0. For events at other positions, manually copy bytes or use a different function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#ac06eeb0060f209fa2a094e252473eb3e" title="Extracts an 8-byte event ID from the message payload.">OpenLcbUtilities_extract_event_id_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aad0305cbd41a639ad54ff12bd599cce9" title="Copies an 8-byte event ID into a configuration memory buffer.">OpenLcbUtilities_copy_event_id_to_config_mem_buffer</a> - Config memory version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Loop from byte index 7 down to 0 (big-endian order)</li>
<li>Extract least significant byte of event_id</li>
<li>Write byte to payload[i]</li>
<li>Increment payload_count</li>
<li>Right-shift event_id by 8 bits</li>
<li>Repeat for all 8 bytes</li>
</ol>
<p>Writes the event ID in big-endian format to the payload starting at offset 0. Event IDs are 64-bit values that identify producer and consumer events per the Event Transport protocol.</p>
<p>Use cases:</p><ul>
<li>Building Producer Identified messages</li>
<li>Building Consumer Identified messages</li>
<li>Building Producer/Consumer Event Report messages</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param event_id 64-bit event identifier
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least 8 bytes available.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This function always writes to offset 0. For events at other positions, manually copy bytes or use a different function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes (increments by 8).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#ac06eeb0060f209fa2a094e252473eb3e" title="Extracts an 8-byte event ID from the message payload.">OpenLcbUtilities_extract_event_id_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aad0305cbd41a639ad54ff12bd599cce9" title="Copies an 8-byte event ID into a configuration memory buffer.">OpenLcbUtilities_copy_event_id_to_config_mem_buffer</a> - Config memory version </dd></dl>

</div>
</div>
<a id="aebdc740485642f016371b4604b93aa7f" name="aebdc740485642f016371b4604b93aa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdc740485642f016371b4604b93aa7f">&#9670;&#160;</a></span>OpenLcbUtilities_copy_node_id_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_node_id_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a></td>          <td class="paramname"><span class="paramname"><em>node_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a 6-byte node ID into the message payload at a specified offset. </p>
<p>Writes the node ID in big-endian format to the payload. Increments payload_count by 6. Node IDs are 48-bit unique identifiers per the OpenLCB specification.</p>
<p>Use cases:</p><ul>
<li>Building Verified Node ID messages</li>
<li>Building Simple Node Ident Info replies</li>
<li>Building protocol support inquiry responses</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">node_id</td><td>48-bit unique node identifier </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where node ID should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 6) bytes available. </dd>
<dd>
Does not validate offset bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a040663f01e6536b8f9fb5a77181e6015" title="Extracts a 6-byte node ID from the message payload.">OpenLcbUtilities_extract_node_id_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#af892a2ef64dfd26cb36667a62ae0f8dc" title="Copies a 6-byte node ID into a configuration memory buffer.">OpenLcbUtilities_copy_node_id_to_config_mem_buffer</a> - Config memory version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Loop from byte index 5 down to 0 (big-endian order)</li>
<li>Extract least significant byte of node_id</li>
<li>Write byte to payload[i + offset]</li>
<li>Increment payload_count</li>
<li>Right-shift node_id by 8 bits</li>
<li>Repeat for all 6 bytes</li>
</ol>
<p>Writes the node ID in big-endian format to the payload. Node IDs are 48-bit unique identifiers per the OpenLCB specification.</p>
<p>Use cases:</p><ul>
<li>Building Verified Node ID messages</li>
<li>Building Simple Node Ident Info replies</li>
<li>Building protocol support inquiry responses</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param node_id 48-bit unique node identifier
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where node ID should be written
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 6) bytes available. </dd>
<dd>
Does not validate offset bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes (increments by 6).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a040663f01e6536b8f9fb5a77181e6015" title="Extracts a 6-byte node ID from the message payload.">OpenLcbUtilities_extract_node_id_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#af892a2ef64dfd26cb36667a62ae0f8dc" title="Copies a 6-byte node ID into a configuration memory buffer.">OpenLcbUtilities_copy_node_id_to_config_mem_buffer</a> - Config memory version </dd></dl>

</div>
</div>
<a id="a8cef78b21287a901f256be421c689e0d" name="a8cef78b21287a901f256be421c689e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cef78b21287a901f256be421c689e0d">&#9670;&#160;</a></span>OpenLcbUtilities_copy_byte_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_byte_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>byte</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a single byte into the message payload at a specified offset. </p>
<p>Writes one byte to the payload and increments payload_count by 1.</p>
<p>Use cases:</p><ul>
<li>Writing command codes in datagrams</li>
<li>Writing status flags in protocol messages</li>
<li>Writing individual configuration bytes</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">byte</td><td>The byte value to write </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where the byte should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Does not validate offset bounds against payload size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added byte.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a6a665fc960f303e05a649d58ccd848e4" title="Extracts a single byte from the message payload.">OpenLcbUtilities_extract_byte_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a153e53986f01cd7fb995277efcd5f022" title="Copies a 16-bit word into the message payload at a specified offset.">OpenLcbUtilities_copy_word_to_openlcb_payload</a> - For 16-bit values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Write byte to payload[offset]</li>
<li>Increment payload_count by 1</li>
</ol>
<p>Use cases:</p><ul>
<li>Writing command codes in datagrams</li>
<li>Writing status flags in protocol messages</li>
<li>Writing individual configuration bytes</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param byte The byte value to write
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where the byte should be written
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Does not validate offset bounds against payload size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added byte.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a6a665fc960f303e05a649d58ccd848e4" title="Extracts a single byte from the message payload.">OpenLcbUtilities_extract_byte_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a153e53986f01cd7fb995277efcd5f022" title="Copies a 16-bit word into the message payload at a specified offset.">OpenLcbUtilities_copy_word_to_openlcb_payload</a> - For 16-bit values </dd></dl>

</div>
</div>
<a id="a153e53986f01cd7fb995277efcd5f022" name="a153e53986f01cd7fb995277efcd5f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153e53986f01cd7fb995277efcd5f022">&#9670;&#160;</a></span>OpenLcbUtilities_copy_word_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_word_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a 16-bit word into the message payload at a specified offset. </p>
<p>Writes the word in big-endian format (MSB first) and increments payload_count by 2.</p>
<p>Use cases:</p><ul>
<li>Writing memory addresses in configuration memory protocol</li>
<li>Writing error codes in datagram replies</li>
<li>Writing 16-bit configuration values</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">word</td><td>The 16-bit value to write </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where the word should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 2) bytes available. </dd>
<dd>
Does not validate offset bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#ad234f0e994829310371761dde2a0fa1e" title="Copies a 32-bit doubleword into the message payload at a specified offset.">OpenLcbUtilities_copy_dword_to_openlcb_payload</a> - For 32-bit values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Extract high byte (bits 15-8) by right-shifting 8 bits</li>
<li>Write high byte to payload[offset]</li>
<li>Extract low byte (bits 7-0) by masking with 0xFF</li>
<li>Write low byte to payload[offset + 1]</li>
<li>Increment payload_count by 2</li>
</ol>
<p>Writes the word in big-endian format (MSB first).</p>
<p>Use cases:</p><ul>
<li>Writing memory addresses in configuration memory protocol</li>
<li>Writing error codes in datagram replies</li>
<li>Writing 16-bit configuration values</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param word The 16-bit value to write
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where the word should be written
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 2) bytes available. </dd>
<dd>
Does not validate offset bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#ad234f0e994829310371761dde2a0fa1e" title="Copies a 32-bit doubleword into the message payload at a specified offset.">OpenLcbUtilities_copy_dword_to_openlcb_payload</a> - For 32-bit values </dd></dl>

</div>
</div>
<a id="ad234f0e994829310371761dde2a0fa1e" name="ad234f0e994829310371761dde2a0fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad234f0e994829310371761dde2a0fa1e">&#9670;&#160;</a></span>OpenLcbUtilities_copy_dword_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_dword_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>doubleword</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a 32-bit doubleword into the message payload at a specified offset. </p>
<p>Writes the doubleword in big-endian format (MSB first) and increments payload_count by 4.</p>
<p>Use cases:</p><ul>
<li>Writing 32-bit memory addresses in configuration memory protocol</li>
<li>Writing large numeric values in protocol messages</li>
<li>Writing timestamps or counters</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">doubleword</td><td>The 32-bit value to write </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where the doubleword should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 4) bytes available. </dd>
<dd>
Does not validate offset bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#abb46cc32b7e4fef78d264d5bc56ed08c" title="Extracts a 32-bit doubleword from the message payload.">OpenLcbUtilities_extract_dword_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a153e53986f01cd7fb995277efcd5f022" title="Copies a 16-bit word into the message payload at a specified offset.">OpenLcbUtilities_copy_word_to_openlcb_payload</a> - For 16-bit values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Extract byte 3 (bits 31-24) by right-shifting 24 bits</li>
<li>Write byte 3 to payload[offset]</li>
<li>Extract byte 2 (bits 23-16) by right-shifting 16 bits</li>
<li>Write byte 2 to payload[offset + 1]</li>
<li>Extract byte 1 (bits 15-8) by right-shifting 8 bits</li>
<li>Write byte 1 to payload[offset + 2]</li>
<li>Extract byte 0 (bits 7-0) by masking with 0xFF</li>
<li>Write byte 0 to payload[offset + 3]</li>
<li>Increment payload_count by 4</li>
</ol>
<p>Writes the doubleword in big-endian format (MSB first).</p>
<p>Use cases:</p><ul>
<li>Writing 32-bit memory addresses in configuration memory protocol</li>
<li>Writing large numeric values in protocol messages</li>
<li>Writing timestamps or counters</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param doubleword The 32-bit value to write
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where the doubleword should be written
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 4) bytes available. </dd>
<dd>
Does not validate offset bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect the added bytes. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#abb46cc32b7e4fef78d264d5bc56ed08c" title="Extracts a 32-bit doubleword from the message payload.">OpenLcbUtilities_extract_dword_from_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a153e53986f01cd7fb995277efcd5f022" title="Copies a 16-bit word into the message payload at a specified offset.">OpenLcbUtilities_copy_word_to_openlcb_payload</a> - For 16-bit values </dd></dl>

</div>
</div>
<a id="a30b8e79173b3eb1f1e36f620b2e7e4c4" name="a30b8e79173b3eb1f1e36f620b2e7e4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b8e79173b3eb1f1e36f620b2e7e4c4">&#9670;&#160;</a></span>OpenLcbUtilities_copy_string_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbUtilities_copy_string_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>string</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a null-terminated string into the message payload. </p>
<p>Copies characters from the string until null terminator is found or payload space is exhausted. Always appends a null terminator. Returns the total number of bytes written including the null terminator.</p>
<p>Use cases:</p><ul>
<li>Building Simple Node Ident Info (SNIP) replies with manufacturer/model strings</li>
<li>Writing user-defined strings in configuration data</li>
<li>Building text-based protocol messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">string</td><td>Null-terminated C string to copy </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where string should start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written including the null terminator</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
string must be null-terminated or buffer overflow may occur. </dd>
<dd>
Truncates string if payload space is insufficient, but always adds null terminator (may overwrite last character).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always reserves one byte for null terminator. Maximum string length is (payload_size - offset - 1).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to include all bytes written plus null terminator. </dd>
<dd>
Return value can be used to calculate offset for next data in payload.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a39d5ca6fda22ae42d9b6efa8ca6dd81c" title="Copies a byte array into the message payload.">OpenLcbUtilities_copy_byte_array_to_openlcb_payload</a> - For binary data</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize counter to 0</li>
<li>Get payload length from payload_type</li>
<li>While source string[counter] is not null:<ol type="a">
<li>If (counter + offset) &lt; (payload_len - 1):<ol type="i">
<li>Copy string[counter] to payload[counter + offset]</li>
<li>Increment payload_count</li>
<li>Increment counter</li>
</ol>
</li>
<li>Else break (no more space)</li>
</ol>
</li>
<li>Write null terminator to payload[counter + offset]</li>
<li>Increment payload_count and counter for null</li>
<li>Return total bytes written (counter)</li>
</ol>
<p>Copies characters from the string until null terminator is found or payload space is exhausted. Always appends a null terminator.</p>
<p>Use cases:</p><ul>
<li>Building Simple Node Ident Info (SNIP) replies with manufacturer/model strings</li>
<li>Writing user-defined strings in configuration data</li>
<li>Building text-based protocol messages</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param string Null-terminated C string to copy
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where string should start
* </pre> <dl class="section return"><dt>Returns</dt><dd>Number of bytes written including the null terminator</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
string must be null-terminated or buffer overflow may occur. </dd>
<dd>
Truncates string if payload space is insufficient, but always adds null terminator (may overwrite last character).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always reserves one byte for null terminator. Maximum string length is (payload_size - offset - 1).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to include all bytes written plus null terminator. </dd>
<dd>
Return value can be used to calculate offset for next data in payload.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a39d5ca6fda22ae42d9b6efa8ca6dd81c" title="Copies a byte array into the message payload.">OpenLcbUtilities_copy_byte_array_to_openlcb_payload</a> - For binary data </dd></dl>

</div>
</div>
<a id="a39d5ca6fda22ae42d9b6efa8ca6dd81c" name="a39d5ca6fda22ae42d9b6efa8ca6dd81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d5ca6fda22ae42d9b6efa8ca6dd81c">&#9670;&#160;</a></span>OpenLcbUtilities_copy_byte_array_to_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbUtilities_copy_byte_array_to_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>byte_array</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>requested_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a byte array into the message payload. </p>
<p>Copies the requested number of bytes from the array, or until payload space is exhausted. Returns the actual number of bytes copied.</p>
<p>Use cases:</p><ul>
<li>Copying configuration memory data into read reply datagrams</li>
<li>Building multi-byte protocol responses</li>
<li>Transferring binary data blocks</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">byte_array</td><td>Array of bytes to copy </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where array should start </td></tr>
    <tr><td class="paramname">requested_bytes</td><td>Number of bytes to attempt to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of bytes copied (may be less if payload full)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
byte_array must have at least requested_bytes available. </dd>
<dd>
May copy fewer bytes than requested if payload space exhausted.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Check return value to determine if all requested bytes were copied. </dd>
<dd>
Does not add null terminator (unlike copy_string).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect bytes actually copied. </dd>
<dd>
Return value indicates actual bytes written, useful for multi-frame messages.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a30b8e79173b3eb1f1e36f620b2e7e4c4" title="Copies a null-terminated string into the message payload.">OpenLcbUtilities_copy_string_to_openlcb_payload</a> - For null-terminated strings</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize counter to 0</li>
<li>Get payload length from payload_type</li>
<li>For i = 0 to requested_bytes - 1:<ol type="a">
<li>If (i + offset) &lt; payload_len:<ol type="i">
<li>Copy byte_array[i] to payload[i + offset]</li>
<li>Increment payload_count</li>
<li>Increment counter</li>
</ol>
</li>
<li>Else break (no more space)</li>
</ol>
</li>
<li>Return counter (actual bytes copied)</li>
</ol>
<p>Copies the requested number of bytes from the array, or until payload space is exhausted. Returns the actual number of bytes copied.</p>
<p>Use cases:</p><ul>
<li>Copying configuration memory data into read reply datagrams</li>
<li>Building multi-byte protocol responses</li>
<li>Transferring binary data blocks</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param byte_array Array of bytes to copy
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where array should start
* </pre> <pre class="fragment">* @param requested_bytes Number of bytes to attempt to copy
* </pre> <dl class="section return"><dt>Returns</dt><dd>Actual number of bytes copied (may be less if payload full)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
byte_array must have at least requested_bytes available. </dd>
<dd>
May copy fewer bytes than requested if payload space exhausted.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Check return value to determine if all requested bytes were copied. </dd>
<dd>
Does not add null terminator (unlike copy_string).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates payload_count to reflect bytes actually copied. </dd>
<dd>
Return value indicates actual bytes written, useful for multi-frame messages.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a30b8e79173b3eb1f1e36f620b2e7e4c4" title="Copies a null-terminated string into the message payload.">OpenLcbUtilities_copy_string_to_openlcb_payload</a> - For null-terminated strings </dd></dl>

</div>
</div>
<a id="a20a0aa6ddbb623d5cab4308765c47477" name="a20a0aa6ddbb623d5cab4308765c47477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a0aa6ddbb623d5cab4308765c47477">&#9670;&#160;</a></span>OpenLcbUtilities_clear_openlcb_message_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_clear_openlcb_message_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears only the payload portion of a message structure. </p>
<p>Sets all payload bytes to zero and resets payload_count to 0. Does not modify message header fields (source, dest, MTI).</p>
<p>Use cases:</p><ul>
<li>Reusing a message structure for a new reply</li>
<li>Clearing payload before building multi-part response</li>
<li>Resetting payload between retry attempts</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Preserves message header (aliases, IDs, MTI). Use OpenLcbUtilities_clear_openlcb_message to clear everything.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Payload size is determined by openlcb_msg-&gt;payload_type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message</a> - Clears entire message </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a6b320eb92f3b9990fb78b35e4a93b8c0" title="Initializes an OpenLCB message structure with source, destination, and MTI.">OpenLcbUtilities_load_openlcb_message</a> - Initializes message with values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Get payload length from payload_type</li>
<li>Loop through all payload bytes</li>
<li>Set each byte to 0</li>
<li>Set payload_count to 0</li>
</ol>
<p>Does not modify message header fields (source, dest, MTI).</p>
<p>Use cases:</p><ul>
<li>Reusing a message structure for a new reply</li>
<li>Clearing payload before building multi-part response</li>
<li>Resetting payload between retry attempts</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Preserves message header (aliases, IDs, MTI). Use OpenLcbUtilities_clear_openlcb_message to clear everything.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Payload size is determined by openlcb_msg-&gt;payload_type.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message</a> - Clears entire message </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a6b320eb92f3b9990fb78b35e4a93b8c0" title="Initializes an OpenLCB message structure with source, destination, and MTI.">OpenLcbUtilities_load_openlcb_message</a> - Initializes message with values </dd></dl>

</div>
</div>
<a id="aae9c2b155851377c1ce5eadca6a64a17" name="aae9c2b155851377c1ce5eadca6a64a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9c2b155851377c1ce5eadca6a64a17">&#9670;&#160;</a></span>OpenLcbUtilities_clear_openlcb_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_clear_openlcb_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completely clears and resets a message structure. </p>
<p>Zeros all header fields, clears payload, and resets all state flags. Sets allocated and inprocess flags to false, resets reference count and timerticks.</p>
<p>Use cases:</p><ul>
<li>Returning a message buffer to the pool</li>
<li>Preparing a buffer for initial allocation</li>
<li>Recovering from error conditions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This clears ALL fields including state flags and reference count. Only use when completely discarding message context.</dd>
<dd>
After calling this, the message should be considered unallocated and should not be used until properly initialized again.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a20a0aa6ddbb623d5cab4308765c47477" title="Clears only the payload portion of a message structure.">OpenLcbUtilities_clear_openlcb_message_payload</a> - Clears only payload </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a6b320eb92f3b9990fb78b35e4a93b8c0" title="Initializes an OpenLCB message structure with source, destination, and MTI.">OpenLcbUtilities_load_openlcb_message</a> - Initializes message with values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Set dest_alias to 0</li>
<li>Set dest_id to 0</li>
<li>Set source_alias to 0</li>
<li>Set source_id to 0</li>
<li>Set mti to 0</li>
<li>Set payload_count to 0</li>
<li>Set timerticks to 0</li>
<li>Set reference_count to 0</li>
<li>Set allocated flag to false</li>
<li>Set inprocess flag to false</li>
</ol>
<p>Zeros all header fields, clears payload, and resets all state flags.</p>
<p>Use cases:</p><ul>
<li>Returning a message buffer to the pool</li>
<li>Preparing a buffer for initial allocation</li>
<li>Recovering from error conditions</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This clears ALL fields including state flags and reference count. Only use when completely discarding message context.</dd>
<dd>
After calling this, the message should be considered unallocated and should not be used until properly initialized again.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does NOT zero the payload bytes themselves, only the header and state.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a20a0aa6ddbb623d5cab4308765c47477" title="Clears only the payload portion of a message structure.">OpenLcbUtilities_clear_openlcb_message_payload</a> - Clears only payload </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a6b320eb92f3b9990fb78b35e4a93b8c0" title="Initializes an OpenLCB message structure with source, destination, and MTI.">OpenLcbUtilities_load_openlcb_message</a> - Initializes message with values </dd></dl>

</div>
</div>
<a id="a040663f01e6536b8f9fb5a77181e6015" name="a040663f01e6536b8f9fb5a77181e6015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040663f01e6536b8f9fb5a77181e6015">&#9670;&#160;</a></span>OpenLcbUtilities_extract_node_id_from_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a> OpenLcbUtilities_extract_node_id_from_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a 6-byte node ID from the message payload. </p>
<p>Reads 6 bytes in big-endian format starting at the specified offset and assembles them into a 48-bit node_id_t value.</p>
<p>Use cases:</p><ul>
<li>Parsing Verified Node ID messages</li>
<li>Extracting node IDs from protocol inquiry responses</li>
<li>Reading node IDs from configuration memory</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where node ID starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 48-bit node ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 6) bytes available. </dd>
<dd>
Does not validate offset bounds. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aebdc740485642f016371b4604b93aa7f" title="Copies a 6-byte node ID into the message payload at a specified offset.">OpenLcbUtilities_copy_node_id_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a8adb3fe5dc4d64da02e252d5bfea2922" title="Extracts a 6-byte node ID from a configuration memory buffer.">OpenLcbUtilities_extract_node_id_from_config_mem_buffer</a> - Config memory version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize result to 0</li>
<li>Read payload[0 + offset], shift left 40 bits, OR into result</li>
<li>Read payload[1 + offset], shift left 32 bits, OR into result</li>
<li>Read payload[2 + offset], shift left 24 bits, OR into result</li>
<li>Read payload[3 + offset], shift left 16 bits, OR into result</li>
<li>Read payload[4 + offset], shift left 8 bits, OR into result</li>
<li>Read payload[5 + offset], OR into result</li>
<li>Return assembled 48-bit node ID</li>
</ol>
<p>Reads 6 bytes in big-endian format starting at the specified offset and assembles them into a 48-bit node_id_t value.</p>
<p>Use cases:</p><ul>
<li>Parsing Verified Node ID messages</li>
<li>Extracting node IDs from protocol inquiry responses</li>
<li>Reading node IDs from configuration memory</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where node ID starts
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 48-bit node ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 6) bytes available. </dd>
<dd>
Does not validate offset bounds. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aebdc740485642f016371b4604b93aa7f" title="Copies a 6-byte node ID into the message payload at a specified offset.">OpenLcbUtilities_copy_node_id_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a8adb3fe5dc4d64da02e252d5bfea2922" title="Extracts a 6-byte node ID from a configuration memory buffer.">OpenLcbUtilities_extract_node_id_from_config_mem_buffer</a> - Config memory version </dd></dl>

</div>
</div>
<a id="ac06eeb0060f209fa2a094e252473eb3e" name="ac06eeb0060f209fa2a094e252473eb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06eeb0060f209fa2a094e252473eb3e">&#9670;&#160;</a></span>OpenLcbUtilities_extract_event_id_from_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_extract_event_id_from_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an 8-byte event ID from the message payload. </p>
<p>Reads 8 bytes in big-endian format starting at offset 0 and assembles them into a 64-bit event_id_t value.</p>
<p>Use cases:</p><ul>
<li>Parsing Producer/Consumer Event Report messages</li>
<li>Extracting event IDs from Identify messages</li>
<li>Reading event IDs from protocol queries</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 64-bit event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least 8 bytes available. </dd>
<dd>
Reading from empty payload returns undefined values.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always reads from offset 0. For events at other positions, manually extract bytes or modify this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a5e94dfb13e33b2d191f446a38364b7e5" title="Copies an 8-byte event ID into the message payload.">OpenLcbUtilities_copy_event_id_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a28f602cb5ef7385e117f152614bd613b" title="Extracts an 8-byte event ID from a configuration memory buffer.">OpenLcbUtilities_copy_config_mem_buffer_to_event_id</a> - Config memory version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize result to 0</li>
<li>Read payload[0], shift left 56 bits, OR into result</li>
<li>Read payload[1], shift left 48 bits, OR into result</li>
<li>Read payload[2], shift left 40 bits, OR into result</li>
<li>Read payload[3], shift left 32 bits, OR into result</li>
<li>Read payload[4], shift left 24 bits, OR into result</li>
<li>Read payload[5], shift left 16 bits, OR into result</li>
<li>Read payload[6], shift left 8 bits, OR into result</li>
<li>Read payload[7], OR into result</li>
<li>Return assembled 64-bit event ID</li>
</ol>
<p>Reads 8 bytes in big-endian format starting at offset 0 and assembles them into a 64-bit event_id_t value.</p>
<p>Use cases:</p><ul>
<li>Parsing Producer/Consumer Event Report messages</li>
<li>Extracting event IDs from Identify messages</li>
<li>Reading event IDs from protocol queries</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 64-bit event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least 8 bytes available. </dd>
<dd>
Reading from empty payload returns undefined values.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always reads from offset 0. For events at other positions, manually extract bytes or modify this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a5e94dfb13e33b2d191f446a38364b7e5" title="Copies an 8-byte event ID into the message payload.">OpenLcbUtilities_copy_event_id_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a28f602cb5ef7385e117f152614bd613b" title="Extracts an 8-byte event ID from a configuration memory buffer.">OpenLcbUtilities_copy_config_mem_buffer_to_event_id</a> - Config memory version </dd></dl>

</div>
</div>
<a id="a6a665fc960f303e05a649d58ccd848e4" name="a6a665fc960f303e05a649d58ccd848e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a665fc960f303e05a649d58ccd848e4">&#9670;&#160;</a></span>OpenLcbUtilities_extract_byte_from_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t OpenLcbUtilities_extract_byte_from_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a single byte from the message payload. </p>
<p>Reads one byte from the specified offset in the payload.</p>
<p>Use cases:</p><ul>
<li>Reading command codes from datagrams</li>
<li>Extracting status flags from protocol messages</li>
<li>Reading individual configuration bytes</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte value at the specified offset</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Does not validate offset bounds against payload size. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a8cef78b21287a901f256be421c689e0d" title="Copies a single byte into the message payload at a specified offset.">OpenLcbUtilities_copy_byte_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - For 16-bit values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read and return payload[offset]</li>
</ol>
<p>Use cases:</p><ul>
<li>Reading command codes from datagrams</li>
<li>Extracting status flags from protocol messages</li>
<li>Reading individual configuration bytes</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param offset Byte offset in the payload to read from
* </pre> <dl class="section return"><dt>Returns</dt><dd>The byte value at the specified offset</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Does not validate offset bounds against payload size. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a8cef78b21287a901f256be421c689e0d" title="Copies a single byte into the message payload at a specified offset.">OpenLcbUtilities_copy_byte_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - For 16-bit values </dd></dl>

</div>
</div>
<a id="a1f9a0c01d0fc5ca782be6b10773aceb4" name="a1f9a0c01d0fc5ca782be6b10773aceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9a0c01d0fc5ca782be6b10773aceb4">&#9670;&#160;</a></span>OpenLcbUtilities_extract_word_from_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbUtilities_extract_word_from_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a 16-bit word from the message payload. </p>
<p>Reads 2 bytes in big-endian format (MSB first) starting at the specified offset and assembles them into a 16-bit value.</p>
<p>Use cases:</p><ul>
<li>Reading memory addresses from configuration memory protocol</li>
<li>Extracting error codes from datagram replies</li>
<li>Reading 16-bit configuration values</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where word starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 16-bit value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 2) bytes available. </dd>
<dd>
Does not validate offset bounds. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a153e53986f01cd7fb995277efcd5f022" title="Copies a 16-bit word into the message payload at a specified offset.">OpenLcbUtilities_copy_word_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#abb46cc32b7e4fef78d264d5bc56ed08c" title="Extracts a 32-bit doubleword from the message payload.">OpenLcbUtilities_extract_dword_from_openlcb_payload</a> - For 32-bit values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read payload[0 + offset], shift left 8 bits</li>
<li>Read payload[1 + offset]</li>
<li>OR the two bytes together</li>
<li>Return assembled 16-bit value</li>
</ol>
<p>Reads 2 bytes in big-endian format (MSB first) starting at the specified offset and assembles them into a 16-bit value.</p>
<p>Use cases:</p><ul>
<li>Reading memory addresses from configuration memory protocol</li>
<li>Extracting error codes from datagram replies</li>
<li>Reading 16-bit configuration values</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where word starts
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 16-bit value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 2) bytes available. </dd>
<dd>
Does not validate offset bounds. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a153e53986f01cd7fb995277efcd5f022" title="Copies a 16-bit word into the message payload at a specified offset.">OpenLcbUtilities_copy_word_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#abb46cc32b7e4fef78d264d5bc56ed08c" title="Extracts a 32-bit doubleword from the message payload.">OpenLcbUtilities_extract_dword_from_openlcb_payload</a> - For 32-bit values </dd></dl>

</div>
</div>
<a id="abb46cc32b7e4fef78d264d5bc56ed08c" name="abb46cc32b7e4fef78d264d5bc56ed08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb46cc32b7e4fef78d264d5bc56ed08c">&#9670;&#160;</a></span>OpenLcbUtilities_extract_dword_from_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OpenLcbUtilities_extract_dword_from_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a 32-bit doubleword from the message payload. </p>
<p>Reads 4 bytes in big-endian format (MSB first) starting at the specified offset and assembles them into a 32-bit value.</p>
<p>Use cases:</p><ul>
<li>Reading 32-bit memory addresses from configuration memory protocol</li>
<li>Extracting large numeric values from protocol messages</li>
<li>Reading timestamps or counters</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset in the payload where doubleword starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 32-bit value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 4) bytes available. </dd>
<dd>
Does not validate offset bounds. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#ad234f0e994829310371761dde2a0fa1e" title="Copies a 32-bit doubleword into the message payload at a specified offset.">OpenLcbUtilities_copy_dword_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - For 16-bit values</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read payload[0 + offset], shift left 24 bits</li>
<li>Read payload[1 + offset], shift left 16 bits</li>
<li>Read payload[2 + offset], shift left 8 bits</li>
<li>Read payload[3 + offset]</li>
<li>OR all four bytes together</li>
<li>Return assembled 32-bit value</li>
</ol>
<p>Reads 4 bytes in big-endian format (MSB first) starting at the specified offset and assembles them into a 32-bit value.</p>
<p>Use cases:</p><ul>
<li>Reading 32-bit memory addresses from configuration memory protocol</li>
<li>Extracting large numeric values from protocol messages</li>
<li>Reading timestamps or counters</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <pre class="fragment">* @param offset Byte offset in the payload where doubleword starts
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 32-bit value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes payload has at least (offset + 4) bytes available. </dd>
<dd>
Does not validate offset bounds. </dd>
<dd>
Reading beyond payload bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not modify payload_count. </dd>
<dd>
Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#ad234f0e994829310371761dde2a0fa1e" title="Copies a 32-bit doubleword into the message payload at a specified offset.">OpenLcbUtilities_copy_dword_to_openlcb_payload</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - For 16-bit values </dd></dl>

</div>
</div>
<a id="a763ed68f05ad99a4902de3826c2e005f" name="a763ed68f05ad99a4902de3826c2e005f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763ed68f05ad99a4902de3826c2e005f">&#9670;&#160;</a></span>OpenLcbUtilities_count_nulls_in_openlcb_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t OpenLcbUtilities_count_nulls_in_openlcb_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of null bytes (0x00) in the message payload. </p>
<p>Scans through payload_count bytes and counts occurrences of 0x00. Used primarily for validating SNIP (Simple Node Ident Info) message format, which requires exactly 4 null terminators for the 4 string fields.</p>
<p>Use cases:</p><ul>
<li>Validating received SNIP messages have correct format</li>
<li>Verifying string-based protocol messages</li>
<li>Detecting malformed messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of null bytes found in the payload</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only scans up to payload_count bytes, not the entire buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For SNIP messages, exactly 4 nulls are expected (manufacturer, model, hardware version, software version).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__snip_8c.html" title="Implementation of Simple Node Information Protocol (SNIP)">protocol_snip.c</a> - Uses this for <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467abe8ba0ab660a42ba2ab8aa7cdc1aa98c">SNIP</a> validation</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize count to 0</li>
<li>For i = 0 to payload_count - 1:<ol type="a">
<li>If payload[i] equals 0x00:<ol type="i">
<li>Increment count</li>
</ol>
</li>
</ol>
</li>
<li>Return count</li>
</ol>
<p>Scans through payload_count bytes and counts occurrences of 0x00. Used primarily for validating SNIP (Simple Node Ident Info) message format, which requires exactly 4 null terminators for the 4 string fields.</p>
<p>Use cases:</p><ul>
<li>Validating received SNIP messages have correct format</li>
<li>Verifying string-based protocol messages</li>
<li>Detecting malformed messages</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <dl class="section return"><dt>Returns</dt><dd>Count of null bytes found in the payload</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only scans up to payload_count bytes, not the entire buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For SNIP messages, exactly 4 nulls are expected (manufacturer, model, hardware version, software version).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__snip_8c.html" title="Implementation of Simple Node Information Protocol (SNIP)">protocol_snip.c</a> - Uses this for <a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467abe8ba0ab660a42ba2ab8aa7cdc1aa98c">SNIP</a> validation </dd></dl>

</div>
</div>
<a id="aaa13f6427e7abf03d5253dc0b95312da" name="aaa13f6427e7abf03d5253dc0b95312da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa13f6427e7abf03d5253dc0b95312da">&#9670;&#160;</a></span>OpenLcbUtilities_is_addressed_openlcb_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_addressed_openlcb_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a message is addressed (not global) </p>
<p>Checks the MTI (Message Type Indicator) for the destination address present bit. Addressed messages have a specific destination node, while global messages are broadcast to all nodes.</p>
<p>Use cases:</p><ul>
<li>Routing messages in the main state machine</li>
<li>Determining if a message requires alias resolution</li>
<li>Filtering messages for specific node handling</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if message is addressed to a specific node, false if global</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_msg must not be NULL. No NULL check performed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Global messages have dest_alias = 0 and MTI without address bit set. </dd>
<dd>
Addressed messages require valid dest_alias or dest_id.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a9204bcb0afbada951297d5be1d719b33" title="Checks if an addressed message is for a specific node.">OpenLcbUtilities_is_addressed_message_for_node</a> - Checks specific node match </dd>
<dd>
<a class="el" href="group__mti__field__masks.html#ga515226f6c2fb12b929379b4e5004ab1a" title="Destination address present indicator.">MASK_DEST_ADDRESS_PRESENT</a> - MTI bit mask used for check</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read mti field from message</li>
<li>AND with MASK_DEST_ADDRESS_PRESENT</li>
<li>Return true if result equals MASK_DEST_ADDRESS_PRESENT</li>
<li>Return false otherwise</li>
</ol>
<p>Checks the MTI (Message Type Indicator) for the destination address present bit. Addressed messages have a specific destination node, while global messages are broadcast to all nodes.</p>
<p>Use cases:</p><ul>
<li>Routing messages in the main state machine</li>
<li>Determining if a message requires alias resolution</li>
<li>Filtering messages for specific node handling</li>
</ul>
<pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <dl class="section return"><dt>Returns</dt><dd>true if message is addressed to a specific node, false if global</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Global messages have dest_alias = 0 and MTI without address bit set. </dd>
<dd>
Addressed messages require valid dest_alias or dest_ID.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a9204bcb0afbada951297d5be1d719b33" title="Checks if an addressed message is for a specific node.">OpenLcbUtilities_is_addressed_message_for_node</a> - Checks specific node match </dd>
<dd>
<a class="el" href="group__mti__field__masks.html#ga515226f6c2fb12b929379b4e5004ab1a" title="Destination address present indicator.">MASK_DEST_ADDRESS_PRESENT</a> - MTI bit mask used for check </dd></dl>

</div>
</div>
<a id="a8ce2d7da1a094193ee6b5bc327911910" name="a8ce2d7da1a094193ee6b5bc327911910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce2d7da1a094193ee6b5bc327911910">&#9670;&#160;</a></span>OpenLcbUtilities_set_multi_frame_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_set_multi_frame_flag </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the multi-frame flag in a target byte. </p>
<p>Modifies the upper nibble of the target byte to set the multi-frame control flag while preserving the lower nibble. Used in datagram and stream protocols for frame sequencing.</p>
<p>Use cases:</p><ul>
<li>Marking first frame in multi-frame datagram</li>
<li>Marking middle frames in sequence</li>
<li>Marking final frame in sequence</li>
<li>Marking single-frame (only) messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to the byte to modify </td></tr>
    <tr><td class="paramname">flag</td><td>Multi-frame flag value (MULTIFRAME_ONLY, MULTIFRAME_FIRST, MULTIFRAME_MIDDLE, or MULTIFRAME_FINAL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>target must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Upper nibble is completely replaced. Lower nibble is preserved. </dd>
<dd>
Valid flag values are defined in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is typically used on the first byte of configuration memory or datagram protocol command bytes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>protocol_config_mem_*.c - Uses for multi-frame config operations</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Clear upper nibble by ANDing with 0x0F (preserves lower nibble)</li>
<li>Set flag in upper nibble by ORing with flag value</li>
</ol>
<p>Modifies the upper nibble of the target byte to set the multi-frame control flag while preserving the lower nibble. Used in datagram and stream protocols for frame sequencing.</p>
<p>Use cases:</p><ul>
<li>Marking first frame in multi-frame datagram</li>
<li>Marking middle frames in sequence</li>
<li>Marking final frame in sequence</li>
<li>Marking single-frame (only) messages</li>
</ul>
<pre class="fragment">* @param target Pointer to the byte to modify
* </pre> <pre class="fragment">* @param flag Multi-frame flag value (MULTIFRAME_ONLY, MULTIFRAME_FIRST,
* </pre><p> MULTIFRAME_MIDDLE, or MULTIFRAME_FINAL)</p>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Upper nibble is completely replaced. Lower nibble is preserved. </dd>
<dd>
Valid flag values are defined in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is typically used on the first byte of configuration memory or datagram protocol command bytes.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>protocol_config_mem_*.c - Uses for multi-frame config operations </dd></dl>

</div>
</div>
<a id="a9204bcb0afbada951297d5be1d719b33" name="a9204bcb0afbada951297d5be1d719b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9204bcb0afbada951297d5be1d719b33">&#9670;&#160;</a></span>OpenLcbUtilities_is_addressed_message_for_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_addressed_message_for_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_msg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an addressed message is for a specific node. </p>
<p>Compares the message destination (alias or ID) against the node's alias and ID. Returns true if either matches, meaning this node is the intended recipient.</p>
<p>Use cases:</p><ul>
<li>Filtering incoming addressed messages in state machine</li>
<li>Determining if node should process a protocol message</li>
<li>Validating message routing in multi-node systems</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to the node structure to check </td></tr>
    <tr><td class="paramname">openlcb_msg</td><td>Pointer to the message structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if message is addressed to this node, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_node must not be NULL. No NULL check performed. </dd>
<dd>
openlcb_msg must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Matches on EITHER alias OR node ID. A match on either field is sufficient to return true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Global messages (dest_alias = 0, dest_id = 0) will return false unless the node somehow has alias or ID = 0 (invalid state).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aaa13f6427e7abf03d5253dc0b95312da" title="Determines if a message is addressed (not global)">OpenLcbUtilities_is_addressed_openlcb_message</a> - Checks if message is addressed at all</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Compare message dest_alias with node alias</li>
<li>If match, return true</li>
<li>Compare message dest_id with node ID</li>
<li>If match, return true</li>
<li>Return false if neither matches</li>
</ol>
<p>Compares the message destination (alias or ID) against the node's alias and ID. Returns true if either matches, meaning this node is the intended recipient.</p>
<p>Use cases:</p><ul>
<li>Filtering incoming addressed messages in state machine</li>
<li>Determining if node should process a protocol message</li>
<li>Validating message routing in multi-node systems</li>
</ul>
<pre class="fragment">* @param openlcb_node Pointer to the node structure to check
* </pre> <pre class="fragment">* @param openlcb_msg Pointer to the message structure
* </pre> <dl class="section return"><dt>Returns</dt><dd>true if message is addressed to this node, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Matches on EITHER alias OR node ID. A match on either field is sufficient to return true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Global messages (dest_alias = 0, dest_id = 0) will return false unless the node somehow has alias or ID = 0 (invalid state).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aaa13f6427e7abf03d5253dc0b95312da" title="Determines if a message is addressed (not global)">OpenLcbUtilities_is_addressed_openlcb_message</a> - Checks if message is addressed at all </dd></dl>

</div>
</div>
<a id="aed21415edc11d38433021fca34e0d60d" name="aed21415edc11d38433021fca34e0d60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed21415edc11d38433021fca34e0d60d">&#9670;&#160;</a></span>OpenLcbUtilities_is_producer_event_assigned_to_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_producer_event_assigned_to_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>event_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a producer event is assigned to a node. </p>
<p>Searches the node's producer event list for a matching event ID. If found, returns true and stores the list index in event_index.</p>
<p>Use cases:</p><ul>
<li>Processing Producer Identify requests</li>
<li>Validating event ownership before sending reports</li>
<li>Looking up producer state information</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to the node structure to search </td></tr>
    <tr><td class="paramname">event_id</td><td>The 64-bit event ID to search for </td></tr>
    <tr><td class="paramname">event_index</td><td>Pointer to store the list index if found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event found in producer list, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_node must not be NULL. No NULL check performed. </dd>
<dd>
event_index must not be NULL. No NULL check performed. </dd>
<dd>
event_index is only valid when function returns true.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>event_index is NOT modified if event is not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Linear search with O(n) complexity where n = producer count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a6cf19f4c15949979c691d4141278ee22" title="Checks if a consumer event is assigned to a node.">OpenLcbUtilities_is_consumer_event_assigned_to_node</a> - Consumer version </dd>
<dd>
<a class="el" href="protocol__event__transport_8c.html" title="Implementation of event transport protocol.">protocol_event_transport.c</a> - Uses this for event identification</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Loop through node's producer list (i = 0 to producers.count - 1)</li>
<li>Compare producers.list[i].event with event_id</li>
<li>If match found:<ol type="a">
<li>Store i in *event_index</li>
<li>Return true</li>
</ol>
</li>
<li>If loop completes without match, return false</li>
</ol>
<p>Searches the node's producer event list for a matching event ID. If found, returns true and stores the list index in event_index.</p>
<p>Use cases:</p><ul>
<li>Processing Producer Identify requests</li>
<li>Validating event ownership before sending reports</li>
<li>Looking up producer state information</li>
</ul>
<pre class="fragment">* @param openlcb_node Pointer to the node structure to search
* </pre> <pre class="fragment">* @param event_id The 64-bit event ID to search for
* </pre> <pre class="fragment">* @param event_index Pointer to store the list index if found
* </pre> <dl class="section return"><dt>Returns</dt><dd>true if event found in producer list, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed. </dd>
<dd>
event_index is only valid when function returns true.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>event_index is NOT modified if event is not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Linear search with O(n) complexity where n = producer count.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>O(n) worst case, where n = producer count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a6cf19f4c15949979c691d4141278ee22" title="Checks if a consumer event is assigned to a node.">OpenLcbUtilities_is_consumer_event_assigned_to_node</a> - Consumer version </dd>
<dd>
<a class="el" href="protocol__event__transport_8c.html" title="Implementation of event transport protocol.">protocol_event_transport.c</a> - Uses this for event identification </dd></dl>

</div>
</div>
<a id="a6cf19f4c15949979c691d4141278ee22" name="a6cf19f4c15949979c691d4141278ee22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf19f4c15949979c691d4141278ee22">&#9670;&#160;</a></span>OpenLcbUtilities_is_consumer_event_assigned_to_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_consumer_event_assigned_to_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>event_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a consumer event is assigned to a node. </p>
<p>Searches the node's consumer event list for a matching event ID. If found, returns true and stores the list index in event_index.</p>
<p>Use cases:</p><ul>
<li>Processing Consumer Identify requests</li>
<li>Validating event subscriptions</li>
<li>Looking up consumer state information</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to the node structure to search </td></tr>
    <tr><td class="paramname">event_id</td><td>The 64-bit event ID to search for </td></tr>
    <tr><td class="paramname">event_index</td><td>Pointer to store the list index if found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event found in consumer list, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_node must not be NULL. No NULL check performed. </dd>
<dd>
event_index must not be NULL. No NULL check performed. </dd>
<dd>
event_index is only valid when function returns true.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>event_index is NOT modified if event is not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Linear search with O(n) complexity where n = consumer count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aed21415edc11d38433021fca34e0d60d" title="Checks if a producer event is assigned to a node.">OpenLcbUtilities_is_producer_event_assigned_to_node</a> - Producer version </dd>
<dd>
<a class="el" href="protocol__event__transport_8c.html" title="Implementation of event transport protocol.">protocol_event_transport.c</a> - Uses this for event identification</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Loop through node's consumer list (i = 0 to consumers.count - 1)</li>
<li>Compare consumers.list[i].event with event_id</li>
<li>If match found:<ol type="a">
<li>Store i in *event_index</li>
<li>Return true</li>
</ol>
</li>
<li>If loop completes without match, return false</li>
</ol>
<p>Searches the node's consumer event list for a matching event ID. If found, returns true and stores the list index in event_index.</p>
<p>Use cases:</p><ul>
<li>Processing Consumer Identify requests</li>
<li>Validating event subscriptions</li>
<li>Looking up consumer state information</li>
</ul>
<pre class="fragment">* @param openlcb_node Pointer to the node structure to search
* </pre> <pre class="fragment">* @param event_id The 64-bit event ID to search for
* </pre> <pre class="fragment">* @param event_index Pointer to store the list index if found
* </pre> <dl class="section return"><dt>Returns</dt><dd>true if event found in consumer list, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed. </dd>
<dd>
event_index is only valid when function returns true.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>event_index is NOT modified if event is not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Linear search with O(n) complexity where n = consumer count.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>O(n) worst case, where n = consumer count.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aed21415edc11d38433021fca34e0d60d" title="Checks if a producer event is assigned to a node.">OpenLcbUtilities_is_producer_event_assigned_to_node</a> - Producer version </dd>
<dd>
<a class="el" href="protocol__event__transport_8c.html" title="Implementation of event transport protocol.">protocol_event_transport.c</a> - Uses this for event identification </dd></dl>

</div>
</div>
<a id="a539043042b27fa7a28f82ff4f20278cd" name="a539043042b27fa7a28f82ff4f20278cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539043042b27fa7a28f82ff4f20278cd">&#9670;&#160;</a></span>OpenLcbUtilities_calculate_memory_offset_into_node_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OpenLcbUtilities_calculate_memory_offset_into_node_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the memory offset for a node's configuration space. </p>
<p>Computes the byte offset into the global configuration memory array where this node's configuration space begins. Handles both absolute addressing (when low_address_valid is false) and relative addressing (when low_address_valid is true).</p>
<p>Use cases:</p><ul>
<li>Multi-node configuration memory implementations</li>
<li>Mapping node index to memory address</li>
<li>Validating configuration memory access requests</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to the node structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Byte offset into global configuration memory for this node</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_node must not be NULL. No NULL check performed. </dd>
<dd>
openlcb_node-&gt;parameters must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>If low_address_valid is true, uses (highest - lowest) as size. </dd>
<dd>
If low_address_valid is false, uses highest_address as size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result is node_size * node_index, allowing sequential allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>protocol_config_mem_*.c - Uses this for address space calculations</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read highest_address from node parameters</li>
<li>If low_address_valid is true, compute size as (highest - lowest)</li>
<li>If low_address_valid is false, use highest_address as size</li>
<li>Multiply size by node index to get offset</li>
<li>Return the calculated offset</li>
</ol>
<p>This allows multiple nodes to share a contiguous configuration memory space, with each node occupying a sequential block of memory determined by its index.</p>
<p>Use cases:</p><ul>
<li>Multi-node configuration memory implementations</li>
<li>Mapping node index to memory address</li>
<li>Validating configuration memory access requests</li>
</ul>
<pre class="fragment">* @param openlcb_node Pointer to the node structure
* </pre> <dl class="section return"><dt>Returns</dt><dd>Byte offset into global configuration memory for this node</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
openlcb_node-&gt;parameters must not be NULL. No NULL check performed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>If low_address_valid is true, uses (highest - lowest) as size. </dd>
<dd>
If low_address_valid is false, uses highest_address as size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Result is node_size * node_index, allowing sequential allocation.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>protocol_config_mem_*.c - Uses this for address space calculations </dd></dl>

</div>
</div>
<a id="a57d58211f6431a39ab1f505e650e87be" name="a57d58211f6431a39ab1f505e650e87be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d58211f6431a39ab1f505e650e87be">&#9670;&#160;</a></span>OpenLcbUtilities_payload_type_to_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbUtilities_payload_type_to_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>payload_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts payload type enum to byte length. </p>
<p>Returns the maximum payload size in bytes for a given payload type. Used throughout the library to determine buffer sizes and validate operations.</p>
<p>Use cases:</p><ul>
<li>Allocating message buffers</li>
<li>Validating payload operations</li>
<li>Determining maximum data capacity</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload_type</td><td>The payload type enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum payload size in bytes, or 0 for unknown types</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Return values per OpenLCB specification:<ul>
<li>BASIC: LEN_MESSAGE_BYTES_BASIC</li>
<li>DATAGRAM: LEN_MESSAGE_BYTES_DATAGRAM <br  />
</li>
<li>SNIP: LEN_MESSAGE_BYTES_SNIP</li>
<li>STREAM: LEN_MESSAGE_BYTES_STREAM</li>
<li>default: 0</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> - Defines the LEN_MESSAGE_BYTES_* constants </dd>
<dd>
<a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467" title="Message buffer payload type enumeration.">payload_type_enum</a> - Enum definition in <a class="el" href="openlcb__types_8h.html" title="Core type definitions, structures, and configuration constants for OpenLCB library.">openlcb_types.h</a></dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Switch on payload_type enum value</li>
<li>Return corresponding LEN_MESSAGE_BYTES_* constant</li>
<li>Return 0 for unknown types</li>
</ol>
<p>Use cases:</p><ul>
<li>Allocating message buffers</li>
<li>Validating payload operations</li>
<li>Determining maximum data capacity</li>
</ul>
<pre class="fragment">* @param payload_type The payload type enum value
* </pre> <dl class="section return"><dt>Returns</dt><dd>Maximum payload size in bytes, or 0 for unknown types</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Return values per OpenLCB specification:<ul>
<li>BASIC: LEN_MESSAGE_BYTES_BASIC</li>
<li>DATAGRAM: LEN_MESSAGE_BYTES_DATAGRAM <br  />
</li>
<li>SNIP: LEN_MESSAGE_BYTES_SNIP</li>
<li>STREAM: LEN_MESSAGE_BYTES_STREAM</li>
<li>default: 0</li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> - Defines the LEN_MESSAGE_BYTES_* constants </dd>
<dd>
<a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467" title="Message buffer payload type enumeration.">payload_type_enum</a> - Enum definition in <a class="el" href="openlcb__types_8h.html" title="Core type definitions, structures, and configuration constants for OpenLCB library.">openlcb_types.h</a> </dd></dl>

</div>
</div>
<a id="a8adb3fe5dc4d64da02e252d5bfea2922" name="a8adb3fe5dc4d64da02e252d5bfea2922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adb3fe5dc4d64da02e252d5bfea2922">&#9670;&#160;</a></span>OpenLcbUtilities_extract_node_id_from_config_mem_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a> OpenLcbUtilities_extract_node_id_from_config_mem_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a 6-byte node ID from a configuration memory buffer. </p>
<p>Reads 6 bytes in big-endian format from the buffer starting at the specified index and assembles them into a 48-bit node_id_t value.</p>
<p>Use cases:</p><ul>
<li>Reading node IDs from configuration memory</li>
<li>Parsing configuration data structures</li>
<li>Extracting stored node identifiers</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the configuration memory buffer </td></tr>
    <tr><td class="paramname">index</td><td>Byte offset in the buffer where node ID starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 48-bit node ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>buffer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 6) bytes available. </dd>
<dd>
Does not validate index bounds. </dd>
<dd>
Reading beyond buffer bounds returns undefined values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#af892a2ef64dfd26cb36667a62ae0f8dc" title="Copies a 6-byte node ID into a configuration memory buffer.">OpenLcbUtilities_copy_node_id_to_config_mem_buffer</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a040663f01e6536b8f9fb5a77181e6015" title="Extracts a 6-byte node ID from the message payload.">OpenLcbUtilities_extract_node_id_from_openlcb_payload</a> - Payload version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read buffer[0 + index], shift left 40 bits</li>
<li>Read buffer[1 + index], shift left 32 bits</li>
<li>Read buffer[2 + index], shift left 24 bits</li>
<li>Read buffer[3 + index], shift left 16 bits</li>
<li>Read buffer[4 + index], shift left 8 bits</li>
<li>Read buffer[5 + index]</li>
<li>OR all six bytes together</li>
<li>Return assembled 48-bit node ID</li>
</ol>
<p>Reads 6 bytes in big-endian format from the buffer starting at the specified index and assembles them into a 48-bit node_id_t value.</p>
<p>Use cases:</p><ul>
<li>Reading node IDs from configuration memory</li>
<li>Parsing configuration data structures</li>
<li>Extracting stored node identifiers</li>
</ul>
<pre class="fragment">* @param buffer Pointer to the configuration memory buffer
* </pre> <pre class="fragment">* @param index Byte offset in the buffer where node ID starts
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 48-bit node ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 6) bytes available. </dd>
<dd>
Does not validate index bounds. </dd>
<dd>
Reading beyond buffer bounds returns undefined values.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#af892a2ef64dfd26cb36667a62ae0f8dc" title="Copies a 6-byte node ID into a configuration memory buffer.">OpenLcbUtilities_copy_node_id_to_config_mem_buffer</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a040663f01e6536b8f9fb5a77181e6015" title="Extracts a 6-byte node ID from the message payload.">OpenLcbUtilities_extract_node_id_from_openlcb_payload</a> - Payload version </dd></dl>

</div>
</div>
<a id="a43ad8d02f8415a5ae8563b5f01dd26ad" name="a43ad8d02f8415a5ae8563b5f01dd26ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ad8d02f8415a5ae8563b5f01dd26ad">&#9670;&#160;</a></span>OpenLcbUtilities_extract_word_from_config_mem_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbUtilities_extract_word_from_config_mem_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a 16-bit word from a configuration memory buffer. </p>
<p>Reads 2 bytes in big-endian format from the buffer starting at the specified index and assembles them into a 16-bit value.</p>
<p>Use cases:</p><ul>
<li>Reading configuration parameters</li>
<li>Extracting stored addresses or offsets</li>
<li>Parsing configuration data structures</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the configuration memory buffer </td></tr>
    <tr><td class="paramname">index</td><td>Byte offset in the buffer where word starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 16-bit value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>buffer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 2) bytes available. </dd>
<dd>
Does not validate index bounds. </dd>
<dd>
Reading beyond buffer bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - Payload version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Read buffer[0 + index], shift left 8 bits</li>
<li>Read buffer[1 + index]</li>
<li>OR the two bytes together</li>
<li>Return assembled 16-bit value</li>
</ol>
<p>Reads 2 bytes in big-endian format from the buffer starting at the specified index and assembles them into a 16-bit value.</p>
<p>Use cases:</p><ul>
<li>Reading configuration parameters</li>
<li>Extracting stored addresses or offsets</li>
<li>Parsing configuration data structures</li>
</ul>
<pre class="fragment">* @param buffer Pointer to the configuration memory buffer
* </pre> <pre class="fragment">* @param index Byte offset in the buffer where word starts
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 16-bit value</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 2) bytes available. </dd>
<dd>
Does not validate index bounds. </dd>
<dd>
Reading beyond buffer bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a1f9a0c01d0fc5ca782be6b10773aceb4" title="Extracts a 16-bit word from the message payload.">OpenLcbUtilities_extract_word_from_openlcb_payload</a> - Payload version </dd></dl>

</div>
</div>
<a id="af892a2ef64dfd26cb36667a62ae0f8dc" name="af892a2ef64dfd26cb36667a62ae0f8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af892a2ef64dfd26cb36667a62ae0f8dc">&#9670;&#160;</a></span>OpenLcbUtilities_copy_node_id_to_config_mem_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_node_id_to_config_mem_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#ab63b0eaf893badf557397c77fb74fe3c">node_id_t</a></td>          <td class="paramname"><span class="paramname"><em>node_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a 6-byte node ID into a configuration memory buffer. </p>
<p>Writes the node ID in big-endian format to the buffer starting at the specified index.</p>
<p>Use cases:</p><ul>
<li>Storing node IDs in configuration memory</li>
<li>Writing configuration data structures</li>
<li>Persisting node identifiers</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the configuration memory buffer </td></tr>
    <tr><td class="paramname">node_id</td><td>The 48-bit node ID to write </td></tr>
    <tr><td class="paramname">index</td><td>Byte offset in the buffer where node ID should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>buffer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 6) bytes available. </dd>
<dd>
Does not validate index bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a8adb3fe5dc4d64da02e252d5bfea2922" title="Extracts a 6-byte node ID from a configuration memory buffer.">OpenLcbUtilities_extract_node_id_from_config_mem_buffer</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aebdc740485642f016371b4604b93aa7f" title="Copies a 6-byte node ID into the message payload at a specified offset.">OpenLcbUtilities_copy_node_id_to_openlcb_payload</a> - Payload version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Loop from byte index 5 down to 0 (big-endian order)</li>
<li>Extract least significant byte of node_id</li>
<li>Write byte to buffer[i + index]</li>
<li>Right-shift node_id by 8 bits</li>
<li>Repeat for all 6 bytes</li>
</ol>
<p>Writes the node ID in big-endian format to the buffer starting at the specified index.</p>
<p>Use cases:</p><ul>
<li>Storing node IDs in configuration memory</li>
<li>Writing configuration data structures</li>
<li>Persisting node identifiers</li>
</ul>
<pre class="fragment">* @param buffer Pointer to the configuration memory buffer
* </pre> <pre class="fragment">* @param node_id The 48-bit node ID to write
* </pre> <pre class="fragment">* @param index Byte offset in the buffer where node ID should be written
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 6) bytes available. </dd>
<dd>
Does not validate index bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a8adb3fe5dc4d64da02e252d5bfea2922" title="Extracts a 6-byte node ID from a configuration memory buffer.">OpenLcbUtilities_extract_node_id_from_config_mem_buffer</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aebdc740485642f016371b4604b93aa7f" title="Copies a 6-byte node ID into the message payload at a specified offset.">OpenLcbUtilities_copy_node_id_to_openlcb_payload</a> - Payload version </dd></dl>

</div>
</div>
<a id="aad0305cbd41a639ad54ff12bd599cce9" name="aad0305cbd41a639ad54ff12bd599cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0305cbd41a639ad54ff12bd599cce9">&#9670;&#160;</a></span>OpenLcbUtilities_copy_event_id_to_config_mem_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_copy_event_id_to_config_mem_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies an 8-byte event ID into a configuration memory buffer. </p>
<p>Writes the event ID in big-endian format to the buffer starting at the specified index.</p>
<p>Use cases:</p><ul>
<li>Storing event IDs in configuration memory</li>
<li>Writing producer/consumer event configurations</li>
<li>Persisting event identifiers</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the configuration memory buffer </td></tr>
    <tr><td class="paramname">event_id</td><td>The 64-bit event ID to write </td></tr>
    <tr><td class="paramname">index</td><td>Byte offset in the buffer where event ID should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>buffer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 8) bytes available. </dd>
<dd>
Does not validate index bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a28f602cb5ef7385e117f152614bd613b" title="Extracts an 8-byte event ID from a configuration memory buffer.">OpenLcbUtilities_copy_config_mem_buffer_to_event_id</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a5e94dfb13e33b2d191f446a38364b7e5" title="Copies an 8-byte event ID into the message payload.">OpenLcbUtilities_copy_event_id_to_openlcb_payload</a> - Payload version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Loop from byte index 7 down to 0 (big-endian order)</li>
<li>Extract least significant byte of event_id</li>
<li>Write byte to buffer[i + index]</li>
<li>Right-shift event_id by 8 bits</li>
<li>Repeat for all 8 bytes</li>
</ol>
<p>Writes the event ID in big-endian format to the buffer starting at the specified index.</p>
<p>Use cases:</p><ul>
<li>Storing event IDs in configuration memory</li>
<li>Writing producer/consumer event configurations</li>
<li>Persisting event identifiers</li>
</ul>
<pre class="fragment">* @param buffer Pointer to the configuration memory buffer
* </pre> <pre class="fragment">* @param event_id The 64-bit event ID to write
* </pre> <pre class="fragment">* @param index Byte offset in the buffer where event ID should be written
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 8) bytes available. </dd>
<dd>
Does not validate index bounds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a28f602cb5ef7385e117f152614bd613b" title="Extracts an 8-byte event ID from a configuration memory buffer.">OpenLcbUtilities_copy_config_mem_buffer_to_event_id</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a5e94dfb13e33b2d191f446a38364b7e5" title="Copies an 8-byte event ID into the message payload.">OpenLcbUtilities_copy_event_id_to_openlcb_payload</a> - Payload version </dd></dl>

</div>
</div>
<a id="a28f602cb5ef7385e117f152614bd613b" name="a28f602cb5ef7385e117f152614bd613b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f602cb5ef7385e117f152614bd613b">&#9670;&#160;</a></span>OpenLcbUtilities_copy_config_mem_buffer_to_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_copy_config_mem_buffer_to_event_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a249892a089c0d512eac257da1ec5b6be">configuration_memory_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an 8-byte event ID from a configuration memory buffer. </p>
<p>Reads 8 bytes in big-endian format from the buffer starting at the specified index and assembles them into a 64-bit event_id_t value.</p>
<p>Use cases:</p><ul>
<li>Reading event IDs from configuration memory</li>
<li>Loading producer/consumer event configurations</li>
<li>Retrieving stored event identifiers</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the configuration memory buffer </td></tr>
    <tr><td class="paramname">index</td><td>Byte offset in the buffer where event ID starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assembled 64-bit event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>buffer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 8) bytes available. </dd>
<dd>
Does not validate index bounds. </dd>
<dd>
Reading beyond buffer bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aad0305cbd41a639ad54ff12bd599cce9" title="Copies an 8-byte event ID into a configuration memory buffer.">OpenLcbUtilities_copy_event_id_to_config_mem_buffer</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#ac06eeb0060f209fa2a094e252473eb3e" title="Extracts an 8-byte event ID from the message payload.">OpenLcbUtilities_extract_event_id_from_openlcb_payload</a> - Payload version</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Initialize retval to 0</li>
<li>For i = 0 to 7:<ol type="a">
<li>Shift retval left by 8 bits</li>
<li>OR with buffer[i + index] masked with 0xFF</li>
</ol>
</li>
<li>Return assembled event ID</li>
</ol>
<p>Reads 8 bytes in big-endian format from the buffer starting at the specified index and assembles them into a 64-bit event_id_t value.</p>
<p>Use cases:</p><ul>
<li>Reading event IDs from configuration memory</li>
<li>Loading producer/consumer event configurations</li>
<li>Retrieving stored event identifiers</li>
</ul>
<pre class="fragment">* @param buffer Pointer to the configuration memory buffer
* </pre> <pre class="fragment">* @param index Byte offset in the buffer where event ID starts
* </pre> <dl class="section return"><dt>Returns</dt><dd>The assembled 64-bit event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Assumes buffer has at least (index + 8) bytes available. </dd>
<dd>
Does not validate index bounds. </dd>
<dd>
Reading beyond buffer bounds returns undefined values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Byte order is big-endian per OpenLCB specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aad0305cbd41a639ad54ff12bd599cce9" title="Copies an 8-byte event ID into a configuration memory buffer.">OpenLcbUtilities_copy_event_id_to_config_mem_buffer</a> - Reverse operation </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#ac06eeb0060f209fa2a094e252473eb3e" title="Extracts an 8-byte event ID from the message payload.">OpenLcbUtilities_extract_event_id_from_openlcb_payload</a> - Payload version </dd></dl>

</div>
</div>
<a id="a06296be3f07fd80febe7dec58eaa5028" name="a06296be3f07fd80febe7dec58eaa5028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06296be3f07fd80febe7dec58eaa5028">&#9670;&#160;</a></span>OpenLcbUtilities_load_config_mem_reply_write_fail_message_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_load_config_mem_reply_write_fail_message_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_write_request_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>error_code</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a configuration memory write failure reply message header. </p>
<p>Constructs a datagram reply message indicating a configuration memory write operation failed. Includes the error code and original request address. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Responding to write requests for read-only memory spaces</li>
<li>Indicating invalid address ranges</li>
<li>Reporting configuration memory errors</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context with message buffers </td></tr>
    <tr><td class="paramname">config_mem_write_request_info</td><td>Pointer to original write request details </td></tr>
    <tr><td class="paramname">error_code</td><td>16-bit error code indicating failure reason</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL. No NULL check performed. </dd>
<dd>
config_mem_write_request_info must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sets outgoing_msg_info.valid to false by default. Application must set to true to actually send the reply.</dd>
<dd>
Error code placement depends on address encoding:<ul>
<li>ADDRESS_SPACE_IN_BYTE_6: error at offset 7</li>
<li>Other encoding: error at offset 6</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aa2c25886675aad1efa582cf2fc318833" title="Loads a configuration memory write success reply message header.">OpenLcbUtilities_load_config_mem_reply_write_ok_message_header</a> - Success version </dd>
<dd>
protocol_config_mem_*.c - Uses this for error responses</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Clear outgoing message payload_count to 0</li>
<li>Load message header with source/dest from state machine info</li>
<li>Set MTI to MTI_DATAGRAM</li>
<li>Copy CONFIG_MEM_CONFIGURATION to payload offset 0</li>
<li>Copy original command byte + FAIL_OFFSET to payload offset 1</li>
<li>Copy write request address (4 bytes) to payload offset 2</li>
<li>If encoding is ADDRESS_SPACE_IN_BYTE_6:<ol type="a">
<li>Copy address space byte from incoming message to payload offset 6</li>
<li>Copy error_code (2 bytes) to payload offset 7</li>
</ol>
</li>
<li>Else:<ol type="a">
<li>Copy error_code (2 bytes) to payload offset 6</li>
</ol>
</li>
<li>Set outgoing_msg_info.valid to false (caller must enable)</li>
</ol>
<p>Constructs a datagram reply message indicating a configuration memory write operation failed. Includes the error code and original request address. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Responding to write requests for read-only memory spaces</li>
<li>Indicating invalid address ranges</li>
<li>Reporting configuration memory errors</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context with message buffers
* </pre> <pre class="fragment">* @param config_mem_write_request_info Pointer to original write request details
* </pre> <pre class="fragment">* @param error_code 16-bit error code indicating failure reason
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sets outgoing_msg_info.valid to false by default. Application must set to true to actually send the reply.</dd>
<dd>
Error code placement depends on address encoding:<ul>
<li>ADDRESS_SPACE_IN_BYTE_6: error at offset 7</li>
<li>Other encoding: error at offset 6</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aa2c25886675aad1efa582cf2fc318833" title="Loads a configuration memory write success reply message header.">OpenLcbUtilities_load_config_mem_reply_write_ok_message_header</a> - Success version </dd>
<dd>
protocol_config_mem_*.c - Uses this for error responses </dd></dl>

</div>
</div>
<a id="aa2c25886675aad1efa582cf2fc318833" name="aa2c25886675aad1efa582cf2fc318833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c25886675aad1efa582cf2fc318833">&#9670;&#160;</a></span>OpenLcbUtilities_load_config_mem_reply_write_ok_message_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_load_config_mem_reply_write_ok_message_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_write_request_info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a configuration memory write success reply message header. </p>
<p>Constructs a datagram reply message indicating a configuration memory write operation succeeded. Includes the original request address. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Acknowledging successful configuration memory writes</li>
<li>Confirming data was stored correctly</li>
<li>Completing write request transactions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context with message buffers </td></tr>
    <tr><td class="paramname">config_mem_write_request_info</td><td>Pointer to original write request details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL. No NULL check performed. </dd>
<dd>
config_mem_write_request_info must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sets outgoing_msg_info.valid to false by default. Application must set to true to actually send the reply.</dd>
<dd>
Address space byte (byte 6) only included if encoding is ADDRESS_SPACE_IN_BYTE_6.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a06296be3f07fd80febe7dec58eaa5028" title="Loads a configuration memory write failure reply message header.">OpenLcbUtilities_load_config_mem_reply_write_fail_message_header</a> - Failure version </dd>
<dd>
protocol_config_mem_*.c - Uses this for success responses</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Clear outgoing message payload_count to 0</li>
<li>Load message header with source/dest from state machine info</li>
<li>Set MTI to MTI_DATAGRAM</li>
<li>Copy CONFIG_MEM_CONFIGURATION to payload offset 0</li>
<li>Copy original command byte + OK_OFFSET to payload offset 1</li>
<li>Copy write request address (4 bytes) to payload offset 2</li>
<li>If encoding is ADDRESS_SPACE_IN_BYTE_6:<ol type="a">
<li>Copy address space byte from incoming message to payload offset 6</li>
</ol>
</li>
<li>Set outgoing_msg_info.valid to false (caller must enable)</li>
</ol>
<p>Constructs a datagram reply message indicating a configuration memory write operation succeeded. Includes the original request address. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Acknowledging successful configuration memory writes</li>
<li>Confirming data was stored correctly</li>
<li>Completing write request transactions</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context with message buffers
* </pre> <pre class="fragment">* @param config_mem_write_request_info Pointer to original write request details
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Sets outgoing_msg_info.valid to false by default. Application must set to true to actually send the reply.</dd>
<dd>
Address space byte (byte 6) only included if encoding is ADDRESS_SPACE_IN_BYTE_6.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#a06296be3f07fd80febe7dec58eaa5028" title="Loads a configuration memory write failure reply message header.">OpenLcbUtilities_load_config_mem_reply_write_fail_message_header</a> - Failure version </dd>
<dd>
protocol_config_mem_*.c - Uses this for success responses </dd></dl>

</div>
</div>
<a id="ad0acbbfd410c33c725f1be639783dbf7" name="ad0acbbfd410c33c725f1be639783dbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0acbbfd410c33c725f1be639783dbf7">&#9670;&#160;</a></span>OpenLcbUtilities_load_config_mem_reply_read_fail_message_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_load_config_mem_reply_read_fail_message_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__read__request__info__t.html">config_mem_read_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_read_request_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>error_code</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a configuration memory read failure reply message header. </p>
<p>Constructs a datagram reply message indicating a configuration memory read operation failed. Includes the error code at the data start position where data would have been placed. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Responding to read requests for invalid addresses</li>
<li>Indicating unavailable memory spaces</li>
<li>Reporting configuration memory errors</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context with message buffers </td></tr>
    <tr><td class="paramname">config_mem_read_request_info</td><td>Pointer to original read request details </td></tr>
    <tr><td class="paramname">error_code</td><td>16-bit error code indicating failure reason</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL. No NULL check performed. </dd>
<dd>
config_mem_read_request_info must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Error code is placed at config_mem_read_request_info-&gt;data_start offset, where the actual data would have been.</dd>
<dd>
Address space byte (byte 6) only included if encoding is ADDRESS_SPACE_IN_BYTE_6.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification. </dd>
<dd>
Does NOT set outgoing_msg_info.valid (differs from write functions).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#add25f972525f3d14f22f4657a74e0c9c" title="Loads a configuration memory read success reply message header.">OpenLcbUtilities_load_config_mem_reply_read_ok_message_header</a> - Success version </dd>
<dd>
protocol_config_mem_*.c - Uses this for error responses</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Clear outgoing message payload_count to 0</li>
<li>Load message header with source/dest from state machine info</li>
<li>Set MTI to MTI_DATAGRAM</li>
<li>Copy CONFIG_MEM_CONFIGURATION to payload offset 0</li>
<li>Copy original command byte + FAIL_OFFSET to payload offset 1</li>
<li>Copy read request address (4 bytes) to payload offset 2</li>
<li>If encoding is ADDRESS_SPACE_IN_BYTE_6:<ol type="a">
<li>Copy address space byte from incoming message to payload offset 6</li>
</ol>
</li>
<li>Copy error_code (2 bytes) to payload at config_mem_read_request_info-&gt;data_start</li>
</ol>
<p>Constructs a datagram reply message indicating a configuration memory read operation failed. Includes the error code at the data start position where data would have been placed. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Responding to read requests for invalid addresses</li>
<li>Indicating unavailable memory spaces</li>
<li>Reporting configuration memory errors</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context with message buffers
* </pre> <pre class="fragment">* @param config_mem_read_request_info Pointer to original read request details
* </pre> <pre class="fragment">* @param error_code 16-bit error code indicating failure reason
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Error code is placed at config_mem_read_request_info-&gt;data_start offset, where the actual data would have been.</dd>
<dd>
Address space byte (byte 6) only included if encoding is ADDRESS_SPACE_IN_BYTE_6.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification. </dd>
<dd>
Does NOT set outgoing_msg_info.valid (differs from write functions).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#add25f972525f3d14f22f4657a74e0c9c" title="Loads a configuration memory read success reply message header.">OpenLcbUtilities_load_config_mem_reply_read_ok_message_header</a> - Success version </dd>
<dd>
protocol_config_mem_*.c - Uses this for error responses </dd></dl>

</div>
</div>
<a id="add25f972525f3d14f22f4657a74e0c9c" name="add25f972525f3d14f22f4657a74e0c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add25f972525f3d14f22f4657a74e0c9c">&#9670;&#160;</a></span>OpenLcbUtilities_load_config_mem_reply_read_ok_message_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_load_config_mem_reply_read_ok_message_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__read__request__info__t.html">config_mem_read_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_read_request_info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a configuration memory read success reply message header. </p>
<p>Constructs a datagram reply message header indicating a configuration memory read operation succeeded. Sets up the header fields; actual data bytes must be added separately by the caller. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Preparing successful configuration memory read replies</li>
<li>Setting up header before copying data bytes</li>
<li>Acknowledging valid read requests</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context with message buffers </td></tr>
    <tr><td class="paramname">config_mem_read_request_info</td><td>Pointer to original read request details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL. No NULL check performed. </dd>
<dd>
config_mem_read_request_info must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This function only loads the HEADER. The caller must append the actual data bytes using copy_byte_array or similar functions.</dd>
<dd>
Sets outgoing_msg_info.valid to false by default. Application must set to true after adding data to actually send the reply.</dd>
<dd>
Address space byte (byte 6) only included if encoding is ADDRESS_SPACE_IN_BYTE_6.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#ad0acbbfd410c33c725f1be639783dbf7" title="Loads a configuration memory read failure reply message header.">OpenLcbUtilities_load_config_mem_reply_read_fail_message_header</a> - Failure version </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a39d5ca6fda22ae42d9b6efa8ca6dd81c" title="Copies a byte array into the message payload.">OpenLcbUtilities_copy_byte_array_to_openlcb_payload</a> - For adding data </dd>
<dd>
protocol_config_mem_*.c - Uses this for success responses</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Clear outgoing message payload_count to 0</li>
<li>Load message header with source/dest from state machine info</li>
<li>Set MTI to MTI_DATAGRAM</li>
<li>Copy CONFIG_MEM_CONFIGURATION to payload offset 0</li>
<li>Copy original command byte + OK_OFFSET to payload offset 1</li>
<li>Copy read request address (4 bytes) to payload offset 2</li>
<li>If encoding is ADDRESS_SPACE_IN_BYTE_6:<ol type="a">
<li>Copy address space byte from incoming message to payload offset 6</li>
</ol>
</li>
<li>Set outgoing_msg_info.valid to false (caller must enable)</li>
</ol>
<p>Constructs a datagram reply message header indicating a configuration memory read operation succeeded. Sets up the header fields; actual data bytes must be added separately by the caller. Handles both 4-byte and 6-byte address encoding formats.</p>
<p>Use cases:</p><ul>
<li>Preparing successful configuration memory read replies</li>
<li>Setting up header before copying data bytes</li>
<li>Acknowledging valid read requests</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context with message buffers
* </pre> <pre class="fragment">* @param config_mem_read_request_info Pointer to original read request details
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL. No NULL check performed. </dd>
<dd>
Pointer must not be NULL. No NULL check performed. </dd>
<dd>
statemachine_info-&gt;outgoing_msg_info.msg_ptr must be valid.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This function only loads the HEADER. The caller must append the actual data bytes using copy_byte_array or similar functions.</dd>
<dd>
Sets outgoing_msg_info.valid to false by default. Application must set to true after adding data to actually send the reply.</dd>
<dd>
Address space byte (byte 6) only included if encoding is ADDRESS_SPACE_IN_BYTE_6.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reply format follows OpenLCB Configuration Memory protocol specification.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant time operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#ad0acbbfd410c33c725f1be639783dbf7" title="Loads a configuration memory read failure reply message header.">OpenLcbUtilities_load_config_mem_reply_read_fail_message_header</a> - Failure version </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a39d5ca6fda22ae42d9b6efa8ca6dd81c" title="Copies a byte array into the message payload.">OpenLcbUtilities_copy_byte_array_to_openlcb_payload</a> - For adding data </dd>
<dd>
protocol_config_mem_*.c - Uses this for success responses </dd></dl>

</div>
</div>
<a id="a47b6a34610057c9cc23e130ddc33617f" name="a47b6a34610057c9cc23e130ddc33617f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b6a34610057c9cc23e130ddc33617f">&#9670;&#160;</a></span>OpenLcbUtilities_generate_event_range_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_generate_event_range_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>base_event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a29cac8697a125631149cacda733a9faa">event_range_count_enum</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96b7768edfeaf28e8a9474455f93659" name="ac96b7768edfeaf28e8a9474455f93659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96b7768edfeaf28e8a9474455f93659">&#9670;&#160;</a></span>OpenLcbUtilities_is_event_id_in_consumer_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_event_id_in_consumer_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad3895e8e4933d384cf8c626fa00f51c" name="aad3895e8e4933d384cf8c626fa00f51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3895e8e4933d384cf8c626fa00f51c">&#9670;&#160;</a></span>OpenLcbUtilities_is_event_id_in_producer_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_event_id_in_producer_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d3dedeec93238f781376e67143c010c" name="a9d3dedeec93238f781376e67143c010c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3dedeec93238f781376e67143c010c">&#9670;&#160;</a></span>OpenLcbUtilities_is_broadcast_time_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_broadcast_time_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an Event ID is a broadcast time event. </p>
<p>Checks if the upper 6 bytes of the Event ID match any of the well-known broadcast time clock IDs. This is used to detect time events before passing them to the broadcast time protocol handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit Event ID to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if Event ID is a broadcast time event, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaf584d752ad0787034618a14f69c4a11" title="Determines the type of broadcast time event from Event ID.">OpenLcbUtilities_get_broadcast_time_event_type</a> - Determines event type </dd>
<dd>
<a class="el" href="group__broadcast__time__events.html#gaa660f0e811458386f2e21f644ac0aade" title="Mask for extracting clock ID (upper 6 bytes) from Event ID.">BROADCAST_TIME_MASK_CLOCK_ID</a> - Mask for extracting clock ID </dd></dl>

</div>
</div>
<a id="a2f31c219624dab8c2aa02e39c2bca96e" name="a2f31c219624dab8c2aa02e39c2bca96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f31c219624dab8c2aa02e39c2bca96e">&#9670;&#160;</a></span>OpenLcbUtilities_extract_clock_id_from_time_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t OpenLcbUtilities_extract_clock_id_from_time_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts clock ID from broadcast time Event ID. </p>
<p>Extracts the upper 6 bytes of the Event ID which identify which clock this event belongs to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit broadcast time Event ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>48-bit clock identifier (upper 6 bytes of Event ID)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__broadcast__time__events.html#gaa660f0e811458386f2e21f644ac0aade" title="Mask for extracting clock ID (upper 6 bytes) from Event ID.">BROADCAST_TIME_MASK_CLOCK_ID</a> - Mask used for extraction </dd></dl>

</div>
</div>
<a id="aaf584d752ad0787034618a14f69c4a11" name="aaf584d752ad0787034618a14f69c4a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf584d752ad0787034618a14f69c4a11">&#9670;&#160;</a></span>OpenLcbUtilities_get_broadcast_time_event_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#ab52e2c84bc398c0dea7b742e92e2314a">broadcast_time_event_type_enum</a> OpenLcbUtilities_get_broadcast_time_event_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the type of broadcast time event from Event ID. </p>
<p>Examines the lower 2 bytes of the Event ID to determine which type of broadcast time event it represents (time, date, year, rate, command).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit broadcast time Event ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerated event type, or BROADCAST_TIME_EVENT_UNKNOWN if invalid</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__types_8h.html#ab52e2c84bc398c0dea7b742e92e2314a" title="Broadcast Time Protocol event type enumeration.">broadcast_time_event_type_enum</a> - Return value enumeration </dd></dl>

</div>
</div>
<a id="aed514896d5573d06d6b41b5753091a08" name="aed514896d5573d06d6b41b5753091a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed514896d5573d06d6b41b5753091a08">&#9670;&#160;</a></span>OpenLcbUtilities_extract_time_from_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_extract_time_from_event_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>hour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>minute</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts time (hour/minute) from broadcast time Event ID. </p>
<p>Decodes hour and minute from the lower 2 bytes of a Report Time or Set Time Event ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit broadcast time Event ID </td></tr>
    <tr><td class="paramname">hour</td><td>Pointer to store extracted hour (0-23) </td></tr>
    <tr><td class="paramname">minute</td><td>Pointer to store extracted minute (0-59)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if extraction successful and values valid, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns false if hour &gt;= 24 or minute &gt;= 60 </dd></dl>

</div>
</div>
<a id="afa3b8179b16d53d28e90c3a5e1340193" name="afa3b8179b16d53d28e90c3a5e1340193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3b8179b16d53d28e90c3a5e1340193">&#9670;&#160;</a></span>OpenLcbUtilities_extract_date_from_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_extract_date_from_event_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>month</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>day</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts date (month/day) from broadcast time Event ID. </p>
<p>Decodes month and day from the lower 2 bytes of a Report Date or Set Date Event ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit broadcast time Event ID </td></tr>
    <tr><td class="paramname">month</td><td>Pointer to store extracted month (1-12) </td></tr>
    <tr><td class="paramname">day</td><td>Pointer to store extracted day (1-31)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if extraction successful and values valid, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns false if month &lt; 1 or month &gt; 12 or day &lt; 1 or day &gt; 31 </dd></dl>

</div>
</div>
<a id="abc10b4f6a222e95a620a12d193a27c69" name="abc10b4f6a222e95a620a12d193a27c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc10b4f6a222e95a620a12d193a27c69">&#9670;&#160;</a></span>OpenLcbUtilities_extract_year_from_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_extract_year_from_event_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>year</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts year from broadcast time Event ID. </p>
<p>Decodes year from the lower 2 bytes of a Report Year or Set Year Event ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit broadcast time Event ID </td></tr>
    <tr><td class="paramname">year</td><td>Pointer to store extracted year (0-4095 AD)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if extraction successful, false otherwise </dd></dl>

</div>
</div>
<a id="a25a2546a9cd1f6caf4fefc7c9471847e" name="a25a2546a9cd1f6caf4fefc7c9471847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a2546a9cd1f6caf4fefc7c9471847e">&#9670;&#160;</a></span>OpenLcbUtilities_extract_rate_from_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_extract_rate_from_event_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *</td>          <td class="paramname"><span class="paramname"><em>rate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts clock rate from broadcast time Event ID. </p>
<p>Decodes the 12-bit signed fixed-point rate value from a Report Rate or Set Rate Event ID. Rate format is 10.2 fixed point (2 fractional bits).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit broadcast time Event ID </td></tr>
    <tr><td class="paramname">rate</td><td>Pointer to store extracted rate (12-bit signed fixed point)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if extraction successful, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Rate examples: 0x0004=1.00 (real-time), 0x0010=4.00 (4x speed) </dd></dl>

</div>
</div>
<a id="a0749230cbe60928a3f601a0d919fdd46" name="a0749230cbe60928a3f601a0d919fdd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0749230cbe60928a3f601a0d919fdd46">&#9670;&#160;</a></span>OpenLcbUtilities_create_time_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_create_time_event_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>clock_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>hour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>minute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a broadcast time Event ID for time events. </p>
<p>Constructs a Report Time or Set Time Event ID by encoding hour and minute into the lower 2 bytes of the specified clock ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_id</td><td>48-bit clock identifier (upper 6 bytes) </td></tr>
    <tr><td class="paramname">hour</td><td>Hour value (0-23) </td></tr>
    <tr><td class="paramname">minute</td><td>Minute value (0-59) </td></tr>
    <tr><td class="paramname">is_set</td><td>true for Set Time, false for Report Time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit broadcast time Event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No validation - caller must ensure hour &lt; 24 and minute &lt; 60 </dd></dl>

</div>
</div>
<a id="a3316cbf73ccec04d15b6f4a2285a7729" name="a3316cbf73ccec04d15b6f4a2285a7729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3316cbf73ccec04d15b6f4a2285a7729">&#9670;&#160;</a></span>OpenLcbUtilities_create_date_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_create_date_event_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>clock_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>month</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>day</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a broadcast time Event ID for date events. </p>
<p>Constructs a Report Date or Set Date Event ID by encoding month and day into the lower 2 bytes of the specified clock ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_id</td><td>48-bit clock identifier (upper 6 bytes) </td></tr>
    <tr><td class="paramname">month</td><td>Month value (1-12) </td></tr>
    <tr><td class="paramname">day</td><td>Day value (1-31) </td></tr>
    <tr><td class="paramname">is_set</td><td>true for Set Date, false for Report Date</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit broadcast time Event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No validation - caller must ensure valid month/day values </dd></dl>

</div>
</div>
<a id="a57fc8ec6df0324d5a8a2b96872fb999c" name="a57fc8ec6df0324d5a8a2b96872fb999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fc8ec6df0324d5a8a2b96872fb999c">&#9670;&#160;</a></span>OpenLcbUtilities_create_year_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_create_year_event_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>clock_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>year</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a broadcast time Event ID for year events. </p>
<p>Constructs a Report Year or Set Year Event ID by encoding year into the lower 2 bytes of the specified clock ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_id</td><td>48-bit clock identifier (upper 6 bytes) </td></tr>
    <tr><td class="paramname">year</td><td>Year value (0-4095 AD) </td></tr>
    <tr><td class="paramname">is_set</td><td>true for Set Year, false for Report Year</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit broadcast time Event ID</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No validation - caller must ensure year &lt;= 4095 </dd></dl>

</div>
</div>
<a id="a4075cb9bc1895bda34727a603915c342" name="a4075cb9bc1895bda34727a603915c342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4075cb9bc1895bda34727a603915c342">&#9670;&#160;</a></span>OpenLcbUtilities_create_rate_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_create_rate_event_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>clock_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>rate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a broadcast time Event ID for rate events. </p>
<p>Constructs a Report Rate or Set Rate Event ID by encoding the 12-bit signed fixed-point rate into the lower 2 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_id</td><td>48-bit clock identifier (upper 6 bytes) </td></tr>
    <tr><td class="paramname">rate</td><td>12-bit signed fixed point rate value </td></tr>
    <tr><td class="paramname">is_set</td><td>true for Set Rate, false for Report Rate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit broadcast time Event ID</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Rate format: 10.2 fixed point (e.g., 0x0004 = 1.00) </dd></dl>

</div>
</div>
<a id="a4cfdd3213341ea2e3aa3c04f1a991205" name="a4cfdd3213341ea2e3aa3c04f1a991205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfdd3213341ea2e3aa3c04f1a991205">&#9670;&#160;</a></span>OpenLcbUtilities_create_command_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_create_command_event_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>clock_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#ab52e2c84bc398c0dea7b742e92e2314a">broadcast_time_event_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>command</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a broadcast time Event ID for command events. </p>
<p>Constructs a command Event ID (Query, Start, Stop, Date Rollover) for the specified clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_id</td><td>48-bit clock identifier (upper 6 bytes) </td></tr>
    <tr><td class="paramname">command</td><td>Command type (QUERY, START, STOP, DATE_ROLLOVER)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit broadcast time Event ID </dd></dl>

</div>
</div>
<a id="a72ea82898e834d55b36e11e07a83c04a" name="a72ea82898e834d55b36e11e07a83c04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ea82898e834d55b36e11e07a83c04a">&#9670;&#160;</a></span>OpenLcbUtilities_is_train_search_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbUtilities_is_train_search_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether an event ID belongs to the Train Search space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>64-bit Event ID to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if upper 4 bytes are 0x090099FF </dd></dl>

</div>
</div>
<a id="ac16df99aa78e31a3d04339e23d1f9db8" name="ac16df99aa78e31a3d04339e23d1f9db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16df99aa78e31a3d04339e23d1f9db8">&#9670;&#160;</a></span>OpenLcbUtilities_extract_train_search_digits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbUtilities_extract_train_search_digits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>digits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts 6 search-query nibbles from a train search event ID. </p>
<p>Nibbles are in bytes 4-6 (bits 31-8). Each nibble is 0-9 for a digit or 0xF for empty/wildcard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>The search event ID </td></tr>
    <tr><td class="paramname">digits</td><td>Output array of 6 uint8_t values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5eda1bd2c9a26747d3d239661d99b8a" name="aa5eda1bd2c9a26747d3d239661d99b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5eda1bd2c9a26747d3d239661d99b8a">&#9670;&#160;</a></span>OpenLcbUtilities_extract_train_search_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t OpenLcbUtilities_extract_train_search_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a></td>          <td class="paramname"><span class="paramname"><em>event_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the flags byte (byte 7) from a train search event ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>The search event ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 8-bit flags byte </dd></dl>

</div>
</div>
<a id="afe285d8d2b51616c319f1e98983e1f7b" name="afe285d8d2b51616c319f1e98983e1f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe285d8d2b51616c319f1e98983e1f7b">&#9670;&#160;</a></span>OpenLcbUtilities_train_search_digits_to_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbUtilities_train_search_digits_to_address </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>digits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 6-nibble digit array to a numeric DCC address. </p>
<p>Skips leading 0xF nibbles. E.g. {F,F,F,0,0,3} -&gt; 3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digits</td><td>Array of 6 nibble values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The numeric address (0 if all empty) </dd></dl>

</div>
</div>
<a id="a1601d2fefb6a3693e58b50956e42376a" name="a1601d2fefb6a3693e58b50956e42376a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1601d2fefb6a3693e58b50956e42376a">&#9670;&#160;</a></span>OpenLcbUtilities_create_train_search_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openlcb__types_8h.html#a124e6ffe91515b7b9f36f42c3517e70c">event_id_t</a> OpenLcbUtilities_create_train_search_event_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a train search event ID from address and flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>DCC address to encode (0-9999) </td></tr>
    <tr><td class="paramname">flags</td><td>Flags byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit train search event ID </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
