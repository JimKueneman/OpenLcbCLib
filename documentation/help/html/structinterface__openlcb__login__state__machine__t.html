<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: interface_openlcb_login_state_machine_t Struct Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">interface_openlcb_login_state_machine_t Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Interface structure for login state machine callback functions.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a216efd7bdc468e6395aa0e5ba04f1060" id="r_a216efd7bdc468e6395aa0e5ba04f1060"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a216efd7bdc468e6395aa0e5ba04f1060">send_openlcb_msg</a> )(<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg)</td></tr>
<tr class="memdesc:a216efd7bdc468e6395aa0e5ba04f1060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to send an OpenLCB message to the network.  <br /></td></tr>
<tr class="separator:a216efd7bdc468e6395aa0e5ba04f1060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642f075eed427764e99bda659f1fd22f" id="r_a642f075eed427764e99bda659f1fd22f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642f075eed427764e99bda659f1fd22f">openlcb_node_get_first</a> )(uint8_t key)</td></tr>
<tr class="memdesc:a642f075eed427764e99bda659f1fd22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to get the first OpenLCB node for enumeration.  <br /></td></tr>
<tr class="separator:a642f075eed427764e99bda659f1fd22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae198d49b6505cbba8429aeb49fa3879e" id="r_ae198d49b6505cbba8429aeb49fa3879e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae198d49b6505cbba8429aeb49fa3879e">openlcb_node_get_next</a> )(uint8_t key)</td></tr>
<tr class="memdesc:ae198d49b6505cbba8429aeb49fa3879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to get the next OpenLCB node for enumeration.  <br /></td></tr>
<tr class="separator:ae198d49b6505cbba8429aeb49fa3879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1423a4675d09949c3d5c0fa2416a0410" id="r_a1423a4675d09949c3d5c0fa2416a0410"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1423a4675d09949c3d5c0fa2416a0410">load_initialization_complete</a> )(<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td></tr>
<tr class="memdesc:a1423a4675d09949c3d5c0fa2416a0410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to load an Initialization Complete message.  <br /></td></tr>
<tr class="separator:a1423a4675d09949c3d5c0fa2416a0410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a77556d4cfa484a8541292be3000c2" id="r_ad3a77556d4cfa484a8541292be3000c2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a77556d4cfa484a8541292be3000c2">load_producer_events</a> )(<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td></tr>
<tr class="memdesc:ad3a77556d4cfa484a8541292be3000c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to load Producer Event Identified messages.  <br /></td></tr>
<tr class="separator:ad3a77556d4cfa484a8541292be3000c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580f2ad00e2adbd8091236f015cd1f3c" id="r_a580f2ad00e2adbd8091236f015cd1f3c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a580f2ad00e2adbd8091236f015cd1f3c">load_consumer_events</a> )(<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td></tr>
<tr class="memdesc:a580f2ad00e2adbd8091236f015cd1f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to load Consumer Event Identified messages.  <br /></td></tr>
<tr class="separator:a580f2ad00e2adbd8091236f015cd1f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13334393662839a3c993f198ad5bce8e" id="r_a13334393662839a3c993f198ad5bce8e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13334393662839a3c993f198ad5bce8e">process_login_statemachine</a> )(<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a13334393662839a3c993f198ad5bce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function pointer for state machine processing.  <br /></td></tr>
<tr class="separator:a13334393662839a3c993f198ad5bce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e0289f2a6d968d59d8f2392e7238d9" id="r_a21e0289f2a6d968d59d8f2392e7238d9"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21e0289f2a6d968d59d8f2392e7238d9">handle_outgoing_openlcb_message</a> )(void)</td></tr>
<tr class="memdesc:a21e0289f2a6d968d59d8f2392e7238d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function pointer for message transmission handling.  <br /></td></tr>
<tr class="separator:a21e0289f2a6d968d59d8f2392e7238d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d0bb10ab97a4dfb5cc19819656c7db" id="r_a87d0bb10ab97a4dfb5cc19819656c7db"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d0bb10ab97a4dfb5cc19819656c7db">handle_try_reenumerate</a> )(void)</td></tr>
<tr class="memdesc:a87d0bb10ab97a4dfb5cc19819656c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function pointer for re-enumeration handling.  <br /></td></tr>
<tr class="separator:a87d0bb10ab97a4dfb5cc19819656c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace54b5c03eafd093615c3de2f76587b1" id="r_ace54b5c03eafd093615c3de2f76587b1"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace54b5c03eafd093615c3de2f76587b1">handle_try_enumerate_first_node</a> )(void)</td></tr>
<tr class="memdesc:ace54b5c03eafd093615c3de2f76587b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function pointer for first node enumeration.  <br /></td></tr>
<tr class="separator:ace54b5c03eafd093615c3de2f76587b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dbaa73eb2229932ffc76416db879e7" id="r_a41dbaa73eb2229932ffc76416db879e7"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41dbaa73eb2229932ffc76416db879e7">handle_try_enumerate_next_node</a> )(void)</td></tr>
<tr class="memdesc:a41dbaa73eb2229932ffc76416db879e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function pointer for next node enumeration.  <br /></td></tr>
<tr class="separator:a41dbaa73eb2229932ffc76416db879e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface structure for login state machine callback functions. </p>
<p>This structure defines the callback interface for the OpenLCB login state machine, which orchestrates the complete node initialization sequence after successful CAN alias allocation. The login state machine manages the three-phase process of announcing nodes on the network:</p>
<ol type="1">
<li>Send Initialization Complete message</li>
<li>Send Producer Event Identified messages for all produced events</li>
<li>Send Consumer Event Identified messages for all consumed events</li>
</ol>
<p>The interface provides callbacks organized into several functional categories:</p>
<p><b>Required Message Transmission Callbacks:</b></p><ul>
<li>send_openlcb_msg: Transmit OpenLCB messages to the network</li>
</ul>
<p><b>Required Node Enumeration Callbacks:</b></p><ul>
<li>openlcb_node_get_first: Begin node enumeration</li>
<li>openlcb_node_get_next: Continue node enumeration</li>
</ul>
<p><b>Required Message Handler Callbacks:</b></p><ul>
<li>load_initialization_complete: Construct Initialization Complete message</li>
<li>load_producer_events: Construct Producer Event Identified messages</li>
<li>load_consumer_events: Construct Consumer Event Identified messages</li>
</ul>
<p><b>Internal Functions (for testing):</b></p><ul>
<li>process_login_statemachine: State dispatcher</li>
<li>handle_outgoing_openlcb_message: Message transmission handler</li>
<li>handle_try_reenumerate: Re-enumeration controller</li>
<li>handle_try_enumerate_first_node: First node enumerator</li>
<li>handle_try_enumerate_next_node: Next node enumerator</li>
</ul>
<p>The state machine operates in a non-blocking manner, performing one step of processing per call to <a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run()</a>. It automatically enumerates all nodes that require login processing and dispatches them through the appropriate handlers based on their run_state.</p>
<dl class="section note"><dt>Note</dt><dd>All required callbacks must be set before calling OpenLcbLoginStateMachine_initialize </dd>
<dd>
Internal function pointers are for unit testing - they reference module functions</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__login__statemachine_8c.html#a3f2b3309b14784eba7f14e9e87a0fe09" title="Initializes the login state machine with callback interface.">OpenLcbLoginStateMachine_initialize</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine__handler_8h.html" title="Login state machine message handler for OpenLCB initialization and event broadcasting.">openlcb_login_statemachine_handler.h</a> - Message construction handlers </dd></dl>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a216efd7bdc468e6395aa0e5ba04f1060" name="a216efd7bdc468e6395aa0e5ba04f1060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216efd7bdc468e6395aa0e5ba04f1060">&#9670;&#160;</a></span>send_openlcb_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* send_openlcb_msg) (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *outgoing_msg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to send an OpenLCB message to the network. </p>
<p>This required callback transmits an OpenLCB message to the network. The implementation should attempt to queue the message for transmission and return true if successful. If the transmission buffer is full or transmission fails, the callback should return false, causing the state machine to retry on the next iteration.</p>
<p>The message includes source alias, source Node ID, MTI, and payload data. The callback is responsible for converting the OpenLCB message to the appropriate CAN frames via the CAN TX state machine.</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd></dl>

</div>
</div>
<a id="a642f075eed427764e99bda659f1fd22f" name="a642f075eed427764e99bda659f1fd22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642f075eed427764e99bda659f1fd22f">&#9670;&#160;</a></span>openlcb_node_get_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *(* openlcb_node_get_first) (uint8_t key)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to get the first OpenLCB node for enumeration. </p>
<p>This required callback initiates node enumeration by returning the first node in the node list. The enumeration uses a key parameter to maintain separate iteration contexts for different state machines (login vs main state machine).</p>
<p>The callback should return the first allocated node in the node pool, or NULL if no nodes exist. The login state machine will process nodes that are in initialization states (not yet in RUNSTATE_RUN).</p>
<p>Typical implementation: Return first entry from node pool array.</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd></dl>

</div>
</div>
<a id="ae198d49b6505cbba8429aeb49fa3879e" name="ae198d49b6505cbba8429aeb49fa3879e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae198d49b6505cbba8429aeb49fa3879e">&#9670;&#160;</a></span>openlcb_node_get_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *(* openlcb_node_get_next) (uint8_t key)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to get the next OpenLCB node for enumeration. </p>
<p>This required callback continues node enumeration by returning the next node in the node list. The enumeration uses a key parameter to maintain separate iteration contexts for different state machines.</p>
<p>The callback should return the next allocated node in the node pool, or NULL when the end of the list is reached. The login state machine will process nodes that are in initialization states (not yet in RUNSTATE_RUN).</p>
<p>Typical implementation: Increment index and return next entry from node pool array.</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd></dl>

</div>
</div>
<a id="a1423a4675d09949c3d5c0fa2416a0410" name="a1423a4675d09949c3d5c0fa2416a0410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1423a4675d09949c3d5c0fa2416a0410">&#9670;&#160;</a></span>load_initialization_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* load_initialization_complete) (<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to load an Initialization Complete message. </p>
<p>This required callback constructs an Initialization Complete message for the node currently being processed. The message announces the node's presence on the network and signals readiness to participate in OpenLCB operations.</p>
<p>The callback should:</p><ul>
<li>Build the message with MTI 0x0100 (Full) or 0x0101 (Simple)</li>
<li>Include the node's 6-byte Node ID in the payload</li>
<li>Set outgoing_msg_info.valid to true to trigger transmission</li>
<li>Mark the node as initialized</li>
<li>Transition to RUNSTATE_LOAD_PRODUCER_EVENTS</li>
</ul>
<p>Typical implementation: OpenLcbLoginMessageHandler_load_initialization_complete</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd></dl>

</div>
</div>
<a id="ad3a77556d4cfa484a8541292be3000c2" name="ad3a77556d4cfa484a8541292be3000c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a77556d4cfa484a8541292be3000c2">&#9670;&#160;</a></span>load_producer_events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* load_producer_events) (<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to load Producer Event Identified messages. </p>
<p>This required callback constructs Producer Identified messages for the node's produced events. The callback may be invoked multiple times via the enumeration mechanism to send one message per produced event.</p>
<p>The callback should:</p><ul>
<li>Check if producers exist (count &gt; 0)</li>
<li>Get MTI for current event state (Valid/Invalid/Unknown)</li>
<li>Build message with 8-byte Event ID in payload</li>
<li>Increment enum_index</li>
<li>Set enumerate flag if more events remain</li>
<li>Transition to RUNSTATE_LOAD_CONSUMER_EVENTS when complete</li>
</ul>
<p>Typical implementation: OpenLcbLoginMessageHandler_load_producer_event</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd></dl>

</div>
</div>
<a id="a580f2ad00e2adbd8091236f015cd1f3c" name="a580f2ad00e2adbd8091236f015cd1f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580f2ad00e2adbd8091236f015cd1f3c">&#9670;&#160;</a></span>load_consumer_events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* load_consumer_events) (<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to load Consumer Event Identified messages. </p>
<p>This required callback constructs Consumer Identified messages for the node's consumed events. The callback may be invoked multiple times via the enumeration mechanism to send one message per consumed event. This is the final step in the login sequence.</p>
<p>The callback should:</p><ul>
<li>Check if consumers exist (count &gt; 0)</li>
<li>Get MTI for current event state (Valid/Invalid/Unknown)</li>
<li>Build message with 8-byte Event ID in payload</li>
<li>Increment enum_index</li>
<li>Set enumerate flag if more events remain</li>
<li>Transition to RUNSTATE_RUN when complete (node fully initialized)</li>
</ul>
<p>Typical implementation: OpenLcbLoginMessageHandler_load_consumer_event</p>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL </dd></dl>

</div>
</div>
<a id="a13334393662839a3c993f198ad5bce8e" name="a13334393662839a3c993f198ad5bce8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13334393662839a3c993f198ad5bce8e">&#9670;&#160;</a></span>process_login_statemachine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* process_login_statemachine) (<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *statemachine_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function pointer for state machine processing. </p>
<p>This callback dispatches to the appropriate message handler based on the node's current run_state. It is exposed through the interface to enable unit testing of the state dispatch logic.</p>
<p>Typical implementation: OpenLcbLoginStateMachine_process</p>
<p>This callback examines node-&gt;run_state and calls:</p><ul>
<li>load_initialization_complete if RUNSTATE_LOAD_INITIALIZATION_COMPLETE</li>
<li>load_producer_events if RUNSTATE_LOAD_PRODUCER_EVENTS</li>
<li>load_consumer_events if RUNSTATE_LOAD_CONSUMER_EVENTS</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL (set to module function) </dd></dl>

</div>
</div>
<a id="a21e0289f2a6d968d59d8f2392e7238d9" name="a21e0289f2a6d968d59d8f2392e7238d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e0289f2a6d968d59d8f2392e7238d9">&#9670;&#160;</a></span>handle_outgoing_openlcb_message</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handle_outgoing_openlcb_message) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function pointer for message transmission handling. </p>
<p>This callback attempts to transmit any pending outgoing message by checking the valid flag and calling send_openlcb_msg. It is exposed through the interface to enable unit testing of transmission logic.</p>
<p>Typical implementation: OpenLcbLoginStatemachine_handle_outgoing_openlcb_message</p>
<p>The callback should:</p><ul>
<li>Check if outgoing_msg_info.valid is true</li>
<li>Call send_openlcb_msg if message is pending</li>
<li>Clear valid flag if transmission succeeds</li>
<li>Keep valid flag set if transmission fails (retry on next iteration)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL (set to module function) </dd></dl>

</div>
</div>
<a id="a87d0bb10ab97a4dfb5cc19819656c7db" name="a87d0bb10ab97a4dfb5cc19819656c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d0bb10ab97a4dfb5cc19819656c7db">&#9670;&#160;</a></span>handle_try_reenumerate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handle_try_reenumerate) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function pointer for re-enumeration handling. </p>
<p>This callback handles the re-enumeration mechanism for multi-message sequences. When message handlers set the enumerate flag, this callback re-invokes the handler to generate the next message in the sequence. It is exposed through the interface to enable unit testing.</p>
<p>Typical implementation: OpenLcbLoginStatemachine_handle_try_reenumerate</p>
<p>The callback should:</p><ul>
<li>Check if outgoing_msg_info.enumerate is true</li>
<li>Call process_login_statemachine if enumerate flag is set</li>
<li>Return true if re-enumeration occurred</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL (set to module function) </dd></dl>

</div>
</div>
<a id="ace54b5c03eafd093615c3de2f76587b1" name="ace54b5c03eafd093615c3de2f76587b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace54b5c03eafd093615c3de2f76587b1">&#9670;&#160;</a></span>handle_try_enumerate_first_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handle_try_enumerate_first_node) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function pointer for first node enumeration. </p>
<p>This callback attempts to get and process the first node in the node pool. If no current node is being processed, it calls openlcb_node_get_first and dispatches the node if it requires login processing. It is exposed through the interface to enable unit testing.</p>
<p>Typical implementation: OpenLcbLoginStatemachine_handle_try_enumerate_first_node</p>
<p>The callback should:</p><ul>
<li>Check if openlcb_node is NULL (no current node)</li>
<li>Call openlcb_node_get_first if needed</li>
<li>Skip nodes already in RUNSTATE_RUN</li>
<li>Call process_login_statemachine for nodes needing initialization</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL (set to module function) </dd></dl>

</div>
</div>
<a id="a41dbaa73eb2229932ffc76416db879e7" name="a41dbaa73eb2229932ffc76416db879e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dbaa73eb2229932ffc76416db879e7">&#9670;&#160;</a></span>handle_try_enumerate_next_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handle_try_enumerate_next_node) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function pointer for next node enumeration. </p>
<p>This callback attempts to get and process the next node in the node pool. If a current node exists, it calls openlcb_node_get_next and dispatches the node if it requires login processing. It is exposed through the interface to enable unit testing.</p>
<p>Typical implementation: OpenLcbLoginStatemachine_handle_try_enumerate_next_node</p>
<p>The callback should:</p><ul>
<li>Check if openlcb_node is not NULL (current node exists)</li>
<li>Call openlcb_node_get_next to advance enumeration</li>
<li>Skip nodes already in RUNSTATE_RUN</li>
<li>Call process_login_statemachine for nodes needing initialization</li>
<li>Clear openlcb_node to NULL when end of list reached</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This is a REQUIRED callback - must not be NULL (set to module function) </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/openlcb/<a class="el" href="openlcb__login__statemachine_8h_source.html">openlcb_login_statemachine.h</a></li>
</ul>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
