<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/openlcb_buffer_store.c File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">openlcb_buffer_store.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of the core buffer store for OpenLCB message allocation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa929fa9f3796aa554fb29771116b864" id="r_aaa929fa9f3796aa554fb29771116b864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa929fa9f3796aa554fb29771116b864">OpenLcbBufferStore_initialize</a> (void)</td></tr>
<tr class="memdesc:aaa929fa9f3796aa554fb29771116b864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the OpenLcb Buffer Store.  <br /></td></tr>
<tr class="separator:aaa929fa9f3796aa554fb29771116b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56857b0d3eaed4ee651e9ac794cad201" id="r_a56857b0d3eaed4ee651e9ac794cad201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56857b0d3eaed4ee651e9ac794cad201">OpenLcbBufferStore_allocate_buffer</a> (<a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a> payload_type)</td></tr>
<tr class="memdesc:a56857b0d3eaed4ee651e9ac794cad201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new buffer of the specified payload type.  <br /></td></tr>
<tr class="separator:a56857b0d3eaed4ee651e9ac794cad201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678e335cc01529581d2b7e69ae0ad023" id="r_a678e335cc01529581d2b7e69ae0ad023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678e335cc01529581d2b7e69ae0ad023">OpenLcbBufferStore_free_buffer</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a678e335cc01529581d2b7e69ae0ad023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements reference count and potentially frees the buffer for reuse.  <br /></td></tr>
<tr class="separator:a678e335cc01529581d2b7e69ae0ad023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a5aa017d1dc54ceda7f0fa7c47d709" id="r_ad8a5aa017d1dc54ceda7f0fa7c47d709"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a5aa017d1dc54ceda7f0fa7c47d709">OpenLcbBufferStore_basic_messages_allocated</a> (void)</td></tr>
<tr class="memdesc:ad8a5aa017d1dc54ceda7f0fa7c47d709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of BASIC messages currently allocated.  <br /></td></tr>
<tr class="separator:ad8a5aa017d1dc54ceda7f0fa7c47d709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3a667dbdbbf14793cadeb40b545331" id="r_a4f3a667dbdbbf14793cadeb40b545331"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f3a667dbdbbf14793cadeb40b545331">OpenLcbBufferStore_basic_messages_max_allocated</a> (void)</td></tr>
<tr class="memdesc:a4f3a667dbdbbf14793cadeb40b545331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of BASIC messages allocated simultaneously.  <br /></td></tr>
<tr class="separator:a4f3a667dbdbbf14793cadeb40b545331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775b6eb9b94b465a263a76b969cad4d3" id="r_a775b6eb9b94b465a263a76b969cad4d3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a775b6eb9b94b465a263a76b969cad4d3">OpenLcbBufferStore_datagram_messages_allocated</a> (void)</td></tr>
<tr class="memdesc:a775b6eb9b94b465a263a76b969cad4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of DATAGRAM messages currently allocated.  <br /></td></tr>
<tr class="separator:a775b6eb9b94b465a263a76b969cad4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047102a7e56925413814ead6e493723" id="r_aa047102a7e56925413814ead6e493723"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa047102a7e56925413814ead6e493723">OpenLcbBufferStore_datagram_messages_max_allocated</a> (void)</td></tr>
<tr class="memdesc:aa047102a7e56925413814ead6e493723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of DATAGRAM messages allocated simultaneously.  <br /></td></tr>
<tr class="separator:aa047102a7e56925413814ead6e493723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17b0f879f93af66cd832a2f6c4c801" id="r_a5e17b0f879f93af66cd832a2f6c4c801"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e17b0f879f93af66cd832a2f6c4c801">OpenLcbBufferStore_snip_messages_allocated</a> (void)</td></tr>
<tr class="memdesc:a5e17b0f879f93af66cd832a2f6c4c801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of SNIP messages currently allocated.  <br /></td></tr>
<tr class="separator:a5e17b0f879f93af66cd832a2f6c4c801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300bfb3d8db0268f6aa3024c87d464c" id="r_a1300bfb3d8db0268f6aa3024c87d464c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1300bfb3d8db0268f6aa3024c87d464c">OpenLcbBufferStore_snip_messages_max_allocated</a> (void)</td></tr>
<tr class="memdesc:a1300bfb3d8db0268f6aa3024c87d464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of SNIP messages allocated simultaneously.  <br /></td></tr>
<tr class="separator:a1300bfb3d8db0268f6aa3024c87d464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8263b6b25707d7cbd8040128d14800c0" id="r_a8263b6b25707d7cbd8040128d14800c0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8263b6b25707d7cbd8040128d14800c0">OpenLcbBufferStore_stream_messages_allocated</a> (void)</td></tr>
<tr class="memdesc:a8263b6b25707d7cbd8040128d14800c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of STREAM message buffers currently allocated.  <br /></td></tr>
<tr class="separator:a8263b6b25707d7cbd8040128d14800c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca556cbdeaa4f86800156e103c872fa" id="r_a3ca556cbdeaa4f86800156e103c872fa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ca556cbdeaa4f86800156e103c872fa">OpenLcbBufferStore_stream_messages_max_allocated</a> (void)</td></tr>
<tr class="memdesc:a3ca556cbdeaa4f86800156e103c872fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of STREAM messages allocated simultaneously.  <br /></td></tr>
<tr class="separator:a3ca556cbdeaa4f86800156e103c872fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d2ba67201acfcfa2a5c67b406161e6" id="r_a36d2ba67201acfcfa2a5c67b406161e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36d2ba67201acfcfa2a5c67b406161e6">OpenLcbBufferStore_inc_reference_count</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *msg)</td></tr>
<tr class="memdesc:a36d2ba67201acfcfa2a5c67b406161e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference count on an allocated buffer.  <br /></td></tr>
<tr class="separator:a36d2ba67201acfcfa2a5c67b406161e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94eea5a323ffed37a490fdf71ea9d55" id="r_ad94eea5a323ffed37a490fdf71ea9d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94eea5a323ffed37a490fdf71ea9d55">OpenLcbBufferStore_clear_max_allocated</a> (void)</td></tr>
<tr class="memdesc:ad94eea5a323ffed37a490fdf71ea9d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all peak allocation counters to zero.  <br /></td></tr>
<tr class="separator:ad94eea5a323ffed37a490fdf71ea9d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the core buffer store for OpenLCB message allocation. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>This module implements a pre-allocated memory pool for OpenLCB messages with support for four different payload sizes. The implementation uses segregated buffer pools to avoid fragmentation and ensure predictable allocation behavior.</p>
<p>Memory layout:</p><ul>
<li>Single static <a class="el" href="structmessage__buffer__t.html" title="Complete message buffer storage.">message_buffer_t</a> structure containing all pools</li>
<li>Messages array with pointers to payload buffers</li>
<li>Four separate payload arrays (basic, datagram, snip, stream)</li>
</ul>
<p>Key algorithms:</p><ul>
<li>Linear search allocation within segregated pools</li>
<li>Reference counting for shared buffer management</li>
<li>Telemetry tracking for peak usage monitoring</li>
</ul>
<p>Thread safety:</p><ul>
<li>NOT thread-safe - designed for single-threaded use</li>
<li>Must be externally synchronized if used in multi-threaded environment</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aaa929fa9f3796aa554fb29771116b864" name="aaa929fa9f3796aa554fb29771116b864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa929fa9f3796aa554fb29771116b864">&#9670;&#160;</a></span>OpenLcbBufferStore_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbBufferStore_initialize </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the OpenLcb Buffer Store. </p>
<p>Algorithm: Sets up the pre-allocated message pool by iterating through all message slots and linking each to its appropriate payload buffer based on pool segmentation.</p><ol type="1">
<li>Iterate through all LEN_MESSAGE_BUFFER message slots</li>
<li>Call <a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message()</a> to zero each message structure</li>
<li>Determine payload type based on index ranges:<ul>
<li>[0 to BASIC_DEPTH-1] → BASIC type, link to basic[] array</li>
<li>[BASIC_DEPTH to BASIC+DATAGRAM-1] → DATAGRAM type, link to datagram[] array</li>
<li>[BASIC+DATAGRAM to BASIC+DATAGRAM+SNIP-1] → SNIP type, link to snip[] array</li>
<li>[Remaining] → STREAM type, link to stream[] array</li>
</ul>
</li>
<li>Set payload_type field in each message</li>
<li>Calculate appropriate payload array index and link payload pointer</li>
<li>Reset all allocation counters to zero</li>
<li>Reset all peak usage counters to zero</li>
</ol>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Required before any buffer allocation operations</li>
<li>Must be called before <a class="el" href="openlcb__buffer__fifo_8c.html#a8a001a3bc68d6587d8d9b11c694e937e" title="Initializes the OpenLcb Message Buffer FIFO.">OpenLcbBufferFifo_initialize()</a> and <a class="el" href="openlcb__buffer__list_8c.html#ad977454a2b373e1e67d269232e41db3b" title="Initializes the OpenLcb Message Buffer List.">OpenLcbBufferList_initialize()</a></li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>MUST be called exactly once during application initialization </dd>
<dd>
Calling multiple times will reset all allocation state </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Must be called during single-threaded initialization only </dd>
<dd>
Call before any buffer allocation operations</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message</a> - Clears individual message structures </dd>
<dd>
<a class="el" href="#a56857b0d3eaed4ee651e9ac794cad201" title="Allocates a new buffer of the specified payload type.">OpenLcbBufferStore_allocate_buffer</a> - Uses the initialized pool </dd></dl>

</div>
</div>
<a id="a56857b0d3eaed4ee651e9ac794cad201" name="a56857b0d3eaed4ee651e9ac794cad201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56857b0d3eaed4ee651e9ac794cad201">&#9670;&#160;</a></span>OpenLcbBufferStore_allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> * OpenLcbBufferStore_allocate_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="openlcb__types_8h.html#aececf1be5c268eb2c680b4a0cc778467">payload_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>payload_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new buffer of the specified payload type. </p>
<p>Algorithm: Searches the appropriate pool segment for an unallocated buffer and returns it.</p><ol type="1">
<li>Calculate offset_start and offset_end based on payload_type:<ul>
<li>BASIC: offset_start=0, offset_end=BASIC_DEPTH</li>
<li>DATAGRAM: offset_start=BASIC_DEPTH, offset_end=BASIC+DATAGRAM_DEPTH</li>
<li>SNIP: offset_start=BASIC+DATAGRAM, offset_end=BASIC+DATAGRAM+SNIP</li>
<li>STREAM: offset_start=BASIC+DATAGRAM+SNIP, offset_end=BASIC+DATAGRAM+SNIP+STREAM</li>
</ul>
</li>
<li>If invalid payload_type, return NULL immediately</li>
<li>Linear search from offset_start to offset_end</li>
<li>Check each message's state.allocated flag</li>
<li>On first unallocated buffer found:<ul>
<li>Call <a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message()</a> to zero the structure</li>
<li>Set reference_count = 1</li>
<li>Set state.allocated = true</li>
<li>Call _update_buffer_telemetry() to update counters</li>
<li>Return pointer to the buffer</li>
</ul>
</li>
<li>If no free buffer found in range, return NULL</li>
</ol>
<p>Use cases:</p><ul>
<li>Creating new outgoing OpenLCB messages</li>
<li>Assembling multi-frame received messages</li>
<li>Storing messages in FIFO or list structures</li>
</ul>
<pre class="fragment">* @param payload_type Type of buffer requested (BASIC, DATAGRAM, SNIP, or STREAM)
* </pre><dl class="section return"><dt>Returns</dt><dd>Pointer to allocated message buffer, or NULL if pool exhausted or invalid type</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns NULL when buffer pool exhausted - caller MUST check for NULL </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always check return value for NULL before dereferencing </dd>
<dd>
Buffer is automatically cleared before being returned</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Buffer starts with reference_count = 1 </dd>
<dd>
Allocation telemetry is updated on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer</a> - Decrements reference count and frees </dd>
<dd>
<a class="el" href="#a36d2ba67201acfcfa2a5c67b406161e6" title="Increments the reference count on an allocated buffer.">OpenLcbBufferStore_inc_reference_count</a> - Increments reference count for sharing </dd>
<dd>
_update_buffer_telemetry - Updates allocation statistics </dd></dl>

</div>
</div>
<a id="a678e335cc01529581d2b7e69ae0ad023" name="a678e335cc01529581d2b7e69ae0ad023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678e335cc01529581d2b7e69ae0ad023">&#9670;&#160;</a></span>OpenLcbBufferStore_free_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbBufferStore_free_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements reference count and potentially frees the buffer for reuse. </p>
<p>Algorithm: Implements reference-counted deallocation to support buffer sharing.</p><ol type="1">
<li>Check if msg pointer is NULL, return immediately if so</li>
<li>Decrement msg-&gt;reference_count</li>
<li>If reference_count &gt; 0, buffer is still referenced elsewhere, return without freeing</li>
<li>If reference_count == 0, proceed with deallocation:<ul>
<li>Switch on msg-&gt;payload_type</li>
<li>Decrement appropriate allocation counter</li>
<li>Set reference_count = 0 (redundant but explicit)</li>
<li>Set state.allocated = false to mark buffer as free</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Releasing a buffer after message transmission</li>
<li>Removing a buffer from FIFO or list</li>
<li>Cleaning up after message processing</li>
</ul>
<pre class="fragment">* @param msg Pointer to message buffer to be freed (NULL safe)
* </pre><dl class="section warning"><dt>Warning</dt><dd>Do NOT access buffer after calling free unless reference count was &gt; 1 </dd>
<dd>
Reference count underflow will cause undefined behavior </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Safe to call with NULL pointer (no-op) </dd>
<dd>
Buffer only freed when reference_count reaches exactly 0</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Telemetry counters updated when buffer actually freed </dd>
<dd>
Reference count must be managed correctly to prevent leaks</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a56857b0d3eaed4ee651e9ac794cad201" title="Allocates a new buffer of the specified payload type.">OpenLcbBufferStore_allocate_buffer</a> - Creates buffer with reference_count = 1 </dd>
<dd>
<a class="el" href="#a36d2ba67201acfcfa2a5c67b406161e6" title="Increments the reference count on an allocated buffer.">OpenLcbBufferStore_inc_reference_count</a> - Increments count when sharing </dd></dl>

</div>
</div>
<a id="ad8a5aa017d1dc54ceda7f0fa7c47d709" name="ad8a5aa017d1dc54ceda7f0fa7c47d709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a5aa017d1dc54ceda7f0fa7c47d709">&#9670;&#160;</a></span>OpenLcbBufferStore_basic_messages_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_basic_messages_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of BASIC messages currently allocated. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_basic_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Runtime monitoring of buffer usage</li>
<li>Detecting buffer leaks</li>
<li>Load analysis</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Number of BASIC sized messages currently allocated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a live count that changes as buffers are allocated and freed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f3a667dbdbbf14793cadeb40b545331" title="Returns the maximum number of BASIC messages allocated simultaneously.">OpenLcbBufferStore_basic_messages_max_allocated</a> - Peak usage </dd></dl>

</div>
</div>
<a id="a4f3a667dbdbbf14793cadeb40b545331" name="a4f3a667dbdbbf14793cadeb40b545331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3a667dbdbbf14793cadeb40b545331">&#9670;&#160;</a></span>OpenLcbBufferStore_basic_messages_max_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_basic_messages_max_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of BASIC messages allocated simultaneously. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_basic_max_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Stress testing to determine minimum buffer pool size</li>
<li>Capacity planning</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of BASIC sized messages that have been allocated simultaneously</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Counter only increases, never decreases (until cleared)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad94eea5a323ffed37a490fdf71ea9d55" title="Resets all peak allocation counters to zero.">OpenLcbBufferStore_clear_max_allocated</a> - Resets this counter </dd></dl>

</div>
</div>
<a id="a775b6eb9b94b465a263a76b969cad4d3" name="a775b6eb9b94b465a263a76b969cad4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775b6eb9b94b465a263a76b969cad4d3">&#9670;&#160;</a></span>OpenLcbBufferStore_datagram_messages_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_datagram_messages_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of DATAGRAM messages currently allocated. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_datagram_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Monitoring datagram protocol activity</li>
<li>Detecting datagram buffer leaks</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Number of DATAGRAM sized messages currently allocated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa047102a7e56925413814ead6e493723" title="Returns the maximum number of DATAGRAM messages allocated simultaneously.">OpenLcbBufferStore_datagram_messages_max_allocated</a> - Peak usage </dd></dl>

</div>
</div>
<a id="aa047102a7e56925413814ead6e493723" name="aa047102a7e56925413814ead6e493723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa047102a7e56925413814ead6e493723">&#9670;&#160;</a></span>OpenLcbBufferStore_datagram_messages_max_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_datagram_messages_max_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of DATAGRAM messages allocated simultaneously. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_datagram_max_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Sizing datagram pool for configuration memory operations</li>
<li>Stress testing</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of DATAGRAM sized messages that have been allocated simultaneously</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad94eea5a323ffed37a490fdf71ea9d55" title="Resets all peak allocation counters to zero.">OpenLcbBufferStore_clear_max_allocated</a> - Resets counter </dd></dl>

</div>
</div>
<a id="a5e17b0f879f93af66cd832a2f6c4c801" name="a5e17b0f879f93af66cd832a2f6c4c801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e17b0f879f93af66cd832a2f6c4c801">&#9670;&#160;</a></span>OpenLcbBufferStore_snip_messages_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_snip_messages_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of SNIP messages currently allocated. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_snip_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Monitoring SNIP protocol activity</li>
<li>Detecting SNIP buffer leaks</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Number of SNIP sized messages currently allocated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1300bfb3d8db0268f6aa3024c87d464c" title="Returns the maximum number of SNIP messages allocated simultaneously.">OpenLcbBufferStore_snip_messages_max_allocated</a> - Peak usage </dd></dl>

</div>
</div>
<a id="a1300bfb3d8db0268f6aa3024c87d464c" name="a1300bfb3d8db0268f6aa3024c87d464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1300bfb3d8db0268f6aa3024c87d464c">&#9670;&#160;</a></span>OpenLcbBufferStore_snip_messages_max_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_snip_messages_max_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of SNIP messages allocated simultaneously. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_snip_max_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Sizing SNIP pool for network enumeration</li>
<li>Testing with multiple node discovery operations</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of SNIP sized messages that have been allocated simultaneously</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad94eea5a323ffed37a490fdf71ea9d55" title="Resets all peak allocation counters to zero.">OpenLcbBufferStore_clear_max_allocated</a> - Resets counter </dd></dl>

</div>
</div>
<a id="a8263b6b25707d7cbd8040128d14800c0" name="a8263b6b25707d7cbd8040128d14800c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8263b6b25707d7cbd8040128d14800c0">&#9670;&#160;</a></span>OpenLcbBufferStore_stream_messages_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_stream_messages_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of STREAM message buffers currently allocated. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_stream_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Monitoring stream protocol activity</li>
<li>Detecting stream buffer leaks</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Number of STREAM sized messages currently allocated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3ca556cbdeaa4f86800156e103c872fa" title="Returns the maximum number of STREAM messages allocated simultaneously.">OpenLcbBufferStore_stream_messages_max_allocated</a> - Peak usage </dd></dl>

</div>
</div>
<a id="a3ca556cbdeaa4f86800156e103c872fa" name="a3ca556cbdeaa4f86800156e103c872fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca556cbdeaa4f86800156e103c872fa">&#9670;&#160;</a></span>OpenLcbBufferStore_stream_messages_max_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OpenLcbBufferStore_stream_messages_max_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of STREAM messages allocated simultaneously. </p>
<p>Algorithm:</p><ol type="1">
<li>Return the value of _buffer_store_stream_max_messages_allocated</li>
</ol>
<p>Use cases:</p><ul>
<li>Sizing stream pool for firmware update operations</li>
<li>Testing large data transfer scenarios</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of STREAM sized messages that have been allocated simultaneously</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad94eea5a323ffed37a490fdf71ea9d55" title="Resets all peak allocation counters to zero.">OpenLcbBufferStore_clear_max_allocated</a> - Resets counter </dd></dl>

</div>
</div>
<a id="a36d2ba67201acfcfa2a5c67b406161e6" name="a36d2ba67201acfcfa2a5c67b406161e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d2ba67201acfcfa2a5c67b406161e6">&#9670;&#160;</a></span>OpenLcbBufferStore_inc_reference_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbBufferStore_inc_reference_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the reference count on an allocated buffer. </p>
<p>Algorithm:</p><ol type="1">
<li>Add 1 to msg-&gt;reference_count</li>
</ol>
<p>Use cases:</p><ul>
<li>Sharing a buffer between transmit and retry queues</li>
<li>Holding a buffer in multiple lists simultaneously</li>
<li>Passing a buffer to callback while keeping local reference</li>
</ul>
<pre class="fragment">* @param msg Pointer to message buffer to increment reference count (must NOT be NULL)
* </pre><dl class="section warning"><dt>Warning</dt><dd>Passing NULL will crash - no NULL check performed </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always pair with corresponding free_buffer() call </dd>
<dd>
Reference count overflow is not checked</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer</a> - Decrements reference count </dd></dl>

</div>
</div>
<a id="ad94eea5a323ffed37a490fdf71ea9d55" name="ad94eea5a323ffed37a490fdf71ea9d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94eea5a323ffed37a490fdf71ea9d55">&#9670;&#160;</a></span>OpenLcbBufferStore_clear_max_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbBufferStore_clear_max_allocated </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all peak allocation counters to zero. </p>
<p>Algorithm:</p><ol type="1">
<li>Set _buffer_store_basic_max_messages_allocated = 0</li>
<li>Set _buffer_store_datagram_max_messages_allocated = 0</li>
<li>Set _buffer_store_snip_max_messages_allocated = 0</li>
<li>Set _buffer_store_stream_max_messages_allocated = 0</li>
</ol>
<p>Use cases:</p><ul>
<li>Starting a new stress test run</li>
<li>Measuring peak usage for specific operational scenarios</li>
<li>Periodic monitoring with fresh baselines</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Does NOT affect current allocation counts </dd>
<dd>
Does not free any buffers</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Typically called at start of test scenario</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f3a667dbdbbf14793cadeb40b545331" title="Returns the maximum number of BASIC messages allocated simultaneously.">OpenLcbBufferStore_basic_messages_max_allocated</a> - Counter that gets cleared </dd>
<dd>
<a class="el" href="#aa047102a7e56925413814ead6e493723" title="Returns the maximum number of DATAGRAM messages allocated simultaneously.">OpenLcbBufferStore_datagram_messages_max_allocated</a> - Counter that gets cleared </dd>
<dd>
<a class="el" href="#a1300bfb3d8db0268f6aa3024c87d464c" title="Returns the maximum number of SNIP messages allocated simultaneously.">OpenLcbBufferStore_snip_messages_max_allocated</a> - Counter that gets cleared </dd>
<dd>
<a class="el" href="#a3ca556cbdeaa4f86800156e103c872fa" title="Returns the maximum number of STREAM messages allocated simultaneously.">OpenLcbBufferStore_stream_messages_max_allocated</a> - Counter that gets cleared </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
