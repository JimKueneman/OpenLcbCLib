<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/protocol_event_transport.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">protocol_event_transport.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Event transport protocol implementation.  
<a href="#details">More...</a></p>

<p><a href="protocol__event__transport_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html">interface_openlcb_protocol_event_transport_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface structure for Event Transport protocol callbacks.  <a href="structinterface__openlcb__protocol__event__transport__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13504f9f3de03215c9717b8dcaf363d8" id="r_a13504f9f3de03215c9717b8dcaf363d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13504f9f3de03215c9717b8dcaf363d8">ProtocolEventTransport_initialize</a> (const <a class="el" href="structinterface__openlcb__protocol__event__transport__t.html">interface_openlcb_protocol_event_transport_t</a> *interface_openlcb_protocol_event_transport)</td></tr>
<tr class="memdesc:a13504f9f3de03215c9717b8dcaf363d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Event Transport protocol layer.  <br /></td></tr>
<tr class="separator:a13504f9f3de03215c9717b8dcaf363d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1be0b7e2081a031609849ebc876d71" id="r_afb1be0b7e2081a031609849ebc876d71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1be0b7e2081a031609849ebc876d71">ProtocolEventTransport_handle_consumer_identify</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:afb1be0b7e2081a031609849ebc876d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Consumer Identify message.  <br /></td></tr>
<tr class="separator:afb1be0b7e2081a031609849ebc876d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c92a4094b3226a294930de68446ab3c" id="r_a9c92a4094b3226a294930de68446ab3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c92a4094b3226a294930de68446ab3c">ProtocolEventTransport_handle_consumer_range_identified</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a9c92a4094b3226a294930de68446ab3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Consumer Range Identified message.  <br /></td></tr>
<tr class="separator:a9c92a4094b3226a294930de68446ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007dbd80061d2cdb1b9963ba8da8ea09" id="r_a007dbd80061d2cdb1b9963ba8da8ea09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a007dbd80061d2cdb1b9963ba8da8ea09">ProtocolEventTransport_handle_consumer_identified_unknown</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a007dbd80061d2cdb1b9963ba8da8ea09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Consumer Identified Unknown message.  <br /></td></tr>
<tr class="separator:a007dbd80061d2cdb1b9963ba8da8ea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d355cd6d9b89e3e556d5ccb3595e0ab" id="r_a2d355cd6d9b89e3e556d5ccb3595e0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d355cd6d9b89e3e556d5ccb3595e0ab">ProtocolEventTransport_handle_consumer_identified_set</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a2d355cd6d9b89e3e556d5ccb3595e0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Consumer Identified Set message.  <br /></td></tr>
<tr class="separator:a2d355cd6d9b89e3e556d5ccb3595e0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c21e80d4ee1d344e00ed20f0b31c0fc" id="r_a1c21e80d4ee1d344e00ed20f0b31c0fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c21e80d4ee1d344e00ed20f0b31c0fc">ProtocolEventTransport_handle_consumer_identified_clear</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a1c21e80d4ee1d344e00ed20f0b31c0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Consumer Identified Clear message.  <br /></td></tr>
<tr class="separator:a1c21e80d4ee1d344e00ed20f0b31c0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db9e7259a0ab51f56f82f3fd46e3cc0" id="r_a4db9e7259a0ab51f56f82f3fd46e3cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db9e7259a0ab51f56f82f3fd46e3cc0">ProtocolEventTransport_handle_consumer_identified_reserved</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a4db9e7259a0ab51f56f82f3fd46e3cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Consumer Identified Reserved message.  <br /></td></tr>
<tr class="separator:a4db9e7259a0ab51f56f82f3fd46e3cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190aa050c233838afbf8b13cce8f04cf" id="r_a190aa050c233838afbf8b13cce8f04cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a190aa050c233838afbf8b13cce8f04cf">ProtocolEventTransport_handle_producer_identify</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a190aa050c233838afbf8b13cce8f04cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer Identify message.  <br /></td></tr>
<tr class="separator:a190aa050c233838afbf8b13cce8f04cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72129eda4bd4ad30e641004fe3484c9" id="r_ad72129eda4bd4ad30e641004fe3484c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad72129eda4bd4ad30e641004fe3484c9">ProtocolEventTransport_handle_producer_range_identified</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:ad72129eda4bd4ad30e641004fe3484c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer Range Identified message.  <br /></td></tr>
<tr class="separator:ad72129eda4bd4ad30e641004fe3484c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd4c8e176e511f24472dc6793f59dc7" id="r_aabd4c8e176e511f24472dc6793f59dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabd4c8e176e511f24472dc6793f59dc7">ProtocolEventTransport_handle_producer_identified_unknown</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:aabd4c8e176e511f24472dc6793f59dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer Identified Unknown message.  <br /></td></tr>
<tr class="separator:aabd4c8e176e511f24472dc6793f59dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e71394fcf36cc5d99b327cdd4001ac7" id="r_a1e71394fcf36cc5d99b327cdd4001ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e71394fcf36cc5d99b327cdd4001ac7">ProtocolEventTransport_handle_producer_identified_set</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a1e71394fcf36cc5d99b327cdd4001ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer Identified Set message.  <br /></td></tr>
<tr class="separator:a1e71394fcf36cc5d99b327cdd4001ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdff7c7109ea8a3aaf1573075aaebadd" id="r_afdff7c7109ea8a3aaf1573075aaebadd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdff7c7109ea8a3aaf1573075aaebadd">ProtocolEventTransport_handle_producer_identified_clear</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:afdff7c7109ea8a3aaf1573075aaebadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer Identified Clear message.  <br /></td></tr>
<tr class="separator:afdff7c7109ea8a3aaf1573075aaebadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b21811e9e91661c063489618c5250" id="r_a2f2b21811e9e91661c063489618c5250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f2b21811e9e91661c063489618c5250">ProtocolEventTransport_handle_producer_identified_reserved</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a2f2b21811e9e91661c063489618c5250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer Identified Reserved message.  <br /></td></tr>
<tr class="separator:a2f2b21811e9e91661c063489618c5250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a7d9aaf31f6c47e7d0b393258b4a61" id="r_a38a7d9aaf31f6c47e7d0b393258b4a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38a7d9aaf31f6c47e7d0b393258b4a61">ProtocolEventTransport_handle_events_identify_dest</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a38a7d9aaf31f6c47e7d0b393258b4a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles addressed Identify Events message.  <br /></td></tr>
<tr class="separator:a38a7d9aaf31f6c47e7d0b393258b4a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fd18aec6a8fca64435b14d94c0752b" id="r_ab1fd18aec6a8fca64435b14d94c0752b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1fd18aec6a8fca64435b14d94c0752b">ProtocolEventTransport_handle_events_identify</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:ab1fd18aec6a8fca64435b14d94c0752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles global Identify Events message.  <br /></td></tr>
<tr class="separator:ab1fd18aec6a8fca64435b14d94c0752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342736e386595db173e0aab6d14edf72" id="r_a342736e386595db173e0aab6d14edf72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a342736e386595db173e0aab6d14edf72">ProtocolEventTransport_handle_event_learn</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a342736e386595db173e0aab6d14edf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Event Learn message.  <br /></td></tr>
<tr class="separator:a342736e386595db173e0aab6d14edf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0871e8dff19e3b845da96bcc208af0ac" id="r_a0871e8dff19e3b845da96bcc208af0ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0871e8dff19e3b845da96bcc208af0ac">ProtocolEventTransport_handle_pc_event_report</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a0871e8dff19e3b845da96bcc208af0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer/Consumer Event Report message.  <br /></td></tr>
<tr class="separator:a0871e8dff19e3b845da96bcc208af0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766f9f46309f4aea60e279d233dfef4d" id="r_a766f9f46309f4aea60e279d233dfef4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a766f9f46309f4aea60e279d233dfef4d">ProtocolEventTransport_handle_pc_event_report_with_payload</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a766f9f46309f4aea60e279d233dfef4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles Producer/Consumer Event Report message with payload.  <br /></td></tr>
<tr class="separator:a766f9f46309f4aea60e279d233dfef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a16c27e84c729162ce66cc0ec4f4dd" id="r_af6a16c27e84c729162ce66cc0ec4f4dd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6a16c27e84c729162ce66cc0ec4f4dd">ProtocolEventTransport_extract_consumer_event_status_mti</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, uint16_t event_index)</td></tr>
<tr class="memdesc:af6a16c27e84c729162ce66cc0ec4f4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the appropriate MTI for consumer event status.  <br /></td></tr>
<tr class="separator:af6a16c27e84c729162ce66cc0ec4f4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42953b23ecc6b49992a048e53abf9c9a" id="r_a42953b23ecc6b49992a048e53abf9c9a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42953b23ecc6b49992a048e53abf9c9a">ProtocolEventTransport_extract_producer_event_status_mti</a> (<a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *openlcb_node, uint16_t event_index)</td></tr>
<tr class="memdesc:a42953b23ecc6b49992a048e53abf9c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the appropriate MTI for producer event status.  <br /></td></tr>
<tr class="separator:a42953b23ecc6b49992a048e53abf9c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Event transport protocol implementation. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a13504f9f3de03215c9717b8dcaf363d8" name="a13504f9f3de03215c9717b8dcaf363d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13504f9f3de03215c9717b8dcaf363d8">&#9670;&#160;</a></span>ProtocolEventTransport_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__openlcb__protocol__event__transport__t.html">interface_openlcb_protocol_event_transport_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_openlcb_protocol_event_transport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the Event Transport protocol layer. </p>
<p>Registers the application's callback interface with the Event Transport protocol handler. Must be called once during system initialization before any event-related messages are processed.</p>
<p>Use cases:</p><ul>
<li>Called during application startup</li>
<li>Required before processing any event messages</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_openlcb_protocol_event_transport</td><td>Pointer to callback interface structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>interface_openlcb_protocol_event_transport must remain valid for lifetime of application </dd>
<dd>
NOT thread-safe - call during single-threaded initialization only</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call before enabling CAN message reception</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback interface structure</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Store pointer to callback interface in static variable</li>
<li>Interface remains valid for application lifetime</li>
</ol>
<p>Use cases:</p><ul>
<li>Called during application startup</li>
<li>Required before processing any event messages</li>
</ul>
<pre class="fragment">* @param interface_openlcb_protocol_event_transport Pointer to callback interface structure
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must remain valid for lifetime of application </dd>
<dd>
NOT thread-safe - call during single-threaded initialization only</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call before enabling CAN message reception</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback interface structure </dd></dl>

</div>
</div>
<a id="afb1be0b7e2081a031609849ebc876d71" name="afb1be0b7e2081a031609849ebc876d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1be0b7e2081a031609849ebc876d71">&#9670;&#160;</a></span>ProtocolEventTransport_handle_consumer_identify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_consumer_identify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Consumer Identify message. </p>
<p>Processes a request to identify if this node consumes a specific event. Checks if the requested event is in the node's consumer list and responds with the current state (unknown/set/clear).</p>
<p>Use cases:</p><ul>
<li>Remote node querying if this node consumes an event</li>
<li>Configuration tools discovering event consumers</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL </dd>
<dd>
Incoming message must have valid event ID payload</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If event not consumed by this node, no response is generated </dd>
<dd>
Response MTI depends on current event state (unknown/set/clear)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#af6a16c27e84c729162ce66cc0ec4f4dd" title="Extracts the appropriate MTI for consumer event status.">ProtocolEventTransport_extract_consumer_event_status_mti</a> - Determines response MTI</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Extract target event ID from incoming message payload</li>
<li>Search node's consumer list for matching event</li>
<li>If event not found:<ul>
<li>Mark outgoing message as invalid (no response)</li>
<li>Return early</li>
</ul>
</li>
<li>If event found:<ul>
<li>Construct Consumer Identified response message</li>
<li>Set MTI based on current consumer event state</li>
<li>Copy event ID to response payload</li>
<li>Mark outgoing message as valid</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Remote node querying if this node consumes an event</li>
<li>Configuration tools discovering event consumers</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL </dd>
<dd>
Incoming message must have valid event ID payload</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If event not consumed by this node, no response is generated </dd>
<dd>
Response MTI depends on current event state (unknown/set/clear) </dd>
<dd>
Payload count is set automatically by OpenLcbUtilities_copy_event_id_to_openlcb_payload</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#af6a16c27e84c729162ce66cc0ec4f4dd" title="Extracts the appropriate MTI for consumer event status.">ProtocolEventTransport_extract_consumer_event_status_mti</a> - Determines response MTI </dd></dl>

</div>
</div>
<a id="a9c92a4094b3226a294930de68446ab3c" name="a9c92a4094b3226a294930de68446ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c92a4094b3226a294930de68446ab3c">&#9670;&#160;</a></span>ProtocolEventTransport_handle_consumer_range_identified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_consumer_range_identified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Consumer Range Identified message. </p>
<p>Processes notification that a remote node has identified itself as consuming a range of events. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Discovering event consumers on the network</li>
<li>Building event routing tables</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback receives the base event ID of the range</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Discovering event consumers on the network</li>
<li>Building event routing tables</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback receives the base event ID of the range</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a007dbd80061d2cdb1b9963ba8da8ea09" name="a007dbd80061d2cdb1b9963ba8da8ea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007dbd80061d2cdb1b9963ba8da8ea09">&#9670;&#160;</a></span>ProtocolEventTransport_handle_consumer_identified_unknown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_consumer_identified_unknown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Consumer Identified Unknown message. </p>
<p>Processes notification that a remote node consumes an event but its current state is unknown. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Tracking consumer states on the network</li>
<li>Updating event state displays</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Tracking consumer states on the network</li>
<li>Updating event state displays</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a2d355cd6d9b89e3e556d5ccb3595e0ab" name="a2d355cd6d9b89e3e556d5ccb3595e0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d355cd6d9b89e3e556d5ccb3595e0ab">&#9670;&#160;</a></span>ProtocolEventTransport_handle_consumer_identified_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_consumer_identified_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Consumer Identified Set message. </p>
<p>Processes notification that a remote node consumes an event and its current state is SET (active/true). Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Tracking consumer states on the network</li>
<li>Updating event state displays</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Tracking consumer states on the network</li>
<li>Synchronizing event states across nodes</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a1c21e80d4ee1d344e00ed20f0b31c0fc" name="a1c21e80d4ee1d344e00ed20f0b31c0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c21e80d4ee1d344e00ed20f0b31c0fc">&#9670;&#160;</a></span>ProtocolEventTransport_handle_consumer_identified_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_consumer_identified_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Consumer Identified Clear message. </p>
<p>Processes notification that a remote node consumes an event and its current state is CLEAR (inactive/false). Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Tracking consumer states on the network</li>
<li>Updating event state displays</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Tracking consumer states on the network</li>
<li>Synchronizing event states across nodes</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a4db9e7259a0ab51f56f82f3fd46e3cc0" name="a4db9e7259a0ab51f56f82f3fd46e3cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db9e7259a0ab51f56f82f3fd46e3cc0">&#9670;&#160;</a></span>ProtocolEventTransport_handle_consumer_identified_reserved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_consumer_identified_reserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Consumer Identified Reserved message. </p>
<p>Processes notification that a remote node consumes an event with a reserved state indicator. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Supporting future protocol extensions</li>
<li>Handling special event types</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Handling future protocol extensions</li>
<li>Logging unusual event states</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Reserved states are defined by future OpenLCB specifications</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a190aa050c233838afbf8b13cce8f04cf" name="a190aa050c233838afbf8b13cce8f04cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190aa050c233838afbf8b13cce8f04cf">&#9670;&#160;</a></span>ProtocolEventTransport_handle_producer_identify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_producer_identify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer Identify message. </p>
<p>Processes a request to identify if this node produces a specific event. Checks if the requested event is in the node's producer list and responds with the current state (unknown/set/clear).</p>
<p>Use cases:</p><ul>
<li>Remote node querying if this node produces an event</li>
<li>Configuration tools discovering event producers</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL </dd>
<dd>
Incoming message must have valid event ID payload</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If event not produced by this node, no response is generated </dd>
<dd>
Response MTI depends on current event state (unknown/set/clear)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a42953b23ecc6b49992a048e53abf9c9a" title="Extracts the appropriate MTI for producer event status.">ProtocolEventTransport_extract_producer_event_status_mti</a> - Determines response MTI</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Extract target event ID from incoming message payload</li>
<li>Search node's producer list for matching event</li>
<li>If event not found:<ul>
<li>Mark outgoing message as invalid (no response)</li>
<li>Return early</li>
</ul>
</li>
<li>If event found:<ul>
<li>Construct Producer Identified response message</li>
<li>Set MTI based on current producer event state</li>
<li>Copy event ID to response payload</li>
<li>Mark outgoing message as valid</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Remote node querying if this node produces an event</li>
<li>Configuration tools discovering event producers</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL </dd>
<dd>
Incoming message must have valid event ID payload</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If event not produced by this node, no response is generated </dd>
<dd>
Response MTI depends on current event state (unknown/set/clear) </dd>
<dd>
Payload count is set automatically by OpenLcbUtilities_copy_event_id_to_openlcb_payload</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a42953b23ecc6b49992a048e53abf9c9a" title="Extracts the appropriate MTI for producer event status.">ProtocolEventTransport_extract_producer_event_status_mti</a> - Determines response MTI </dd></dl>

</div>
</div>
<a id="ad72129eda4bd4ad30e641004fe3484c9" name="ad72129eda4bd4ad30e641004fe3484c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72129eda4bd4ad30e641004fe3484c9">&#9670;&#160;</a></span>ProtocolEventTransport_handle_producer_range_identified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_producer_range_identified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer Range Identified message. </p>
<p>Processes notification that a remote node has identified itself as producing a range of events. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Discovering event producers on the network</li>
<li>Building event routing tables</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback receives the base event ID of the range</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Discovering event producers on the network</li>
<li>Building event routing tables</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback receives the base event ID of the range</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="aabd4c8e176e511f24472dc6793f59dc7" name="aabd4c8e176e511f24472dc6793f59dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd4c8e176e511f24472dc6793f59dc7">&#9670;&#160;</a></span>ProtocolEventTransport_handle_producer_identified_unknown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_producer_identified_unknown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer Identified Unknown message. </p>
<p>Processes notification that a remote node produces an event but its current state is unknown. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Tracking producer states on the network</li>
<li>Updating event state displays</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Tracking producer states on the network</li>
<li>Updating event state displays</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a1e71394fcf36cc5d99b327cdd4001ac7" name="a1e71394fcf36cc5d99b327cdd4001ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e71394fcf36cc5d99b327cdd4001ac7">&#9670;&#160;</a></span>ProtocolEventTransport_handle_producer_identified_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_producer_identified_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer Identified Set message. </p>
<p>Processes notification that a remote node produces an event and its current state is SET (active/true). Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Tracking producer states on the network</li>
<li>Updating event state displays</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Tracking producer states on the network</li>
<li>Synchronizing event states across nodes</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="afdff7c7109ea8a3aaf1573075aaebadd" name="afdff7c7109ea8a3aaf1573075aaebadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdff7c7109ea8a3aaf1573075aaebadd">&#9670;&#160;</a></span>ProtocolEventTransport_handle_producer_identified_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_producer_identified_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer Identified Clear message. </p>
<p>Processes notification that a remote node produces an event and its current state is CLEAR (inactive/false). Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Tracking producer states on the network</li>
<li>Updating event state displays</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Tracking producer states on the network</li>
<li>Synchronizing event states across nodes</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a2f2b21811e9e91661c063489618c5250" name="a2f2b21811e9e91661c063489618c5250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2b21811e9e91661c063489618c5250">&#9670;&#160;</a></span>ProtocolEventTransport_handle_producer_identified_reserved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_producer_identified_reserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer Identified Reserved message. </p>
<p>Processes notification that a remote node produces an event with a reserved state indicator. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Supporting future protocol extensions</li>
<li>Handling special event types</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Handling future protocol extensions</li>
<li>Logging unusual event states</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Reserved states are defined by future OpenLCB specifications</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a38a7d9aaf31f6c47e7d0b393258b4a61" name="a38a7d9aaf31f6c47e7d0b393258b4a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a7d9aaf31f6c47e7d0b393258b4a61">&#9670;&#160;</a></span>ProtocolEventTransport_handle_events_identify_dest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_events_identify_dest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles addressed Identify Events message. </p>
<p>Processes an addressed request to identify all events this node produces and consumes. Verifies the message is addressed to this node before delegating to the actual event identification logic.</p>
<p>Use cases:</p><ul>
<li>Targeted event discovery for a specific node</li>
<li>Configuration tools querying this node's events</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Checks message destination before processing </dd>
<dd>
If not addressed to this node, no response is generated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab1fd18aec6a8fca64435b14d94c0752b" title="Handles global Identify Events message.">ProtocolEventTransport_handle_events_identify</a> - Actual event identification logic</dd></dl>
<p>Handles addressed Identify Events message.</p>
<p>Algorithm:</p><ol type="1">
<li>Check if incoming message is addressed to this node</li>
<li>If addressed to this node:<ul>
<li>Call <a class="el" href="#ab1fd18aec6a8fca64435b14d94c0752b" title="Handles global Identify Events message.">ProtocolEventTransport_handle_events_identify()</a> for processing</li>
<li>Return to caller</li>
</ul>
</li>
<li>If not addressed to this node:<ul>
<li>Mark outgoing message as invalid (no response)</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Configuration tools requesting complete event list from specific node</li>
<li>Targeted event discovery without network-wide broadcast</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Checks message destination before processing </dd>
<dd>
If not addressed to this node, no response is generated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab1fd18aec6a8fca64435b14d94c0752b" title="Handles global Identify Events message.">ProtocolEventTransport_handle_events_identify</a> - Actual event identification logic </dd></dl>

</div>
</div>
<a id="ab1fd18aec6a8fca64435b14d94c0752b" name="ab1fd18aec6a8fca64435b14d94c0752b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fd18aec6a8fca64435b14d94c0752b">&#9670;&#160;</a></span>ProtocolEventTransport_handle_events_identify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_events_identify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles global Identify Events message. </p>
<p>Processes a global request to identify all events this node produces and consumes. Responds with Producer/Consumer Identified messages for each event in the node's event lists.</p>
<p>Use cases:</p><ul>
<li>Network-wide event discovery</li>
<li>Configuration tools building complete event maps</li>
<li>Node initialization and announcement</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enumerates all producer events first, then all consumer events </dd>
<dd>
Uses enumeration state machine to handle multiple responses </dd>
<dd>
Responses are generated incrementally across multiple calls</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a42953b23ecc6b49992a048e53abf9c9a" title="Extracts the appropriate MTI for producer event status.">ProtocolEventTransport_extract_producer_event_status_mti</a> - Get producer response MTI </dd>
<dd>
<a class="el" href="protocol__event__transport_8c.html#af6a16c27e84c729162ce66cc0ec4f4dd" title="Extracts the appropriate MTI for consumer event status.">ProtocolEventTransport_extract_consumer_event_status_mti</a> - Get consumer response MTI</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if more producer events need enumeration (enum_index &lt; count):<ul>
<li>If yes: Call _identify_producers() to handle next producer event</li>
<li>Return to caller for transmission</li>
</ul>
</li>
<li>If all producers enumerated:<ul>
<li>Mark producer enumeration as complete</li>
</ul>
</li>
<li>Check if more consumer events need enumeration (enum_index &lt; count):<ul>
<li>If yes: Call _identify_consumers() to handle next consumer event</li>
<li>Return to caller for transmission</li>
</ul>
</li>
<li>If all consumers enumerated:<ul>
<li>Reset both enumeration indices to 0</li>
<li>Mark consumer enumeration as complete</li>
<li>Clear enumeration flag</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Network-wide event discovery</li>
<li>Configuration tools building complete event maps</li>
<li>Node initialization and announcement</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enumerates all producer events first, then all consumer events </dd>
<dd>
Uses enumeration state machine to handle multiple responses </dd>
<dd>
Responses are generated incrementally across multiple calls </dd>
<dd>
Caller must continue calling until enumerate flag becomes false</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a42953b23ecc6b49992a048e53abf9c9a" title="Extracts the appropriate MTI for producer event status.">ProtocolEventTransport_extract_producer_event_status_mti</a> - Get producer response MTI </dd>
<dd>
<a class="el" href="protocol__event__transport_8c.html#af6a16c27e84c729162ce66cc0ec4f4dd" title="Extracts the appropriate MTI for consumer event status.">ProtocolEventTransport_extract_consumer_event_status_mti</a> - Get consumer response MTI </dd></dl>

</div>
</div>
<a id="a342736e386595db173e0aab6d14edf72" name="a342736e386595db173e0aab6d14edf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342736e386595db173e0aab6d14edf72">&#9670;&#160;</a></span>ProtocolEventTransport_handle_event_learn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_event_learn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Event Learn message. </p>
<p>Processes a teach/learn message for event configuration. The node can use this to learn a new event ID from a producer or consumer. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Teaching this node a new event to produce or consume</li>
<li>Configuration mode for event learning</li>
<li>Dynamic event configuration</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback must implement actual event learning logic</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Teaching this node a new event to produce or consume</li>
<li>Configuration mode for event learning</li>
<li>Dynamic event configuration</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback must implement actual event learning logic</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a0871e8dff19e3b845da96bcc208af0ac" name="a0871e8dff19e3b845da96bcc208af0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0871e8dff19e3b845da96bcc208af0ac">&#9670;&#160;</a></span>ProtocolEventTransport_handle_pc_event_report()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_pc_event_report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer/Consumer Event Report message. </p>
<p>Processes an event report indicating that an event has occurred on the network. This is the fundamental event notification mechanism in OpenLCB. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Receiving event notifications from producers</li>
<li>Triggering consumer actions in response to events</li>
<li>Event logging and monitoring</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback is responsible for consuming the event and taking action</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a766f9f46309f4aea60e279d233dfef4d" title="Handles Producer/Consumer Event Report message with payload.">ProtocolEventTransport_handle_pc_event_report_with_payload</a> - Event report with additional data </dd>
<dd>
<a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from incoming message payload</li>
<li>Invoke callback with node context and event ID</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Receiving event notifications from producers</li>
<li>Triggering consumer actions in response to events</li>
<li>Event logging and monitoring</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback is responsible for consuming the event and taking action</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a766f9f46309f4aea60e279d233dfef4d" title="Handles Producer/Consumer Event Report message with payload.">ProtocolEventTransport_handle_pc_event_report_with_payload</a> - Event report with additional data </dd>
<dd>
<a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="a766f9f46309f4aea60e279d233dfef4d" name="a766f9f46309f4aea60e279d233dfef4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766f9f46309f4aea60e279d233dfef4d">&#9670;&#160;</a></span>ProtocolEventTransport_handle_pc_event_report_with_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolEventTransport_handle_pc_event_report_with_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles Producer/Consumer Event Report message with payload. </p>
<p>Processes an event report that includes additional payload data beyond the event ID. The payload can contain sensor readings, state information, or other data associated with the event. Invokes the registered callback if configured.</p>
<p>Use cases:</p><ul>
<li>Receiving event reports with sensor data</li>
<li>Events carrying configuration or state information</li>
<li>Extended event notifications with context</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must NOT be NULL </dd>
<dd>
Payload must be at least sizeof(event_id_t) + 1 bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback receives payload data pointer and byte count </dd>
<dd>
Payload count excludes the event ID (8 bytes)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a0871e8dff19e3b845da96bcc208af0ac" title="Handles Producer/Consumer Event Report message.">ProtocolEventTransport_handle_pc_event_report</a> - Event report without payload </dd>
<dd>
<a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Check if payload count is greater than event ID size (8 bytes)</li>
<li>If payload too small:<ul>
<li>Mark outgoing message as invalid (no response)</li>
<li>Return early (malformed message)</li>
</ul>
</li>
<li>Check if callback is registered (!= NULL)</li>
<li>If callback registered:<ul>
<li>Extract event ID from first 8 bytes of payload</li>
<li>Calculate payload data count (total - 8 bytes)</li>
<li>Get pointer to payload data (after event ID)</li>
<li>Invoke callback with node, event ID, count, and payload pointer</li>
</ul>
</li>
<li>Mark outgoing message as invalid (no automatic response)</li>
</ol>
<p>Use cases:</p><ul>
<li>Receiving event reports with sensor data</li>
<li>Events carrying configuration or state information</li>
<li>Extended event notifications with context</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL </dd>
<dd>
Payload must be at least sizeof(event_id_t) + 1 bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always sets outgoing_msg_info.valid to false (no automatic response) </dd>
<dd>
Callback receives payload data pointer and byte count </dd>
<dd>
Payload count excludes the event ID (8 bytes)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a0871e8dff19e3b845da96bcc208af0ac" title="Handles Producer/Consumer Event Report message.">ProtocolEventTransport_handle_pc_event_report</a> - Event report without payload </dd>
<dd>
<a class="el" href="structinterface__openlcb__protocol__event__transport__t.html" title="Interface structure for Event Transport protocol callbacks.">interface_openlcb_protocol_event_transport_t</a> - Callback registration </dd></dl>

</div>
</div>
<a id="af6a16c27e84c729162ce66cc0ec4f4dd" name="af6a16c27e84c729162ce66cc0ec4f4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a16c27e84c729162ce66cc0ec4f4dd">&#9670;&#160;</a></span>ProtocolEventTransport_extract_consumer_event_status_mti()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolEventTransport_extract_consumer_event_status_mti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>event_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the appropriate MTI for consumer event status. </p>
<p>Determines the correct Message Type Indicator (MTI) to use when responding to a consumer identification request, based on the current state of the consumer event (unknown/set/clear).</p>
<p>Use cases:</p><ul>
<li>Responding to consumer identify requests</li>
<li>Event enumeration responses</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing consumer event list </td></tr>
    <tr><td class="paramname">event_index</td><td>Index into the node's consumer event list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTI value corresponding to event state:<ul>
<li>MTI_CONSUMER_IDENTIFIED_UNKNOWN for unknown state</li>
<li>MTI_CONSUMER_IDENTIFIED_SET for set state</li>
<li>MTI_CONSUMER_IDENTIFIED_CLEAR for clear state</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_node must NOT be NULL </dd>
<dd>
event_index must be valid (&lt; consumer.count)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Caller must ensure event_index is within bounds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a42953b23ecc6b49992a048e53abf9c9a" title="Extracts the appropriate MTI for producer event status.">ProtocolEventTransport_extract_producer_event_status_mti</a> - Producer equivalent</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Access consumer event at specified index</li>
<li>Switch on event status field:<ul>
<li>EVENT_STATUS_SET  return MTI_CONSUMER_IDENTIFIED_SET</li>
<li>EVENT_STATUS_CLEAR  return MTI_CONSUMER_IDENTIFIED_CLEAR</li>
<li>Default/unknown  return MTI_CONSUMER_IDENTIFIED_UNKNOWN</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Responding to consumer identify requests</li>
<li>Event enumeration responses</li>
</ul>
<pre class="fragment">* @param openlcb_node Pointer to node containing consumer event list
* </pre> <pre class="fragment">* @param event_index Index into the node's consumer event list
* </pre><dl class="section return"><dt>Returns</dt><dd>MTI value corresponding to event state:<ul>
<li>MTI_CONSUMER_IDENTIFIED_UNKNOWN for unknown state</li>
<li>MTI_CONSUMER_IDENTIFIED_SET for set state</li>
<li>MTI_CONSUMER_IDENTIFIED_CLEAR for clear state</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL </dd>
<dd>
Index must be valid (&lt; consumer.count)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Caller must ensure event_index is within bounds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#a42953b23ecc6b49992a048e53abf9c9a" title="Extracts the appropriate MTI for producer event status.">ProtocolEventTransport_extract_producer_event_status_mti</a> - Producer equivalent </dd></dl>

</div>
</div>
<a id="a42953b23ecc6b49992a048e53abf9c9a" name="a42953b23ecc6b49992a048e53abf9c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42953b23ecc6b49992a048e53abf9c9a">&#9670;&#160;</a></span>ProtocolEventTransport_extract_producer_event_status_mti()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ProtocolEventTransport_extract_producer_event_status_mti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__node__t.html">openlcb_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>event_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the appropriate MTI for producer event status. </p>
<p>Determines the correct Message Type Indicator (MTI) to use when responding to a producer identification request, based on the current state of the producer event (unknown/set/clear).</p>
<p>Use cases:</p><ul>
<li>Responding to producer identify requests</li>
<li>Event enumeration responses</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_node</td><td>Pointer to node containing producer event list </td></tr>
    <tr><td class="paramname">event_index</td><td>Index into the node's producer event list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTI value corresponding to event state:<ul>
<li>MTI_PRODUCER_IDENTIFIED_UNKNOWN for unknown state</li>
<li>MTI_PRODUCER_IDENTIFIED_SET for set state</li>
<li>MTI_PRODUCER_IDENTIFIED_CLEAR for clear state</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_node must NOT be NULL </dd>
<dd>
event_index must be valid (&lt; producer.count)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Caller must ensure event_index is within bounds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#af6a16c27e84c729162ce66cc0ec4f4dd" title="Extracts the appropriate MTI for consumer event status.">ProtocolEventTransport_extract_consumer_event_status_mti</a> - Consumer equivalent</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Access producer event at specified index</li>
<li>Switch on event status field:<ul>
<li>EVENT_STATUS_SET  return MTI_PRODUCER_IDENTIFIED_SET</li>
<li>EVENT_STATUS_CLEAR  return MTI_PRODUCER_IDENTIFIED_CLEAR</li>
<li>Default/unknown  return MTI_PRODUCER_IDENTIFIED_UNKNOWN</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Responding to producer identify requests</li>
<li>Event enumeration responses</li>
</ul>
<pre class="fragment">* @param openlcb_node Pointer to node containing producer event list
* </pre> <pre class="fragment">* @param event_index Index into the node's producer event list
* </pre><dl class="section return"><dt>Returns</dt><dd>MTI value corresponding to event state:<ul>
<li>MTI_PRODUCER_IDENTIFIED_UNKNOWN for unknown state</li>
<li>MTI_PRODUCER_IDENTIFIED_SET for set state</li>
<li>MTI_PRODUCER_IDENTIFIED_CLEAR for clear state</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL </dd>
<dd>
Index must be valid (&lt; producer.count)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Caller must ensure event_index is within bounds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__event__transport_8c.html#af6a16c27e84c729162ce66cc0ec4f4dd" title="Extracts the appropriate MTI for consumer event status.">ProtocolEventTransport_extract_consumer_event_status_mti</a> - Consumer equivalent </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
