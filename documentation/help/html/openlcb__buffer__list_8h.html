<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/openlcb_buffer_list.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">openlcb_buffer_list.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Linear search buffer list for OpenLcb/LCC message structures.  
<a href="#details">More...</a></p>

<p><a href="openlcb__buffer__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad977454a2b373e1e67d269232e41db3b" id="r_ad977454a2b373e1e67d269232e41db3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad977454a2b373e1e67d269232e41db3b">OpenLcbBufferList_initialize</a> (void)</td></tr>
<tr class="memdesc:ad977454a2b373e1e67d269232e41db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the OpenLcb Message Buffer List.  <br /></td></tr>
<tr class="separator:ad977454a2b373e1e67d269232e41db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62e6cfb246eaeea5cb13e9df3cf4f7" id="r_aeb62e6cfb246eaeea5cb13e9df3cf4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb62e6cfb246eaeea5cb13e9df3cf4f7">OpenLcbBufferList_add</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *new_msg)</td></tr>
<tr class="memdesc:aeb62e6cfb246eaeea5cb13e9df3cf4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new OpenLcb message into the buffer at the first open slot.  <br /></td></tr>
<tr class="separator:aeb62e6cfb246eaeea5cb13e9df3cf4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3588df82dfb9547d9150cb4350f3710" id="r_ac3588df82dfb9547d9150cb4350f3710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3588df82dfb9547d9150cb4350f3710">OpenLcbBufferList_find</a> (uint16_t source_alias, uint16_t dest_alias, uint16_t mti)</td></tr>
<tr class="memdesc:ac3588df82dfb9547d9150cb4350f3710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the buffer for a message matching the passed parameters.  <br /></td></tr>
<tr class="separator:ac3588df82dfb9547d9150cb4350f3710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f7c4484feef516fc703ae7fa38ec6c" id="r_ab5f7c4484feef516fc703ae7fa38ec6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f7c4484feef516fc703ae7fa38ec6c">OpenLcbBufferList_release</a> (<a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *msg)</td></tr>
<tr class="memdesc:ab5f7c4484feef516fc703ae7fa38ec6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an OpenLcb message from the buffer list.  <br /></td></tr>
<tr class="separator:ab5f7c4484feef516fc703ae7fa38ec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293cd4aa8d64db386fc6de0b524a80bf" id="r_a293cd4aa8d64db386fc6de0b524a80bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a293cd4aa8d64db386fc6de0b524a80bf">OpenLcbBufferList_index_of</a> (uint16_t index)</td></tr>
<tr class="memdesc:a293cd4aa8d64db386fc6de0b524a80bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the message at the passed index.  <br /></td></tr>
<tr class="separator:a293cd4aa8d64db386fc6de0b524a80bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15c0df7469df0e2203f3a67bc3620af" id="r_ab15c0df7469df0e2203f3a67bc3620af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab15c0df7469df0e2203f3a67bc3620af">OpenLcbBufferList_is_empty</a> (void)</td></tr>
<tr class="memdesc:ab15c0df7469df0e2203f3a67bc3620af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if there are any messages stored in the buffer list.  <br /></td></tr>
<tr class="separator:ab15c0df7469df0e2203f3a67bc3620af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear search buffer list for OpenLcb/LCC message structures. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>This module provides a linear array-based list for storing and searching OpenLCB message pointers. Unlike the FIFO, this list supports random access by index and searching by message attributes (source alias, destination alias, and MTI).</p>
<p>Key features:</p><ul>
<li>Linear array with NULL slots indicating free positions</li>
<li>Stores pointers only (messages allocated from buffer store)</li>
</ul>
<p>Primary use cases:</p><ul>
<li>Multi-frame message assembly (tracking partial messages)</li>
<li>Finding in-progress messages by source/dest/MTI combination</li>
<li>Holding messages that don't fit pure FIFO semantics</li>
<li>Managing messages that need lookup by attributes rather than just FIFO order</li>
</ul>
<p>Typical workflow:</p><ol type="1">
<li>Receive first frame of multi-frame message</li>
<li>Allocate buffer from store</li>
<li>Add to list</li>
<li>On subsequent frames, find by source/dest/MTI</li>
<li>Complete assembly</li>
<li>Release from list</li>
<li>Free buffer when done</li>
</ol>
<p>This list must be initialized after <a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize()</a> but can be used independently of OpenLcbBufferFifo.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad977454a2b373e1e67d269232e41db3b" name="ad977454a2b373e1e67d269232e41db3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad977454a2b373e1e67d269232e41db3b">&#9670;&#160;</a></span>OpenLcbBufferList_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbBufferList_initialize </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the OpenLcb Message Buffer List. </p>
<p>Prepares the list for use by setting all array positions to NULL, indicating all slots are free and available for message storage.</p>
<p>The list uses NULL pointers to indicate free slots, so initialization simply clears the entire array. Messages can then be added to any NULL slot.</p>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Required before any list add/find/release operations</li>
<li>Must be called after <a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize()</a></li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>MUST be called exactly once during application initialization before any list operations. Calling multiple times will discard all stored messages. </dd>
<dd>
NOT thread-safe - must be called during single-threaded initialization</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call this function after <a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize()</a> </dd>
<dd>
Call before using <a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add()</a>, find(), release(), or index_of()</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize</a> - Must be called first </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add</a> - Adds messages to initialized list </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ac3588df82dfb9547d9150cb4350f3710" title="Searches the buffer for a message matching the passed parameters.">OpenLcbBufferList_find</a> - Searches initialized list</dd></dl>
<p>Algorithm: Simple initialization by clearing all slots to NULL.</p><ol type="1">
<li>Iterate through all LEN_MESSAGE_BUFFER slots</li>
<li>Set each slot to NULL</li>
<li>Result: Empty list ready for use</li>
</ol>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Required before any list operations</li>
<li>Must be called after <a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize()</a></li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>MUST be called exactly once during initialization </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call after <a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__store_8c.html#aaa929fa9f3796aa554fb29771116b864" title="Initializes the OpenLcb Buffer Store.">OpenLcbBufferStore_initialize</a> - Must be called first </dd></dl>

</div>
</div>
<a id="aeb62e6cfb246eaeea5cb13e9df3cf4f7" name="aeb62e6cfb246eaeea5cb13e9df3cf4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62e6cfb246eaeea5cb13e9df3cf4f7">&#9670;&#160;</a></span>OpenLcbBufferList_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> * OpenLcbBufferList_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>new_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new OpenLcb message into the buffer at the first open slot. </p>
<p>Performs a linear search through the list to find the first NULL slot and stores the message pointer there. This allows the message to be later retrieved by its attributes (source/dest/MTI) or by its index.</p>
<p>Use cases:</p><ul>
<li>Storing first frame of multi-frame message for assembly</li>
<li>Holding messages that need attribute-based lookup</li>
<li>Managing messages in non-FIFO patterns</li>
<li>Tracking in-progress operations</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_msg</td><td>Pointer to a message allocated from OpenLcbBufferStore (must NOT be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the message on success, or NULL if list is full</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Passing NULL will store NULL in list (though function will store it if passed) </dd>
<dd>
Returns NULL when list is full - caller MUST check return value </dd>
<dd>
List full means all LEN_MESSAGE_BUFFER slots occupied </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always check return value for NULL before assuming success </dd>
<dd>
Caller retains ownership - must call release() and free() later </dd>
<dd>
List stores pointers only - does not copy message data</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For frequently-full lists, consider increasing LEN_MESSAGE_BUFFER</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__store_8c.html#a56857b0d3eaed4ee651e9ac794cad201" title="Allocates a new buffer of the specified payload type.">OpenLcbBufferStore_allocate_buffer</a> - Allocate message before adding </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ac3588df82dfb9547d9150cb4350f3710" title="Searches the buffer for a message matching the passed parameters.">OpenLcbBufferList_find</a> - Find message by attributes </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ab5f7c4484feef516fc703ae7fa38ec6c" title="Removes an OpenLcb message from the buffer list.">OpenLcbBufferList_release</a> - Remove message from list </dd>
<dd>
<a class="el" href="openlcb__buffer__store_8c.html#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer</a> - Free message after releasing</dd></dl>
<p>Algorithm: Linear search for first free slot, then store pointer.</p><ol type="1">
<li>Iterate from index 0 to LEN_MESSAGE_BUFFER-1</li>
<li>Check if _openlcb_msg_buffer_list[i] is NULL (free slot)</li>
<li>If NULL found:<ul>
<li>Store new_msg at that index</li>
<li>Return new_msg (success)</li>
</ul>
</li>
<li>If loop completes without finding NULL:<ul>
<li>Return NULL (list full)</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Storing first frame of multi-frame message</li>
<li>Tracking in-progress operations</li>
<li>Managing messages needing attribute lookup</li>
</ul>
<pre class="fragment">* @param new_msg Pointer to message from buffer store (should NOT be NULL)
* </pre><dl class="section return"><dt>Returns</dt><dd>Pointer to message on success, NULL if list full</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns NULL when list full </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Check return value for NULL </dd>
<dd>
Caller retains ownership</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If frequently returning NULL, increase LEN_MESSAGE_BUFFER</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__store_8c.html#a56857b0d3eaed4ee651e9ac794cad201" title="Allocates a new buffer of the specified payload type.">OpenLcbBufferStore_allocate_buffer</a> - Allocate before adding </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ab5f7c4484feef516fc703ae7fa38ec6c" title="Removes an OpenLcb message from the buffer list.">OpenLcbBufferList_release</a> - Remove from list </dd></dl>

</div>
</div>
<a id="ac3588df82dfb9547d9150cb4350f3710" name="ac3588df82dfb9547d9150cb4350f3710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3588df82dfb9547d9150cb4350f3710">&#9670;&#160;</a></span>OpenLcbBufferList_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> * OpenLcbBufferList_find </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>source_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>dest_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mti</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the buffer for a message matching the passed parameters. </p>
<p>Performs a linear search through the list looking for a message that matches all three criteria: source_alias, dest_alias, and mti. This is typically used to find the partial message for a specific multi-frame transfer.</p>
<p>Use cases:</p><ul>
<li>Finding partial multi-frame message to append additional frames</li>
<li>Looking up message by source/destination/type combination</li>
<li>Verifying if a message with specific attributes exists</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_alias</td><td>The CAN alias of the node sending the message frame </td></tr>
    <tr><td class="paramname">dest_alias</td><td>The CAN alias of the node receiving the message frame </td></tr>
    <tr><td class="paramname">mti</td><td>The Message Type Indicator (MTI) code of the message frame type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first matching message, or NULL if no match found</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns NULL if no match found - caller MUST check for NULL </dd>
<dd>
Does NOT remove message from list - use release() for that </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>All three parameters must match for a message to be returned </dd>
<dd>
Returns first match only (if duplicates exist, others not returned) </dd>
<dd>
Returned pointer is still in the list until release() is called</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Skips NULL entries during search</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Common pattern: find() to locate message, update it, then release() when complete</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add</a> - How messages are added to the list </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ab5f7c4484feef516fc703ae7fa38ec6c" title="Removes an OpenLcb message from the buffer list.">OpenLcbBufferList_release</a> - Remove message from list after finding </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#a293cd4aa8d64db386fc6de0b524a80bf" title="Returns a pointer to the message at the passed index.">OpenLcbBufferList_index_of</a> - Alternative lookup by index</dd></dl>
<p>Algorithm: Linear search with triple condition matching.</p><ol type="1">
<li>Iterate from index 0 to LEN_MESSAGE_BUFFER-1</li>
<li>Skip NULL slots (no message stored)</li>
<li>For each non-NULL slot, check if ALL three conditions match:<ul>
<li>dest_alias matches</li>
<li>source_alias matches <br  />
</li>
<li>mti matches</li>
</ul>
</li>
<li>If all match, return pointer immediately</li>
<li>If loop completes without match, return NULL</li>
</ol>
<p>Use cases:</p><ul>
<li>Finding partial multi-frame message by source/dest/type</li>
<li>Looking up message for frame assembly</li>
<li>Verifying message existence</li>
</ul>
<pre class="fragment">* @param source_alias CAN alias of sending node
* @param dest_alias CAN alias of receiving node
* @param mti Message Type Indicator code
* </pre><dl class="section return"><dt>Returns</dt><dd>Pointer to first matching message, or NULL if not found</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns NULL if no match </dd>
<dd>
Does NOT remove from list </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>All three parameters must match </dd>
<dd>
Returns first match only</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Early exit on first match</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add</a> - How messages get into list </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ab5f7c4484feef516fc703ae7fa38ec6c" title="Removes an OpenLcb message from the buffer list.">OpenLcbBufferList_release</a> - Remove after finding </dd></dl>

</div>
</div>
<a id="ab5f7c4484feef516fc703ae7fa38ec6c" name="ab5f7c4484feef516fc703ae7fa38ec6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f7c4484feef516fc703ae7fa38ec6c">&#9670;&#160;</a></span>OpenLcbBufferList_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> * OpenLcbBufferList_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an OpenLcb message from the buffer list. </p>
<p>Searches the list for the specified message pointer and sets that slot to NULL, effectively removing it from the list. The message itself is NOT freed - the caller must call <a class="el" href="openlcb__buffer__store_8c.html#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer()</a> separately.</p>
<p>Use cases:</p><ul>
<li>Removing completed multi-frame message from assembly tracking</li>
<li>Cleaning up after message processing</li>
<li>Removing message before freeing it</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Pointer to message to be removed from list (can be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the message if found and removed, or NULL if msg was NULL or not in list</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Message is NOT freed, only removed from list </dd>
<dd>
Caller must call <a class="el" href="openlcb__buffer__store_8c.html#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer()</a> to actually free the message </dd>
<dd>
Returns NULL if message not found in list </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Safe to call with NULL (returns NULL) </dd>
<dd>
Caller responsible for freeing the returned message </dd>
<dd>
Does not free the message buffer, only removes from list</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Common pattern: release() then free() the message</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add</a> - How messages are added </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ac3588df82dfb9547d9150cb4350f3710" title="Searches the buffer for a message matching the passed parameters.">OpenLcbBufferList_find</a> - Find message before releasing </dd>
<dd>
<a class="el" href="openlcb__buffer__store_8c.html#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer</a> - Free message after releasing</dd></dl>
<p>Algorithm: Linear search for matching pointer, then NULL that slot.</p><ol type="1">
<li>If msg is NULL, return NULL immediately</li>
<li>Iterate from index 0 to LEN_MESSAGE_BUFFER-1</li>
<li>Compare each slot's pointer with msg</li>
<li>If match found:<ul>
<li>Set slot to NULL (remove from list)</li>
<li>Return msg pointer</li>
</ul>
</li>
<li>If loop completes without match:<ul>
<li>Return NULL (not found)</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Removing completed multi-frame message</li>
<li>Cleaning up before freeing message</li>
<li>Removing message from tracking</li>
</ul>
<pre class="fragment">* @param msg Pointer to message to remove (can be NULL)
* </pre><dl class="section return"><dt>Returns</dt><dd>Pointer to message if found and removed, NULL otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Does NOT free message buffer </dd>
<dd>
Caller must call free_buffer() separately </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Safe to call with NULL </dd>
<dd>
Message not freed, only removed from list</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__store_8c.html#a678e335cc01529581d2b7e69ae0ad023" title="Decrements reference count and potentially frees the buffer for reuse.">OpenLcbBufferStore_free_buffer</a> - Free after releasing </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ac3588df82dfb9547d9150cb4350f3710" title="Searches the buffer for a message matching the passed parameters.">OpenLcbBufferList_find</a> - Find before releasing </dd></dl>

</div>
</div>
<a id="a293cd4aa8d64db386fc6de0b524a80bf" name="a293cd4aa8d64db386fc6de0b524a80bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293cd4aa8d64db386fc6de0b524a80bf">&#9670;&#160;</a></span>OpenLcbBufferList_index_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__msg__t.html">openlcb_msg_t</a> * OpenLcbBufferList_index_of </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the message at the passed index. </p>
<p>Provides direct array access to the list by index. The returned pointer may be NULL if that slot is empty, or a valid message pointer if occupied.</p>
<p>Use cases:</p><ul>
<li>Iterating through all list entries</li>
<li>Direct access when index is known</li>
<li>Debugging and diagnostics</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the message requested (0 to LEN_MESSAGE_BUFFER-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to message at index, or NULL if:<ul>
<li>index is out of bounds (&gt;= LEN_MESSAGE_BUFFER)</li>
<li>slot at index is empty (NULL)</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns NULL for out-of-bounds index </dd>
<dd>
Returns NULL for empty slots </dd>
<dd>
Caller cannot distinguish between out-of-bounds and empty slot </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Always check return value for NULL </dd>
<dd>
Valid index range is 0 to LEN_MESSAGE_BUFFER-1 </dd>
<dd>
Returned pointer may be NULL even for valid index</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not remove message from list</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Common pattern: loop from 0 to LEN_MESSAGE_BUFFER-1, check each index_of() result for NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#ab15c0df7469df0e2203f3a67bc3620af" title="Tests if there are any messages stored in the buffer list.">OpenLcbBufferList_is_empty</a> - Check if entire list is empty </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ac3588df82dfb9547d9150cb4350f3710" title="Searches the buffer for a message matching the passed parameters.">OpenLcbBufferList_find</a> - Search by attributes instead of index</dd></dl>
<p>Algorithm: Simple bounds checking followed by array access.</p><ol type="1">
<li>Check if index &gt;= LEN_MESSAGE_BUFFER</li>
<li>If out of bounds, return NULL</li>
<li>Otherwise, return _openlcb_msg_buffer_list[index] (may be NULL if slot is empty)</li>
</ol>
<p>Use cases:</p><ul>
<li>Iterating through all entries</li>
<li>Direct access by index</li>
<li>Debugging and diagnostics</li>
</ul>
<pre class="fragment">* @param index Index of message requested (0 to LEN_MESSAGE_BUFFER-1)
* </pre><dl class="section return"><dt>Returns</dt><dd>Pointer to message at index, or NULL if out of bounds or empty</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns NULL for out-of-bounds </dd>
<dd>
Returns NULL for empty slots </dd>
<dd>
Cannot distinguish out-of-bounds from empty </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Check return value for NULL </dd>
<dd>
Valid range: 0 to LEN_MESSAGE_BUFFER-1</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not remove from list</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#ac3588df82dfb9547d9150cb4350f3710" title="Searches the buffer for a message matching the passed parameters.">OpenLcbBufferList_find</a> - Search by attributes instead </dd></dl>

</div>
</div>
<a id="ab15c0df7469df0e2203f3a67bc3620af" name="ab15c0df7469df0e2203f3a67bc3620af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15c0df7469df0e2203f3a67bc3620af">&#9670;&#160;</a></span>OpenLcbBufferList_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbBufferList_is_empty </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if there are any messages stored in the buffer list. </p>
<p>Scans the entire list to determine if all slots are NULL (empty) or if at least one message pointer exists.</p>
<p>Use cases:</p><ul>
<li>Checking if any multi-frame messages are in progress</li>
<li>Idle detection</li>
<li>Shutdown validation (ensure list is empty before shutdown)</li>
<li>Memory leak detection</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if list is empty (all slots NULL), false if at least one message present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-destructive operation - does not modify list </dd>
<dd>
Early exit on first non-NULL entry found</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add</a> - Causes is_empty() to return false </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ab5f7c4484feef516fc703ae7fa38ec6c" title="Removes an OpenLcb message from the buffer list.">OpenLcbBufferList_release</a> - May cause is_empty() to return true </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#a293cd4aa8d64db386fc6de0b524a80bf" title="Returns a pointer to the message at the passed index.">OpenLcbBufferList_index_of</a> - Alternative to check individual slots</dd></dl>
<p>Algorithm: Linear scan with early exit optimization.</p><ol type="1">
<li>Iterate from index 0 to LEN_MESSAGE_BUFFER-1</li>
<li>If any slot is not NULL:<ul>
<li>Return false immediately (not empty)</li>
</ul>
</li>
<li>If loop completes (all slots NULL):<ul>
<li>Return true (empty)</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>Checking for in-progress multi-frame messages</li>
<li>Idle detection</li>
<li>Shutdown validation</li>
<li>Memory leak detection</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if all slots NULL (empty), false if any message present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-destructive </dd>
<dd>
Early exit on first non-NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__buffer__list_8c.html#aeb62e6cfb246eaeea5cb13e9df3cf4f7" title="Inserts a new OpenLcb message into the buffer at the first open slot.">OpenLcbBufferList_add</a> - Causes to return false </dd>
<dd>
<a class="el" href="openlcb__buffer__list_8c.html#ab5f7c4484feef516fc703ae7fa38ec6c" title="Removes an OpenLcb message from the buffer list.">OpenLcbBufferList_release</a> - May cause to return true </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
