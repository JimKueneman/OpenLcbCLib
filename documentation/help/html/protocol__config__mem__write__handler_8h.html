<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/protocol_config_mem_write_handler.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">protocol_config_mem_write_handler.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Configuration memory write protocol handler.  
<a href="#details">More...</a></p>

<p><a href="protocol__config__mem__write__handler_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__protocol__config__mem__write__handler__t.html">interface_protocol_config_mem_write_handler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface structure for configuration memory write protocol handler.  <a href="structinterface__protocol__config__mem__write__handler__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a456f44446ea0be1a304531ca365c41bf" id="r_a456f44446ea0be1a304531ca365c41bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a456f44446ea0be1a304531ca365c41bf">ProtocolConfigMemWriteHandler_initialize</a> (const <a class="el" href="structinterface__protocol__config__mem__write__handler__t.html">interface_protocol_config_mem_write_handler_t</a> *interface_protocol_config_mem_write_handler)</td></tr>
<tr class="memdesc:a456f44446ea0be1a304531ca365c41bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the configuration memory write protocol handler.  <br /></td></tr>
<tr class="separator:a456f44446ea0be1a304531ca365c41bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f5714c211b96714d6fda3ed4c77aea" id="r_a94f5714c211b96714d6fda3ed4c77aea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f5714c211b96714d6fda3ed4c77aea">ProtocolConfigMemWriteHandler_write_space_config_description_info</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a94f5714c211b96714d6fda3ed4c77aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for Configuration Definition Info space.  <br /></td></tr>
<tr class="separator:a94f5714c211b96714d6fda3ed4c77aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b680b4f26701c10f56982bb8aff7ed6" id="r_a3b680b4f26701c10f56982bb8aff7ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b680b4f26701c10f56982bb8aff7ed6">ProtocolConfigMemWriteHandler_write_space_all</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a3b680b4f26701c10f56982bb8aff7ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for All memory space.  <br /></td></tr>
<tr class="separator:a3b680b4f26701c10f56982bb8aff7ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182374f854aca68bc53a50e3e0124668" id="r_a182374f854aca68bc53a50e3e0124668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a182374f854aca68bc53a50e3e0124668">ProtocolConfigMemWriteHandler_write_space_config_memory</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a182374f854aca68bc53a50e3e0124668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for Configuration Memory space.  <br /></td></tr>
<tr class="separator:a182374f854aca68bc53a50e3e0124668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8a2c2c697f5e531dcf1cf4ca3cb355" id="r_a3c8a2c2c697f5e531dcf1cf4ca3cb355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8a2c2c697f5e531dcf1cf4ca3cb355">ProtocolConfigMemWriteHandler_write_space_acdi_manufacturer</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a3c8a2c2c697f5e531dcf1cf4ca3cb355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for ACDI Manufacturer space.  <br /></td></tr>
<tr class="separator:a3c8a2c2c697f5e531dcf1cf4ca3cb355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ebb986cb45efaed2ed9e531f08a0e0" id="r_a63ebb986cb45efaed2ed9e531f08a0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ebb986cb45efaed2ed9e531f08a0e0">ProtocolConfigMemWriteHandler_write_space_acdi_user</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a63ebb986cb45efaed2ed9e531f08a0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for ACDI User space.  <br /></td></tr>
<tr class="separator:a63ebb986cb45efaed2ed9e531f08a0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f7abc16888f8eaca186004c45a6c8" id="r_ab94f7abc16888f8eaca186004c45a6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94f7abc16888f8eaca186004c45a6c8">ProtocolConfigMemWriteHandler_write_space_train_function_definition_info</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:ab94f7abc16888f8eaca186004c45a6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for Train Function Definition space.  <br /></td></tr>
<tr class="separator:ab94f7abc16888f8eaca186004c45a6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7e53583be81e5c73641262e112d4be" id="r_a1d7e53583be81e5c73641262e112d4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d7e53583be81e5c73641262e112d4be">ProtocolConfigMemWriteHandler_write_space_train_function_config_memory</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a1d7e53583be81e5c73641262e112d4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for Train Function Configuration space.  <br /></td></tr>
<tr class="separator:a1d7e53583be81e5c73641262e112d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9715d1dfcab9d73fe90edbf27c026ce6" id="r_a9715d1dfcab9d73fe90edbf27c026ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9715d1dfcab9d73fe90edbf27c026ce6">ProtocolConfigMemWriteHandler_write_space_firmware</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info)</td></tr>
<tr class="memdesc:a9715d1dfcab9d73fe90edbf27c026ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an incoming write command for Firmware space.  <br /></td></tr>
<tr class="separator:a9715d1dfcab9d73fe90edbf27c026ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e6bfec7458fac25d7adbd77368af28" id="r_a50e6bfec7458fac25d7adbd77368af28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50e6bfec7458fac25d7adbd77368af28">ProtocolConfigMemWriteHandler_write_space_under_mask_message</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, uint8_t space, uint8_t return_msg_ok, uint8_t return_msg_fail)</td></tr>
<tr class="memdesc:a50e6bfec7458fac25d7adbd77368af28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a write command with bit mask.  <br /></td></tr>
<tr class="separator:a50e6bfec7458fac25d7adbd77368af28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1ec325ab08b36cabf99d77bab61814" id="r_a6c1ec325ab08b36cabf99d77bab61814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c1ec325ab08b36cabf99d77bab61814">ProtocolConfigMemWriteHandler_write_request_config_mem</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *config_mem_write_request_info)</td></tr>
<tr class="memdesc:a6c1ec325ab08b36cabf99d77bab61814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a write request for Configuration Memory space.  <br /></td></tr>
<tr class="separator:a6c1ec325ab08b36cabf99d77bab61814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721b302f19e65da8ab1dc3591624b8cb" id="r_a721b302f19e65da8ab1dc3591624b8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a721b302f19e65da8ab1dc3591624b8cb">ProtocolConfigMemWriteHandler_write_request_acdi_user</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *config_mem_write_request_info)</td></tr>
<tr class="memdesc:a721b302f19e65da8ab1dc3591624b8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a write request for ACDI User space.  <br /></td></tr>
<tr class="separator:a721b302f19e65da8ab1dc3591624b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6980019b8da00f292aaa35d954e54f" id="r_a0c6980019b8da00f292aaa35d954e54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c6980019b8da00f292aaa35d954e54f">ProtocolConfigMemWriteHandler_write_request_train_function_config_memory</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, <a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *config_mem_write_request_info)</td></tr>
<tr class="memdesc:a0c6980019b8da00f292aaa35d954e54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to Train Function Configuration Memory space (0xF9)  <br /></td></tr>
<tr class="separator:a0c6980019b8da00f292aaa35d954e54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5c6caef119721e390732860b3f51e3" id="r_aaa5c6caef119721e390732860b3f51e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa5c6caef119721e390732860b3f51e3">ProtocolConfigMemWriteHandler_write_message</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, uint8_t space, uint8_t return_msg_ok, uint8_t return_msg_fail)</td></tr>
<tr class="memdesc:aaa5c6caef119721e390732860b3f51e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a generic write message.  <br /></td></tr>
<tr class="separator:aaa5c6caef119721e390732860b3f51e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee9729eac62a42ab08adea00546aa94" id="r_a1ee9729eac62a42ab08adea00546aa94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee9729eac62a42ab08adea00546aa94">ProtocolConfigMemWriteHandler_write_reply_ok_message</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, uint8_t space)</td></tr>
<tr class="memdesc:a1ee9729eac62a42ab08adea00546aa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a write reply OK message.  <br /></td></tr>
<tr class="separator:a1ee9729eac62a42ab08adea00546aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200fcc9dc0362a182b47ba3f8687878e" id="r_a200fcc9dc0362a182b47ba3f8687878e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a200fcc9dc0362a182b47ba3f8687878e">ProtocolConfigMemWriteHandler_write_reply_fail_message</a> (<a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *statemachine_info, uint8_t space)</td></tr>
<tr class="memdesc:a200fcc9dc0362a182b47ba3f8687878e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a write reply fail message.  <br /></td></tr>
<tr class="separator:a200fcc9dc0362a182b47ba3f8687878e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Configuration memory write protocol handler. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a456f44446ea0be1a304531ca365c41bf" name="a456f44446ea0be1a304531ca365c41bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456f44446ea0be1a304531ca365c41bf">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__protocol__config__mem__write__handler__t.html">interface_protocol_config_mem_write_handler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_protocol_config_mem_write_handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the configuration memory write protocol handler. </p>
<p>Sets up the protocol handler with the required callback interface for processing configuration memory write commands. This must be called once during system initialization before any write operations can be processed.</p>
<p>The interface structure provides callbacks for datagram acknowledgment (required), memory writing (required), and address space-specific handlers (optional based on supported features).</p>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Must be called before processing any configuration write datagrams</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_protocol_config_mem_write_handler</td><td>Pointer to interface structure with callback functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>interface_protocol_config_mem_write_handler must not be NULL </dd>
<dd>
Required callbacks must be set (load_datagram_received_ok_message, load_datagram_received_rejected_message, config_memory_write) </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call during initialization before enabling datagram reception</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__protocol__config__mem__write__handler__t.html" title="Interface structure for configuration memory write protocol handler.">interface_protocol_config_mem_write_handler_t</a></dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Store pointer to interface structure in static variable</li>
<li>Interface callbacks are now available for use by handler functions</li>
</ol>
<p>The interface structure must remain valid for the lifetime of the application as the handler stores a pointer to it rather than copying its contents.</p>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Must be called before processing any configuration write datagrams</li>
</ul>
<pre class="fragment">* @param interface_protocol_config_mem_write_handler Pointer to interface structure with callback functions
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd>
<dd>
Interface structure must remain valid throughout application lifetime </dd>
<dd>
Required callbacks must be set (load_datagram_received_ok_message, load_datagram_received_rejected_message, config_memory_write) </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call during initialization before enabling datagram reception</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__protocol__config__mem__write__handler__t.html" title="Interface structure for configuration memory write protocol handler.">interface_protocol_config_mem_write_handler_t</a> </dd></dl>

</div>
</div>
<a id="a94f5714c211b96714d6fda3ed4c77aea" name="a94f5714c211b96714d6fda3ed4c77aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f5714c211b96714d6fda3ed4c77aea">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_config_description_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_config_description_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for Configuration Definition Info space. </p>
<p>Handles write requests for address space 0xFF (CDI). This space is typically read-only, so this handler will normally reject write attempts.</p>
<p>Use cases:</p><ul>
<li>Rejecting writes to read-only CDI space</li>
<li>Custom CDI handling if writeable CDI is supported</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>CDI space is typically read-only per OpenLCB specification</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a182374f854aca68bc53a50e3e0124668" title="Processes an incoming write command for Configuration Memory space.">ProtocolConfigMemWriteHandler_write_space_config_memory</a></dd></dl>
<p>Processes an incoming write command for Configuration Definition Info space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for CDI writes</li>
<li>Set space_info to point to CDI address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper function sets up the request context for CDI writes. Note that CDI space is typically read-only, so this handler will normally reject write attempts unless custom writeable CDI is implemented.</p>
<p>Use cases:</p><ul>
<li>Called by datagram handler when CDI write command is received</li>
<li>Typically rejects writes (CDI is read-only)</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>CDI space is typically read-only per OpenLCB specification</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd></dl>

</div>
</div>
<a id="a3b680b4f26701c10f56982bb8aff7ed6" name="a3b680b4f26701c10f56982bb8aff7ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b680b4f26701c10f56982bb8aff7ed6">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for All memory space. </p>
<p>Handles write requests for address space 0xFE (All Memory), which maps writes to the appropriate underlying writeable space.</p>
<p>Use cases:</p><ul>
<li>Generic memory write handling</li>
<li>Unified write access to all spaces</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a182374f854aca68bc53a50e3e0124668" title="Processes an incoming write command for Configuration Memory space.">ProtocolConfigMemWriteHandler_write_space_config_memory</a></dd></dl>
<p>Processes an incoming write command for All memory space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for All space writes</li>
<li>Set space_info to point to All address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to the unified All memory space which maps writes to the appropriate underlying writeable space.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd></dl>

</div>
</div>
<a id="a182374f854aca68bc53a50e3e0124668" name="a182374f854aca68bc53a50e3e0124668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182374f854aca68bc53a50e3e0124668">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_config_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_config_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for Configuration Memory space. </p>
<p>Handles write requests for address space 0xFD (Configuration Memory), which contains the node's actual configuration data. Validates the request, sends acknowledgment, and writes the data using the config_memory_write callback.</p>
<p>Use cases:</p><ul>
<li>Writing node configuration values</li>
<li>Responding to configuration tool write requests</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command with data </dd>
<dd>
config_memory_write callback must be implemented </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Writes may affect node behavior - handle carefully</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6c1ec325ab08b36cabf99d77bab61814" title="Generates a write request for Configuration Memory space.">ProtocolConfigMemWriteHandler_write_request_config_mem</a></dd></dl>
<p>Processes an incoming write command for Configuration Memory space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for config memory writes</li>
<li>Set space_info to point to Configuration Memory address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to the actual configuration data storage. This is the primary writeable space for node configuration.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd>
<dd>
config_memory_write callback must be registered</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd>
<dd>
<a class="el" href="#a6c1ec325ab08b36cabf99d77bab61814" title="Generates a write request for Configuration Memory space.">ProtocolConfigMemWriteHandler_write_request_config_mem</a> </dd></dl>

</div>
</div>
<a id="a3c8a2c2c697f5e531dcf1cf4ca3cb355" name="a3c8a2c2c697f5e531dcf1cf4ca3cb355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8a2c2c697f5e531dcf1cf4ca3cb355">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_acdi_manufacturer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_acdi_manufacturer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for ACDI Manufacturer space. </p>
<p>Handles write requests for address space 0xFC (ACDI Manufacturer). This space is typically read-only, so this handler will normally reject write attempts.</p>
<p>Use cases:</p><ul>
<li>Rejecting writes to read-only manufacturer info</li>
<li>Factory programming of manufacturer data (special cases only)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>ACDI manufacturer space is typically read-only</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a63ebb986cb45efaed2ed9e531f08a0e0" title="Processes an incoming write command for ACDI User space.">ProtocolConfigMemWriteHandler_write_space_acdi_user</a></dd></dl>
<p>Processes an incoming write command for ACDI Manufacturer space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for ACDI manufacturer writes</li>
<li>Set space_info to point to ACDI Manufacturer address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to manufacturer identification fields. Note that ACDI Manufacturer space is typically read-only (factory-set), so this handler will normally reject write attempts.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>ACDI Manufacturer space is typically read-only</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd></dl>

</div>
</div>
<a id="a63ebb986cb45efaed2ed9e531f08a0e0" name="a63ebb986cb45efaed2ed9e531f08a0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ebb986cb45efaed2ed9e531f08a0e0">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_acdi_user()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_acdi_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for ACDI User space. </p>
<p>Handles write requests for address space 0xFB (ACDI User), which contains user-defined identification information that can be modified (name, description).</p>
<p>Use cases:</p><ul>
<li>Writing user-defined node name</li>
<li>Writing user description text</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command with data</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a721b302f19e65da8ab1dc3591624b8cb" title="Generates a write request for ACDI User space.">ProtocolConfigMemWriteHandler_write_request_acdi_user</a></dd></dl>
<p>Processes an incoming write command for ACDI User space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for ACDI user writes</li>
<li>Set space_info to point to ACDI User address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to user-defined identification fields (name, description). This space is writeable to allow users to customize node identification.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd>
<dd>
<a class="el" href="#a721b302f19e65da8ab1dc3591624b8cb" title="Generates a write request for ACDI User space.">ProtocolConfigMemWriteHandler_write_request_acdi_user</a> </dd></dl>

</div>
</div>
<a id="ab94f7abc16888f8eaca186004c45a6c8" name="ab94f7abc16888f8eaca186004c45a6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94f7abc16888f8eaca186004c45a6c8">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_train_function_definition_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_train_function_definition_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for Train Function Definition space. </p>
<p>Handles write requests for address space 0xFA (Train Function CDI). This space is typically read-only, so this handler will normally reject write attempts.</p>
<p>Use cases:</p><ul>
<li>Rejecting writes to read-only train CDI</li>
<li>Custom train CDI handling if writeable</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Train function CDI is typically read-only</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1d7e53583be81e5c73641262e112d4be" title="Processes an incoming write command for Train Function Configuration space.">ProtocolConfigMemWriteHandler_write_space_train_function_config_memory</a></dd></dl>
<p>Processes an incoming write command for Train Function Definition space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for train function CDI writes</li>
<li>Set space_info to point to Train Function Definition address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to train function configuration structure (XML). This space is typically read-only.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Train Function CDI space is typically read-only</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd></dl>

</div>
</div>
<a id="a1d7e53583be81e5c73641262e112d4be" name="a1d7e53583be81e5c73641262e112d4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7e53583be81e5c73641262e112d4be">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_train_function_config_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_train_function_config_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for Train Function Configuration space. </p>
<p>Handles write requests for address space 0xF9 (Train Function Config), which contains actual train function configuration data that can be modified.</p>
<p>Use cases:</p><ul>
<li>Writing train function settings</li>
<li>Configuring train functions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid write command with data</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab94f7abc16888f8eaca186004c45a6c8" title="Processes an incoming write command for Train Function Definition space.">ProtocolConfigMemWriteHandler_write_space_train_function_definition_info</a></dd></dl>
<p>Processes an incoming write command for Train Function Configuration space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for train function config writes</li>
<li>Set space_info to point to Train Function Config address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to train function configuration data. This space is writeable for configuring train functions.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd></dl>

</div>
</div>
<a id="a9715d1dfcab9d73fe90edbf27c026ce6" name="a9715d1dfcab9d73fe90edbf27c026ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9715d1dfcab9d73fe90edbf27c026ce6">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_firmware()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_firmware </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes an incoming write command for Firmware space. </p>
<p>Handles write requests for address space 0xEF (Firmware Update), used for uploading new firmware to the node. This is a critical operation requiring careful validation and handling.</p>
<p>Use cases:</p><ul>
<li>Uploading firmware updates</li>
<li>Performing over-the-air updates</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context containing incoming message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL </dd>
<dd>
statemachine_info-&gt;incoming_msg_info.msg_ptr must contain valid firmware data </dd>
<dd>
Implementation must verify firmware integrity before applying </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Firmware updates are critical operations - handle with care</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="protocol__config__mem__operations__handler_8c.html#ae97bdda6c0fe6f2e61ce88b3a78d9fdf" title="Entry point for processing Reset/Reboot command.">ProtocolConfigMemOperationsHandler_reset_reboot</a></dd></dl>
<p>Processes an incoming write command for Firmware space.</p>
<p>Algorithm:</p><ol type="1">
<li>Create local config_mem_write_request_info structure</li>
<li>Set write_space_func to interface callback for firmware writes</li>
<li>Set space_info to point to Firmware address space definition</li>
<li>Call central _dispatch_write_request dispatcher</li>
</ol>
<p>This wrapper processes writes to firmware update space. This is a critical operation used for uploading new firmware to the node.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context containing incoming message
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must not be NULL </dd>
<dd>
Implementation must verify firmware integrity before applying </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Firmware updates are critical operations - handle with care</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_dispatch_write_request </dd></dl>

</div>
</div>
<a id="a50e6bfec7458fac25d7adbd77368af28" name="a50e6bfec7458fac25d7adbd77368af28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e6bfec7458fac25d7adbd77368af28">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_space_under_mask_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_space_under_mask_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>return_msg_ok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>return_msg_fail</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes a write command with bit mask. </p>
<p>Handles write-under-mask commands which allow modifying specific bits in memory without affecting other bits. The command includes both data and mask bytes.</p>
<p>Use cases:</p><ul>
<li>Modifying specific configuration bits</li>
<li>Atomic bit-level updates</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context </td></tr>
    <tr><td class="paramname">space</td><td>Address space identifier </td></tr>
    <tr><td class="paramname">return_msg_ok</td><td>Message type for successful write response </td></tr>
    <tr><td class="paramname">return_msg_fail</td><td>Message type for failed write response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation</dd></dl>
<p>Processes a write command with bit mask.</p>
<p>This stub is reserved for implementing write-under-mask operations which allow modifying specific bits in memory without affecting other bits.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context
* </pre> <pre class="fragment">* @param space Address space identifier
* </pre> <pre class="fragment">* @param return_msg_ok Message type for successful write response
* </pre> <pre class="fragment">* @param return_msg_fail Message type for failed write response
* </pre><dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation </dd></dl>

</div>
</div>
<a id="a6c1ec325ab08b36cabf99d77bab61814" name="a6c1ec325ab08b36cabf99d77bab61814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1ec325ab08b36cabf99d77bab61814">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_request_config_mem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_request_config_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_write_request_info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a write request for Configuration Memory space. </p>
<p>Creates and sends a write request targeting address space 0xFD (Configuration Memory). This function is used when acting as a configuration tool to write configuration data to other nodes.</p>
<p>Use cases:</p><ul>
<li>Writing configuration values to target nodes</li>
<li>Sending settings during configuration operations</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context for message generation </td></tr>
    <tr><td class="paramname">config_mem_write_request_info</td><td>Pointer to write request information including address, count, and data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Both parameters must not be NULL </dd>
<dd>
config_mem_write_request_info must specify valid address, byte count, and data buffer </dd>
<dd>
Byte count must not exceed 64 bytes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a182374f854aca68bc53a50e3e0124668" title="Processes an incoming write command for Configuration Memory space.">ProtocolConfigMemWriteHandler_write_space_config_memory</a></dd></dl>
<p>Generates a write request for Configuration Memory space.</p>
<p>Algorithm:</p><ol type="1">
<li>Load write reply OK message header</li>
<li>Call _write_data to perform the actual write operation</li>
</ol>
<p>This function handles writes to the primary configuration data storage space. The actual write is delegated to the config_memory_write callback which can implement any storage mechanism (EEPROM, flash, RAM, etc.).</p>
<p>Use cases:</p><ul>
<li>Writing configuration values to non-volatile storage</li>
<li>Responding to configuration tool write requests</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context for message generation
* </pre> <pre class="fragment">* @param config_mem_write_request_info Pointer to request info with address, byte count, and data buffer
* </pre><dl class="section warning"><dt>Warning</dt><dd>Both parameters must not be NULL </dd>
<dd>
config_memory_write callback must be implemented </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Writes may affect node behavior - ensure data is validated before writing</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_write_data </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aa2c25886675aad1efa582cf2fc318833" title="Loads a configuration memory write success reply message header.">OpenLcbUtilities_load_config_mem_reply_write_ok_message_header</a> </dd></dl>

</div>
</div>
<a id="a721b302f19e65da8ab1dc3591624b8cb" name="a721b302f19e65da8ab1dc3591624b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721b302f19e65da8ab1dc3591624b8cb">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_request_acdi_user()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_request_acdi_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_write_request_info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a write request for ACDI User space. </p>
<p>Creates and sends a write request targeting address space 0xFB (ACDI User). This function is used when acting as a configuration tool to write user-defined identification to other nodes.</p>
<p>Use cases:</p><ul>
<li>Writing user-defined node names</li>
<li>Setting custom node descriptions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context for message generation </td></tr>
    <tr><td class="paramname">config_mem_write_request_info</td><td>Pointer to write request information including address, count, and data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Both parameters must not be NULL </dd>
<dd>
config_mem_write_request_info must specify valid SNIP field address and data</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a63ebb986cb45efaed2ed9e531f08a0e0" title="Processes an incoming write command for ACDI User space.">ProtocolConfigMemWriteHandler_write_space_acdi_user</a></dd></dl>
<p>Generates a write request for ACDI User space.</p>
<p>Algorithm:</p><ol type="1">
<li>Load write reply OK message header</li>
<li>Use switch statement on requested address to determine SNIP field:<ul>
<li>CONFIG_MEM_ACDI_USER_NAME_ADDRESS:<ul>
<li>Call _write_data to write user name</li>
</ul>
</li>
<li>CONFIG_MEM_ACDI_USER_DESCRIPTION_ADDRESS:<ul>
<li>Call _write_data to write user description</li>
</ul>
</li>
<li>default (unrecognized address):<ul>
<li>Load write fail message with OUT_OF_BOUNDS_INVALID_ADDRESS error</li>
</ul>
</li>
</ul>
</li>
<li>Set outgoing message valid</li>
</ol>
<p>This function maps fixed ACDI user addresses to SNIP data fields for user-customizable identification information. Only name and description fields are writeable.</p>
<p>ACDI User writeable fields:</p><ul>
<li>Name: User-defined node name (e.g. "Front Porch Light")</li>
<li>Description: User-defined description (e.g. "Controls porch lighting")</li>
</ul>
<p>Use cases:</p><ul>
<li>Writing user-defined node name</li>
<li>Writing user description text</li>
<li>Customizing node identification</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context for message generation
* </pre> <pre class="fragment">* @param config_mem_write_request_info Pointer to request info with address indicating which field and data to write
* </pre><dl class="section warning"><dt>Warning</dt><dd>Both parameters must not be NULL </dd>
<dd>
config_memory_write callback must be implemented </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>User name and description fields have size limits</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_write_data </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aa2c25886675aad1efa582cf2fc318833" title="Loads a configuration memory write success reply message header.">OpenLcbUtilities_load_config_mem_reply_write_ok_message_header</a> </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#a06296be3f07fd80febe7dec58eaa5028" title="Loads a configuration memory write failure reply message header.">OpenLcbUtilities_load_config_mem_reply_write_fail_message_header</a> </dd></dl>

</div>
</div>
<a id="a0c6980019b8da00f292aaa35d954e54f" name="a0c6980019b8da00f292aaa35d954e54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6980019b8da00f292aaa35d954e54f">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_request_train_function_config_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_request_train_function_config_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconfig__mem__write__request__info__t.html">config_mem_write_request_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>config_mem_write_request_info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to Train Function Configuration Memory space (0xF9) </p>
<p>Writes function values from datagram data into the train's in-RAM functions[] array. Function N at byte offset N*2, big-endian. Fires on_function_changed notifier for each modified function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context </td></tr>
    <tr><td class="paramname">config_mem_write_request_info</td><td>Pointer to write request information</td></tr>
  </table>
  </dd>
</dl>
<p>Writes to Train Function Configuration Memory space (0xF9)</p>
<p>Algorithm:</p><ol type="1">
<li>Load write reply OK message header</li>
<li>Get train state for the node</li>
<li>If train state exists:<ul>
<li>Iterate over incoming bytes</li>
<li>For each byte, calculate function index (address / 2) and byte selector (address % 2)</li>
<li>Byte selector 0 = high byte (big-endian), byte selector 1 = low byte</li>
<li>Update the corresponding byte of the function value</li>
<li>Fire on_function_changed notifier for each function whose bytes were touched</li>
</ul>
</li>
<li>Set outgoing message as valid</li>
</ol>
<p>This function writes function values into the <a class="el" href="structtrain__state___t_a_g.html#aec825c2a5463ff3857eedd2c5f996bf2">train_state_t.functions</a>[] array from datagram data using big-endian byte order. Function N's 16-bit value occupies byte offsets N*2 (high byte) and N*2+1 (low byte). Bulk writes spanning multiple functions are supported.</p>
<p>After storing the values, this fires the same on_function_changed notifier that Set Function commands use, ensuring consistent application behavior regardless of whether the function was set via Train Control command or via Memory Config write to 0xF9.</p>
<p>Use cases:</p><ul>
<li>Writing function values from configuration tools (JMRI)</li>
<li>Bulk writing multiple function values in a single datagram</li>
</ul>
<pre class="fragment">* @param statemachine_info Pointer to state machine context for message generation
* </pre> <pre class="fragment">* @param config_mem_write_request_info Pointer to request info with address, data, and byte count
* </pre><dl class="section warning"><dt>Warning</dt><dd>Both parameters must not be NULL </dd>
<dd>
Node must have train_state initialized via <a class="el" href="openlcb__application__train_8c.html#ae17ef6101bcfddf2d9debadb6c11d8d0">OpenLcbApplicationTrain_setup()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__utilities_8c.html#aa2c25886675aad1efa582cf2fc318833" title="Loads a configuration memory write success reply message header.">OpenLcbUtilities_load_config_mem_reply_write_ok_message_header</a> </dd></dl>

</div>
</div>
<a id="aaa5c6caef119721e390732860b3f51e3" name="aaa5c6caef119721e390732860b3f51e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5c6caef119721e390732860b3f51e3">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>return_msg_ok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>return_msg_fail</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes a generic write message. </p>
<p>Handles incoming write messages for any address space. This function provides a generic entry point for write command processing.</p>
<p>Use cases:</p><ul>
<li>Generic write message handling</li>
<li>Protocol-level write processing</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context </td></tr>
    <tr><td class="paramname">space</td><td>Address space identifier </td></tr>
    <tr><td class="paramname">return_msg_ok</td><td>Message type for successful write response </td></tr>
    <tr><td class="paramname">return_msg_fail</td><td>Message type for failed write response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation</dd></dl>
<p>Processes a generic write message.</p>
<p>This stub provides a generic entry point for write command processing.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context
* </pre> <pre class="fragment">* @param space Address space identifier
* </pre> <pre class="fragment">* @param return_msg_ok Message type for successful write response
* </pre> <pre class="fragment">* @param return_msg_fail Message type for failed write response
* </pre><dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation </dd></dl>

</div>
</div>
<a id="a1ee9729eac62a42ab08adea00546aa94" name="a1ee9729eac62a42ab08adea00546aa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee9729eac62a42ab08adea00546aa94">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_reply_ok_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_reply_ok_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>space</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes a write reply OK message. </p>
<p>Handles incoming successful write response messages. Used when this node is acting as a configuration tool and receives confirmation that a write was successful.</p>
<p>Use cases:</p><ul>
<li>Processing successful write confirmations</li>
<li>Tracking write completion</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context </td></tr>
    <tr><td class="paramname">space</td><td>Address space identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation</dd></dl>
<p>Processes a write reply OK message.</p>
<p>This stub handles successful write response messages when acting as a configuration tool.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context
* </pre> <pre class="fragment">* @param space Address space identifier
* </pre><dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation </dd></dl>

</div>
</div>
<a id="a200fcc9dc0362a182b47ba3f8687878e" name="a200fcc9dc0362a182b47ba3f8687878e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200fcc9dc0362a182b47ba3f8687878e">&#9670;&#160;</a></span>ProtocolConfigMemWriteHandler_write_reply_fail_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolConfigMemWriteHandler_write_reply_fail_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__statemachine__info__t.html">openlcb_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>statemachine_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>space</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes a write reply fail message. </p>
<p>Handles incoming failed write response messages. Used when this node is acting as a configuration tool and receives a rejection indicating the write could not be completed.</p>
<p>Use cases:</p><ul>
<li>Processing write error responses</li>
<li>Handling write failures and retries</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statemachine_info</td><td>Pointer to state machine context </td></tr>
    <tr><td class="paramname">space</td><td>Address space identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>statemachine_info must not be NULL</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation</dd></dl>
<p>Processes a write reply fail message.</p>
<p>This stub handles failed write response messages when acting as a configuration tool.</p>
<pre class="fragment">* @param statemachine_info Pointer to state machine context
* </pre> <pre class="fragment">* @param space Address space identifier
* </pre><dl class="section note"><dt>Note</dt><dd>Intentional stub - reserved for future implementation </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
