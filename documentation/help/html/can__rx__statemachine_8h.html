<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/drivers/canbus/can_rx_statemachine.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c718a368270b13c54d94892d20736f45.html">drivers</a></li><li class="navelem"><a class="el" href="dir_858afec057d05dde4e87dd686afd4670.html">canbus</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">can_rx_statemachine.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>State machine for receiving and decoding incoming CAN frames.  
<a href="#details">More...</a></p>

<p><a href="can__rx__statemachine_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__can__rx__statemachine__t.html">interface_can_rx_statemachine_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency injection interface for CAN RX state machine module.  <a href="structinterface__can__rx__statemachine__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a90ffc180158c3b8810f3cd68fc904b65" id="r_a90ffc180158c3b8810f3cd68fc904b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90ffc180158c3b8810f3cd68fc904b65">CanRxStatemachine_initialize</a> (const <a class="el" href="structinterface__can__rx__statemachine__t.html">interface_can_rx_statemachine_t</a> *interface_can_rx_statemachine)</td></tr>
<tr class="memdesc:a90ffc180158c3b8810f3cd68fc904b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CAN Receive State Machine module.  <br /></td></tr>
<tr class="separator:a90ffc180158c3b8810f3cd68fc904b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc58af220edcb563f76d5efc256eafe" id="r_a1dc58af220edcb563f76d5efc256eafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dc58af220edcb563f76d5efc256eafe">CanRxStatemachine_incoming_can_driver_callback</a> (<a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *can_msg)</td></tr>
<tr class="memdesc:a1dc58af220edcb563f76d5efc256eafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for incoming CAN frames from hardware driver.  <br /></td></tr>
<tr class="separator:a1dc58af220edcb563f76d5efc256eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>State machine for receiving and decoding incoming CAN frames. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</li>
</ul>
</dd></dl>
<p>This module implements the CAN receive state machine that processes raw CAN frames from the hardware driver and routes them to appropriate handlers. It decodes the CAN frame format, extracts MTI and addressing information, and dispatches to message handlers based on frame type.</p>
<p>The state machine handles:</p><ul>
<li>CAN control frames (CID, RID, AMD, AME, AMR, error reports)</li>
<li>OpenLCB message frames (global, addressed, datagram, stream)</li>
<li>Multi-frame message assembly coordination</li>
<li>Framing bit extraction and validation</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a90ffc180158c3b8810f3cd68fc904b65" name="a90ffc180158c3b8810f3cd68fc904b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ffc180158c3b8810f3cd68fc904b65">&#9670;&#160;</a></span>CanRxStatemachine_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CanRxStatemachine_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__can__rx__statemachine__t.html">interface_can_rx_statemachine_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_can_rx_statemachine</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the CAN Receive State Machine module. </p>
<p>Stores the dependency injection interface for use by the state machine. Must be called during application initialization before processing any CAN frames.</p>
<p>Use cases:</p><ul>
<li>Application startup sequence</li>
<li>System initialization</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_can_rx_statemachine</td><td>Pointer to interface structure containing required function pointers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must be called exactly once during initialization </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call before CanRxStatemachine_incoming_can_driver_callback is invoked </dd>
<dd>
All required function pointers in interface must be initialized</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__rx__statemachine__t.html" title="Dependency injection interface for CAN RX state machine module.">interface_can_rx_statemachine_t</a> - Interface structure definition</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Store pointer to dependency injection interface</li>
<li>Interface remains valid for application lifetime</li>
</ol>
<p>Use cases:</p><ul>
<li>Application startup</li>
<li>System initialization</li>
</ul>
<pre class="fragment">* @param interface_can_rx_statemachine Pointer to interface structure
* </pre><dl class="section warning"><dt>Warning</dt><dd>Must be called exactly once during initialization </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call after CanRxMessageHandler_initialize</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__can__rx__statemachine__t.html" title="Dependency injection interface for CAN RX state machine module.">interface_can_rx_statemachine_t</a> - Interface definition </dd></dl>

</div>
</div>
<a id="a1dc58af220edcb563f76d5efc256eafe" name="a1dc58af220edcb563f76d5efc256eafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc58af220edcb563f76d5efc256eafe">&#9670;&#160;</a></span>CanRxStatemachine_incoming_can_driver_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CanRxStatemachine_incoming_can_driver_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="can__types_8h.html#a9fec363f8b39411fc3ce3bafd7182309">can_msg_t</a> *</td>          <td class="paramname"><span class="paramname"><em>can_msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for incoming CAN frames from hardware driver. </p>
<p>Called by the application's CAN hardware driver when a frame is received. Decodes the CAN frame format, routes to appropriate handler based on frame type, and initiates multi-frame message assembly if needed. This is the primary entry point from the hardware layer into the OpenLCB library.</p>
<p>Use cases:</p><ul>
<li>CAN receive interrupt handler</li>
<li>CAN receive thread/task</li>
<li>Polled CAN reception</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_msg</td><td>Pointer to received CAN frame buffer from hardware</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must not be called when shared resources are locked </dd>
<dd>
NOT thread-safe with main state machine </dd>
<dd>
Frame buffer must remain valid until processing completes</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Application must respect lock_shared_resources/unlock_shared_resources </dd>
<dd>
If using interrupts, disable CAN RX interrupt during resource lock </dd>
<dd>
If using threads, either suspend thread or queue frame for later processing </dd>
<dd>
Lock duration is minimal (microseconds) - queuing should not overflow</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When lock_shared_resources is active, either: </dd>
<dd>
- Disable CAN interrupts until unlock_shared_resources </dd>
<dd>
- Queue incoming frames and call this function after unlock </dd>
<dd>
- Suspend receiving thread until unlock (RTOS only)</dd></dl>
<dl class="section see"><dt>See also</dt><dd>CanMainStatemachine_run - Main state machine that may lock resources </dd>
<dd>
<a class="el" href="structinterface__can__rx__statemachine__t.html#a74e23c8dcaedb643f11cb3c3791e7aad" title="Optional callback for application notification on CAN frame reception.">interface_can_rx_statemachine_t::on_receive</a> - Optional receive callback</dd></dl>
<p>Entry point for incoming CAN frames from hardware driver.</p>
<p>Algorithm:</p><ol type="1">
<li>Call optional on_receive callback if registered</li>
<li>Use CanUtilities_is_openlcb_message to determine frame type</li>
<li>Route based on result:<ul>
<li>true: OpenLCB message â†' Call _handle_can_type_frame</li>
<li>false: CAN control frame â†' Call _handle_can_control_frame</li>
</ul>
</li>
</ol>
<p>Use cases:</p><ul>
<li>CAN receive interrupt handler</li>
<li>CAN receive thread/task</li>
<li>Polled CAN frame reception</li>
</ul>
<pre class="fragment">* @param can_msg Pointer to received CAN frame from hardware driver
* </pre><dl class="section warning"><dt>Warning</dt><dd>Must not be called when shared resources are locked </dd>
<dd>
NOT thread-safe with main state machine </dd>
<dd>
Frame buffer must remain valid during processing</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Application must coordinate with lock_shared_resources </dd>
<dd>
Common implementation: disable CAN RX interrupt during lock </dd>
<dd>
Alternative: queue frames when locked, process after unlock</dd></dl>
<dl class="section note"><dt>Note</dt><dd>CanUtilities_is_openlcb_message checks identifier to distinguish types </dd>
<dd>
OpenLCB messages use OPENLCB_MESSAGE_STANDARD_FRAME_TYPE or datagram/stream types </dd>
<dd>
CAN control frames use different identifier encoding</dd></dl>
<dl class="section see"><dt>See also</dt><dd>CanMainStatemachine_run - Main state machine that may lock resources </dd>
<dd>
<a class="el" href="can__utilities_8c.html#ac6cf0e5812d45a55473653d2b99d6718" title="Tests if CAN frame contains an OpenLCB message.">CanUtilities_is_openlcb_message</a> - Frame type check utility </dd>
<dd>
_handle_can_type_frame - Routes OpenLCB messages </dd>
<dd>
_handle_can_control_frame - Routes CAN control frames </dd></dl>
<p>Routes CAN frame based on frame type field</p>
<p>Algorithm:</p><ol type="1">
<li>Mask CAN identifier with MASK_CAN_FRAME_TYPE</li>
<li>Switch on frame type:<ul>
<li>OPENLCB_MESSAGE_STANDARD_FRAME_TYPE: Standard global/addressed message</li>
<li>CAN_FRAME_TYPE_DATAGRAM_ONLY: Single-frame datagram</li>
<li>CAN_FRAME_TYPE_DATAGRAM_FIRST: First frame of multi-frame datagram</li>
<li>CAN_FRAME_TYPE_DATAGRAM_MIDDLE: Middle frame of datagram</li>
<li>CAN_FRAME_TYPE_DATAGRAM_FINAL: Last frame of datagram</li>
<li>CAN_FRAME_TYPE_STREAM: Stream data frame</li>
</ul>
</li>
<li>Dispatch to appropriate handler based on type</li>
</ol>
<p>Use cases:</p><ul>
<li>Routing all OpenLCB messages from CAN bus</li>
<li>Frame type-specific handling</li>
<li>Multi-frame message coordination</li>
</ul>
<pre class="fragment">* @param can_msg Pointer to received OpenLCB message frame
* </pre><dl class="section warning"><dt>Warning</dt><dd>NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Frame type field in identifier determines message structure </dd>
<dd>
OPENLCB_MESSAGE_STANDARD_FRAME_TYPE indicates standard format message</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Frame types defined by CAN Frame Transfer Standard</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__can__frame__format.html#ga597e5d0d6dc7173b7ec7fce751217bc7" title="Frame type: Global or addressed OpenLCB message.">OPENLCB_MESSAGE_STANDARD_FRAME_TYPE</a> - Standard message frame type constant </dd>
<dd>
CAN_FRAME_TYPE_DATAGRAM_* - Datagram frame type constants </dd>
<dd>
<a class="el" href="group__can__frame__format.html#ga8dc98428ffc735944ad4bea972edda04" title="Frame type: Stream data frame.">CAN_FRAME_TYPE_STREAM</a> - Stream frame type constant</dd></dl>
<p>Routes CAN control frames to handlers</p>
<p>Algorithm:</p><ol type="1">
<li>Extract control frame type from bits [26:16]</li>
<li>Check if variable field (0x0700-0x071F)</li>
<li>Else check if CID pattern</li>
<li>Dispatch accordingly</li>
</ol>
<p>Use cases:</p><ul>
<li>Routing control frames</li>
<li>Filtering invalid frames</li>
</ul>
<pre class="fragment">* @param can_msg Pointer to received control frame
* </pre><dl class="section warning"><dt>Warning</dt><dd>Silently ignores unrecognized types </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Control frames have frame type bit = 0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_handle_can_control_frame_variable_field - RID/AMD/AME/AMR/Error</dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
