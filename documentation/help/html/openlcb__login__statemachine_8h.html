<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenLcbCLib: src/openlcb/openlcb_login_statemachine.h File Reference</title>
<link rel="icon" href="Diesel.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenLcbCLib<span id="projectnumber">&#160;1.0 Alpha</span>
   </div>
   <div id="projectbrief">OpenSource C Library to create OpenLcb/Lcc Nodes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2e7e6c944bd9908e2f8181efb624bb5a.html">openlcb</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">openlcb_login_statemachine.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Login state machine dispatcher for OpenLCB node initialization sequence.  
<a href="#details">More...</a></p>

<p><a href="openlcb__login__statemachine_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterface__openlcb__login__state__machine__t.html">interface_openlcb_login_state_machine_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface structure for login state machine callback functions.  <a href="structinterface__openlcb__login__state__machine__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3f2b3309b14784eba7f14e9e87a0fe09" id="r_a3f2b3309b14784eba7f14e9e87a0fe09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f2b3309b14784eba7f14e9e87a0fe09">OpenLcbLoginStateMachine_initialize</a> (const <a class="el" href="structinterface__openlcb__login__state__machine__t.html">interface_openlcb_login_state_machine_t</a> *interface_openlcb_login_state_machine)</td></tr>
<tr class="memdesc:a3f2b3309b14784eba7f14e9e87a0fe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the login state machine with callback interface.  <br /></td></tr>
<tr class="separator:a3f2b3309b14784eba7f14e9e87a0fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48302fcd398ed4abdc719d2c883b382d" id="r_a48302fcd398ed4abdc719d2c883b382d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48302fcd398ed4abdc719d2c883b382d">OpenLcbLoginMainStatemachine_run</a> (void)</td></tr>
<tr class="memdesc:a48302fcd398ed4abdc719d2c883b382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main state machine processing loop - call repeatedly from application loop.  <br /></td></tr>
<tr class="separator:a48302fcd398ed4abdc719d2c883b382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3330b4f3d1fab79ca865ccca2ca9ef" id="r_a0f3330b4f3d1fab79ca865ccca2ca9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3330b4f3d1fab79ca865ccca2ca9ef">OpenLcbLoginStateMachine_process</a> (<a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *openlcb_statemachine_info)</td></tr>
<tr class="memdesc:a0f3330b4f3d1fab79ca865ccca2ca9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches to appropriate handler based on node's run_state.  <br /></td></tr>
<tr class="separator:a0f3330b4f3d1fab79ca865ccca2ca9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15755455ac11fbb6b09b4eabf9979353" id="r_a15755455ac11fbb6b09b4eabf9979353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15755455ac11fbb6b09b4eabf9979353">OpenLcbLoginStatemachine_handle_outgoing_openlcb_message</a> (void)</td></tr>
<tr class="memdesc:a15755455ac11fbb6b09b4eabf9979353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles transmission of pending outgoing message.  <br /></td></tr>
<tr class="separator:a15755455ac11fbb6b09b4eabf9979353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4519cd137afe8fd412fa900b8278ec10" id="r_a4519cd137afe8fd412fa900b8278ec10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4519cd137afe8fd412fa900b8278ec10">OpenLcbLoginStatemachine_handle_try_reenumerate</a> (void)</td></tr>
<tr class="memdesc:a4519cd137afe8fd412fa900b8278ec10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles re-enumeration for multi-message sequences.  <br /></td></tr>
<tr class="separator:a4519cd137afe8fd412fa900b8278ec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948366df2bf6d0e785d4f8fe5c7810c7" id="r_a948366df2bf6d0e785d4f8fe5c7810c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a948366df2bf6d0e785d4f8fe5c7810c7">OpenLcbLoginStatemachine_handle_try_enumerate_first_node</a> (void)</td></tr>
<tr class="memdesc:a948366df2bf6d0e785d4f8fe5c7810c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get and process the first node in enumeration.  <br /></td></tr>
<tr class="separator:a948366df2bf6d0e785d4f8fe5c7810c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161b0d98a87850fd49c8f2b564a33b77" id="r_a161b0d98a87850fd49c8f2b564a33b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a161b0d98a87850fd49c8f2b564a33b77">OpenLcbLoginStatemachine_handle_try_enumerate_next_node</a> (void)</td></tr>
<tr class="memdesc:a161b0d98a87850fd49c8f2b564a33b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get and process the next node in enumeration.  <br /></td></tr>
<tr class="separator:a161b0d98a87850fd49c8f2b564a33b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5f902fc1cfc55ba719220fa39f3e84" id="r_aca5f902fc1cfc55ba719220fa39f3e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca5f902fc1cfc55ba719220fa39f3e84">OpenLcbLoginStatemachine_get_statemachine_info</a> (void)</td></tr>
<tr class="memdesc:aca5f902fc1cfc55ba719220fa39f3e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to internal state machine info structure.  <br /></td></tr>
<tr class="separator:aca5f902fc1cfc55ba719220fa39f3e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Login state machine dispatcher for OpenLCB node initialization sequence. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2024, Jim Kueneman All rights reserved.</dd></dl>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>This module implements the main dispatcher for the OpenLCB login state machine. It orchestrates the complete node initialization sequence by managing node enumeration, dispatching to appropriate message handlers, controlling message transmission, and coordinating re-enumeration for multi-message sequences.</p>
<p>The state machine is event-driven and non-blocking, designed to be called repeatedly by the main application loop.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Kueneman </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17 Jan 2026</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__login__statemachine__handler_8h.html" title="Login state machine message handler for OpenLCB initialization and event broadcasting.">openlcb_login_statemachine_handler.h</a> - Message construction handlers </dd>
<dd>
OpenLCB Message Network Standard S-9.7.3.1 - Initialization Complete </dd>
<dd>
OpenLCB Event Transport Standard S-9.7.4 - Event Transport Protocol </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3f2b3309b14784eba7f14e9e87a0fe09" name="a3f2b3309b14784eba7f14e9e87a0fe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2b3309b14784eba7f14e9e87a0fe09">&#9670;&#160;</a></span>OpenLcbLoginStateMachine_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbLoginStateMachine_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structinterface__openlcb__login__state__machine__t.html">interface_openlcb_login_state_machine_t</a> *</td>          <td class="paramname"><span class="paramname"><em>interface_openlcb_login_state_machine</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the login state machine with callback interface. </p>
<p>Stores the interface function pointers and initializes the internal state machine structure. Sets up the outgoing message buffer and prepares for node enumeration.</p>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Must be called before any nodes begin login sequence</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_openlcb_login_state_machine</td><td>Pointer to interface structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>MUST be called exactly once during initialization </dd>
<dd>
The interface pointer is stored in static memory - the pointed-to structure must remain valid for the lifetime of the program </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call during single-threaded initialization phase </dd>
<dd>
All interface function pointers must be valid (non-NULL) </dd>
<dd>
Call after message handler initialization</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - Interface structure definition </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run</a> - Main processing loop</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Stores interface pointer in static memory for callbacks</li>
<li>Links outgoing message buffer pointers in state machine info</li>
<li>Sets message pointer to embedded buffer structure</li>
<li>Sets payload pointer to embedded payload structure</li>
<li>Sets payload type to BASIC (standard message size)</li>
<li>Clears message structure to zeros</li>
<li>Clears message payload to zeros</li>
<li>Marks message buffer as allocated (ready for use)</li>
<li>Sets current node pointer to NULL (no node being processed)</li>
</ol>
<p>Memory Layout: The state machine info contains an embedded openlcb_msg_buffer_t which holds both the message structure and payload buffer. The pointers are set up to reference these embedded structures for efficient memory use.</p>
<p>Buffer Lifecycle: The message buffer is allocated once during initialization and reused for all login messages. It is never freed as it is statically allocated within the state machine info structure.</p>
<p>Use cases:</p><ul>
<li>Called once during application startup</li>
<li>Must be called before any nodes begin login sequence</li>
<li>Must be called after message handler initialization</li>
</ul>
<pre class="fragment">* @param interface_openlcb_login_state_machine Pointer to interface structure
* </pre><dl class="section warning"><dt>Warning</dt><dd>MUST be called exactly once during initialization </dd>
<dd>
The interface pointer is stored in static memory - the pointed-to structure must remain valid for the lifetime of the program </dd>
<dd>
NOT thread-safe</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call during single-threaded initialization phase </dd>
<dd>
All interface function pointers must be valid (non-NULL) </dd>
<dd>
Call after <a class="el" href="openlcb__login__statemachine__handler_8c.html#a0240f7d8fb35fff420fcf60de82cb4ba" title="Initializes the login message handler with callback interface.">OpenLcbLoginMessageHandler_initialize()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The message buffer allocated flag is set to prevent accidental deallocation</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - Interface structure definition </dd>
<dd>
<a class="el" href="structopenlcb__login__statemachine__info__t.html" title="Login state machine context.">openlcb_login_statemachine_info_t</a> - State machine info structure </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run</a> - Main processing loop </dd>
<dd>
<a class="el" href="openlcb__utilities_8c.html#aae9c2b155851377c1ce5eadca6a64a17" title="Completely clears and resets a message structure.">OpenLcbUtilities_clear_openlcb_message</a> - Message clearing utility </dd></dl>

</div>
</div>
<a id="a48302fcd398ed4abdc719d2c883b382d" name="a48302fcd398ed4abdc719d2c883b382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48302fcd398ed4abdc719d2c883b382d">&#9670;&#160;</a></span>OpenLcbLoginMainStatemachine_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbLoginMainStatemachine_run </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main state machine processing loop - call repeatedly from application loop. </p>
<p>This is the main entry point for login processing. Should be called repeatedly by the application's main loop. Performs one step of processing and returns immediately (non-blocking design).</p>
<p>Processing handles message transmission, re-enumeration for multi-message sequences, and node iteration. Nodes are automatically processed through their initialization states.</p>
<p>Use cases:</p><ul>
<li>Called continuously from main application loop</li>
<li>Automatically processes all nodes requiring initialization</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Must be called from non-interrupt context</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call repeatedly - this function does NOT block </dd>
<dd>
Nodes transition themselves through states - this just dispatches</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-blocking - returns immediately after one step </dd>
<dd>
Safe to call even when no nodes need processing</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__login__statemachine_8c.html#a0f3330b4f3d1fab79ca865ccca2ca9ef" title="Dispatches to appropriate handler based on node&#39;s run_state.">OpenLcbLoginStateMachine_process</a> - State dispatcher </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a15755455ac11fbb6b09b4eabf9979353" title="Handles transmission of pending outgoing message.">OpenLcbLoginStatemachine_handle_outgoing_openlcb_message</a> - Message transmission </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a4519cd137afe8fd412fa900b8278ec10" title="Handles re-enumeration for multi-message sequences.">OpenLcbLoginStatemachine_handle_try_reenumerate</a> - Re-enumeration control</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Calls handle_outgoing_openlcb_message() to attempt message transmission If returns true (message pending), returns immediately to retry</li>
<li>Calls handle_try_reenumerate() to check for multi-message sequences If returns true (re-enumeration active), returns immediately to continue</li>
<li>Calls handle_try_enumerate_first_node() to start or restart enumeration If returns true (first node handled), returns immediately</li>
<li>Calls handle_try_enumerate_next_node() to advance to next node If returns true (next node handled), returns immediately</li>
</ol>
<p>Processing Priority: The function processes steps in strict priority order:</p><ol type="1">
<li>Message transmission (highest priority - clear pending messages first)</li>
<li>Re-enumeration (continue multi-message sequences on same node)</li>
<li>First node enumeration (start new enumeration cycle)</li>
<li>Next node enumeration (continue enumeration cycle)</li>
</ol>
<p>Non-Blocking Design: Each call performs exactly one operation and returns immediately. The main application loop calls this function repeatedly, allowing other system tasks to execute between login operations.</p>
<p>Enumeration Cycle: The function cycles through all nodes repeatedly. On each pass:</p><ul>
<li>Nodes in RUNSTATE_RUN are skipped (already initialized)</li>
<li>Nodes in initialization states are processed one step</li>
<li>After processing all nodes, enumeration restarts at first node</li>
</ul>
<p>Message Flow Example (2 nodes, each with 1 producer): Call 1: Get first node, generate Init Complete for node 0 Call 2: Send Init Complete for node 0 Call 3: Generate Producer Identified for node 0 Call 4: Send Producer Identified for node 0 Call 5: Node 0 complete, get next node (node 1) Call 6: Generate Init Complete for node 1 Call 7: Send Init Complete for node 1 Call 8: Generate Producer Identified for node 1 Call 9: Send Producer Identified for node 1 Call 10+: All nodes complete, state machine idles</p>
<p>Use cases:</p><ul>
<li>Called continuously from main application loop</li>
<li>Automatically processes all nodes requiring initialization</li>
<li>Continues operating as new nodes are added</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Must be called from non-interrupt context</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call repeatedly in main loop - this function does NOT block </dd>
<dd>
Nodes transition themselves through states - this just dispatches</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-blocking - returns immediately after one step </dd>
<dd>
Safe to call even when no nodes need processing </dd>
<dd>
If message handler needs multiple messages, re-enumerate the same message</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__login__statemachine_8c.html#a0f3330b4f3d1fab79ca865ccca2ca9ef" title="Dispatches to appropriate handler based on node&#39;s run_state.">OpenLcbLoginStateMachine_process</a> - State dispatcher </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a15755455ac11fbb6b09b4eabf9979353" title="Handles transmission of pending outgoing message.">OpenLcbLoginStatemachine_handle_outgoing_openlcb_message</a> - Message transmission </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a4519cd137afe8fd412fa900b8278ec10" title="Handles re-enumeration for multi-message sequences.">OpenLcbLoginStatemachine_handle_try_reenumerate</a> - Re-enumeration control </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a948366df2bf6d0e785d4f8fe5c7810c7" title="Attempts to get and process the first node in enumeration.">OpenLcbLoginStatemachine_handle_try_enumerate_first_node</a> - First node enumeration </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a161b0d98a87850fd49c8f2b564a33b77" title="Attempts to get and process the next node in enumeration.">OpenLcbLoginStatemachine_handle_try_enumerate_next_node</a> - Next node enumeration </dd></dl>

</div>
</div>
<a id="a0f3330b4f3d1fab79ca865ccca2ca9ef" name="a0f3330b4f3d1fab79ca865ccca2ca9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3330b4f3d1fab79ca865ccca2ca9ef">&#9670;&#160;</a></span>OpenLcbLoginStateMachine_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenLcbLoginStateMachine_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>openlcb_statemachine_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches to appropriate handler based on node's run_state. </p>
<p>Examines the node's current run_state and calls the corresponding interface handler function. This function is exposed for unit testing but is normally called internally by the main state machine loop.</p>
<p>Use cases:</p><ul>
<li>Called internally by main state machine</li>
<li>Called directly in unit tests</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openlcb_statemachine_info</td><td>Pointer to state machine info with node and message buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>openlcb_statemachine_info must NOT be NULL </dd>
<dd>
openlcb_statemachine_info-&gt;openlcb_node must be valid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Does nothing if node run_state is not one of the handled states</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - Handler callbacks </dd>
<dd>
<a class="el" href="group__node__login__states.html#gac1cbddb1be6516477038aa787447be6f" title="Send Initialization Complete message, node becomes &quot;Initialized&quot;.">RUNSTATE_LOAD_INITIALIZATION_COMPLETE</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a></dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Examines openlcb_node-&gt;state.run_state value</li>
<li>Switches on run_state to determine which handler to call</li>
<li>For RUNSTATE_LOAD_INITIALIZATION_COMPLETE: Calls load_initialization_complete()</li>
<li>For RUNSTATE_LOAD_PRODUCER_EVENTS: Calls load_producer_events()</li>
<li>For RUNSTATE_LOAD_CONSUMER_EVENTS: Calls load_consumer_events()</li>
<li>For all other states (including RUNSTATE_RUN): Returns without action</li>
</ol>
<p>State-to-Handler Mapping:</p><ul>
<li>RUNSTATE_LOAD_INITIALIZATION_COMPLETE (0x01) -&gt; load_initialization_complete() Generates Initialization Complete message (MTI 0x0100 or 0x0101)</li>
<li>RUNSTATE_LOAD_PRODUCER_EVENTS (0x02) -&gt; load_producer_events() Generates Producer Identified messages (MTI 0x0914/0x0915/0x0917) May be called multiple times via re-enumeration</li>
<li>RUNSTATE_LOAD_CONSUMER_EVENTS (0x03) -&gt; load_consumer_events() Generates Consumer Identified messages (MTI 0x04C4/0x04C5/0x04C7) May be called multiple times via re-enumeration</li>
</ul>
<p>Handler Responsibilities: Each handler is responsible for:</p><ul>
<li>Constructing the appropriate OpenLCB message</li>
<li>Setting the valid flag to trigger transmission</li>
<li>Setting the enumerate flag if more messages are needed</li>
<li>Advancing the node to the next run_state when complete</li>
</ul>
<p>This function is exposed for unit testing but is normally called internally by the main state machine loop.</p>
<p>Use cases:</p><ul>
<li>Called internally by handle_try_enumerate_first_node()</li>
<li>Called internally by handle_try_enumerate_next_node()</li>
<li>Called internally by handle_try_reenumerate()</li>
<li>Called directly in unit tests</li>
</ul>
<pre class="fragment">* @param openlcb_statemachine_info Pointer to state machine info with node and message buffer
* </pre><dl class="section warning"><dt>Warning</dt><dd>Pointer must NOT be NULL </dd>
<dd>
Node pointer within info structure must be valid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Does nothing if node run_state is not one of the handled states </dd>
<dd>
Handlers may modify the node's run_state to advance the sequence</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - Handler callbacks </dd>
<dd>
<a class="el" href="group__node__login__states.html#gac1cbddb1be6516477038aa787447be6f" title="Send Initialization Complete message, node becomes &quot;Initialized&quot;.">RUNSTATE_LOAD_INITIALIZATION_COMPLETE</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="group__node__login__states.html#ga08482f1fdb216fe0bd36cacf8dbf092e" title="Broadcast all producer event IDs that this node generates.">RUNSTATE_LOAD_PRODUCER_EVENTS</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="group__node__login__states.html#ga75ee6f410ee754afe21247321de81f58" title="Broadcast all consumer event IDs that this node handles.">RUNSTATE_LOAD_CONSUMER_EVENTS</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine__handler_8c.html#a63d4945cfcd4930d8b3bc780f59687eb" title="Loads an Initialization Complete message into the outgoing message buffer.">OpenLcbLoginMessageHandler_load_initialization_complete</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine__handler_8c.html#a86d1ac7c901b8980d26547ef4b1b6f48" title="Loads a Producer Event Identified message for the current producer event.">OpenLcbLoginMessageHandler_load_producer_event</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine__handler_8c.html#ac6977ee9bd7b697ad431ddadd14779a9" title="Loads a Consumer Event Identified message for the current consumer event.">OpenLcbLoginMessageHandler_load_consumer_event</a> </dd></dl>

</div>
</div>
<a id="a15755455ac11fbb6b09b4eabf9979353" name="a15755455ac11fbb6b09b4eabf9979353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15755455ac11fbb6b09b4eabf9979353">&#9670;&#160;</a></span>OpenLcbLoginStatemachine_handle_outgoing_openlcb_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbLoginStatemachine_handle_outgoing_openlcb_message </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles transmission of pending outgoing message. </p>
<p>Checks if there is a valid outgoing message and attempts to send it. If transmission succeeds, clears the valid flag. If transmission fails, keeps the valid flag set to retry later. This function is exposed for unit testing but is normally called internally.</p>
<p>Use cases:</p><ul>
<li>Called as first step in main state machine loop</li>
<li>Called directly in unit tests</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a message was pending (sent or queued for retry), false if no message pending</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Returning true indicates state machine should retry on next iteration</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - send_openlcb_msg callback </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run</a> - Main loop caller</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Checks if outgoing_msg_info.valid flag is set</li>
<li>If not valid, returns false (no message to send)</li>
<li>Calls interface-&gt;send_openlcb_msg() with message pointer</li>
<li>If send returns true (message queued successfully):<ul>
<li>Clears valid flag (message sent, no longer pending)</li>
</ul>
</li>
<li>If send returns false (transmit queue full):<ul>
<li>Keeps valid flag set (message still pending, retry later)</li>
</ul>
</li>
<li>Returns true (message was pending, whether sent or not)</li>
</ol>
<p>Message Transmission Flow: The valid flag serves as a semaphore indicating that a message is ready to send. The state machine will repeatedly call this function until the message is successfully transmitted. Once sent, the valid flag is cleared and the state machine can proceed to the next step.</p>
<p>Retry Logic: If the transmit queue is full (send returns false), the function keeps the valid flag set and returns true. This causes the main loop to retry on the next iteration without processing any other nodes or generating new messages.</p>
<p>Priority: This function is called first in the main loop, ensuring that pending messages are transmitted before any new messages are generated. This prevents message buffer overflow and maintains correct sequencing.</p>
<p>This function is exposed for unit testing but is normally called internally by the main state machine loop.</p>
<p>Use cases:</p><ul>
<li>Called as first step in <a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run()</a></li>
<li>Called directly in unit tests to verify transmission logic</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a message was pending (sent or queued for retry), false if no message pending</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Returning true indicates state machine should retry on next iteration </dd>
<dd>
The message buffer is reused, so valid flag must be cleared after transmission</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - send_openlcb_msg callback </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run</a> - Main loop caller </dd>
<dd>
<a class="el" href="structopenlcb__login__statemachine__info__t.html" title="Login state machine context.">openlcb_login_statemachine_info_t</a> - Contains outgoing_msg_info structure </dd></dl>

</div>
</div>
<a id="a4519cd137afe8fd412fa900b8278ec10" name="a4519cd137afe8fd412fa900b8278ec10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4519cd137afe8fd412fa900b8278ec10">&#9670;&#160;</a></span>OpenLcbLoginStatemachine_handle_try_reenumerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbLoginStatemachine_handle_try_reenumerate </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles re-enumeration for multi-message sequences. </p>
<p>Checks if the enumerate flag is set and re-enters the handler if needed. The enumerate flag is set by handlers when they have more messages to send in the same state. This function is exposed for unit testing but is normally called internally.</p>
<p>Use cases:</p><ul>
<li>Called after message transmission in main state machine loop</li>
<li>Called directly in unit tests</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if re-enumeration occurred, false if enumeration complete</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Handlers control enumeration by setting/clearing the enumerate flag</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__login__statemachine__handler_8c.html#a86d1ac7c901b8980d26547ef4b1b6f48" title="Loads a Producer Event Identified message for the current producer event.">OpenLcbLoginMessageHandler_load_producer_event</a> - Sets enumerate flag </dd>
<dd>
<a class="el" href="openlcb__login__statemachine__handler_8c.html#ac6977ee9bd7b697ad431ddadd14779a9" title="Loads a Consumer Event Identified message for the current consumer event.">OpenLcbLoginMessageHandler_load_consumer_event</a> - Sets enumerate flag</dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Checks if outgoing_msg_info.enumerate flag is set</li>
<li>If not set, returns false (enumeration complete for this node)</li>
<li>Calls interface-&gt;process_login_statemachine() to re-enter handler</li>
<li>Returns true (continue enumeration, don't advance to next node)</li>
</ol>
<p>Re-enumeration Purpose: The enumerate flag allows handlers to send multiple messages in sequence without the state machine advancing to the next node. This is used for:</p><ul>
<li>Sending Producer Identified for each produced event</li>
<li>Sending Consumer Identified for each consumed event</li>
</ul>
<p>How It Works: When a handler has more messages to send (e.g., more producer events), it sets the enumerate flag before returning. The state machine detects this flag and calls the handler again instead of moving to the next node. This continues until the handler clears the enumerate flag, indicating all messages in the sequence have been generated.</p>
<p>Example Flow for Node with 3 Producer Events:</p><ol type="1">
<li>Handler called for event 0, sets enumerate=true</li>
<li>Message sent, enumerate=true detected</li>
<li>Handler called again for event 1, sets enumerate=true</li>
<li>Message sent, enumerate=true detected</li>
<li>Handler called again for event 2, sets enumerate=false (last event)</li>
<li>Message sent, enumerate=false detected</li>
<li>State machine advances to next phase</li>
</ol>
<p>This function is exposed for unit testing but is normally called internally by the main state machine loop.</p>
<p>Use cases:</p><ul>
<li>Called in <a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run()</a> after message transmission</li>
<li>Called directly in unit tests to verify re-enumeration logic</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if re-enumeration occurred, false if enumeration complete</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Handlers control enumeration by setting/clearing the enumerate flag </dd>
<dd>
Re-enumeration happens on the same node, not advancing to next node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="openlcb__login__statemachine__handler_8c.html#a86d1ac7c901b8980d26547ef4b1b6f48" title="Loads a Producer Event Identified message for the current producer event.">OpenLcbLoginMessageHandler_load_producer_event</a> - Sets enumerate flag </dd>
<dd>
<a class="el" href="openlcb__login__statemachine__handler_8c.html#ac6977ee9bd7b697ad431ddadd14779a9" title="Loads a Consumer Event Identified message for the current consumer event.">OpenLcbLoginMessageHandler_load_consumer_event</a> - Sets enumerate flag </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a0f3330b4f3d1fab79ca865ccca2ca9ef" title="Dispatches to appropriate handler based on node&#39;s run_state.">OpenLcbLoginStateMachine_process</a> - Called for re-enumeration </dd></dl>

</div>
</div>
<a id="a948366df2bf6d0e785d4f8fe5c7810c7" name="a948366df2bf6d0e785d4f8fe5c7810c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948366df2bf6d0e785d4f8fe5c7810c7">&#9670;&#160;</a></span>OpenLcbLoginStatemachine_handle_try_enumerate_first_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbLoginStatemachine_handle_try_enumerate_first_node </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to get and process the first node in enumeration. </p>
<p>If the current node pointer is NULL, gets the first node and processes it if its run_state indicates initialization is needed. This function is exposed for unit testing but is normally called internally.</p>
<p>Use cases:</p><ul>
<li>Called in main state machine loop to start node enumeration</li>
<li>Called directly in unit tests</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if first node attempt was made, false if current node already exists</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Skips nodes already in RUNSTATE_RUN (already initialized)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - openlcb_node_get_first callback </dd>
<dd>
<a class="el" href="group__node__enum__keys.html#gaad373a5580bf74102fd15f057be715bf" title="Enumeration key used by login state machine.">OPENLCB_LOGIN_STATMACHINE_NODE_ENUMERATOR_INDEX</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a></dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Checks if _statemachine_info.openlcb_node is NULL</li>
<li>If not NULL, returns false (already have a current node)</li>
<li>Calls interface-&gt;openlcb_node_get_first() with enumerator index</li>
<li>If returns NULL (no nodes exist):<ul>
<li>Returns true (done, no nodes to process)</li>
</ul>
</li>
<li>Checks if node-&gt;state.run_state &lt; RUNSTATE_RUN</li>
<li>If node needs initialization:<ul>
<li>Calls interface-&gt;process_login_statemachine()</li>
</ul>
</li>
<li>Returns true (first node handled)</li>
</ol>
<p>First Node Initialization: This function is responsible for starting the node enumeration process. It is called when the state machine has no current node and needs to begin or restart the enumeration sequence.</p>
<p>Node Selection Criteria: Nodes are processed if their run_state is less than RUNSTATE_RUN, indicating they are still in the initialization phase:</p><ul>
<li>RUNSTATE_LOAD_INITIALIZATION_COMPLETE (0x01)</li>
<li>RUNSTATE_LOAD_PRODUCER_EVENTS (0x02)</li>
<li>RUNSTATE_LOAD_CONSUMER_EVENTS (0x03)</li>
</ul>
<p>Nodes already in RUNSTATE_RUN or higher are skipped as they have completed the login sequence.</p>
<p>Empty List Handling: If no nodes exist (get_first returns NULL), the function returns true to indicate completion. This prevents the state machine from attempting to process non-existent nodes.</p>
<p>This function is exposed for unit testing but is normally called internally by the main state machine loop.</p>
<p>Use cases:</p><ul>
<li>Called in <a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run()</a> to start enumeration</li>
<li>Called directly in unit tests to verify first node logic</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if first node attempt was made, false if current node already exists</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Skips nodes already in RUNSTATE_RUN (already initialized) </dd>
<dd>
Sets _statemachine_info.openlcb_node to first node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - openlcb_node_get_first callback </dd>
<dd>
<a class="el" href="group__node__enum__keys.html#gaad373a5580bf74102fd15f057be715bf" title="Enumeration key used by login state machine.">OPENLCB_LOGIN_STATMACHINE_NODE_ENUMERATOR_INDEX</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="group__node__login__states.html#gaf6eaeb155cdfde837a166bac521293a8" title="Normal operation mode - process messages from FIFO.">RUNSTATE_RUN</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a0f3330b4f3d1fab79ca865ccca2ca9ef" title="Dispatches to appropriate handler based on node&#39;s run_state.">OpenLcbLoginStateMachine_process</a> - Processes the node </dd></dl>

</div>
</div>
<a id="a161b0d98a87850fd49c8f2b564a33b77" name="a161b0d98a87850fd49c8f2b564a33b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161b0d98a87850fd49c8f2b564a33b77">&#9670;&#160;</a></span>OpenLcbLoginStatemachine_handle_try_enumerate_next_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLcbLoginStatemachine_handle_try_enumerate_next_node </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to get and process the next node in enumeration. </p>
<p>If the current node pointer is not NULL, gets the next node and processes it if its run_state indicates initialization is needed. This function is exposed for unit testing but is normally called internally.</p>
<p>Use cases:</p><ul>
<li>Called in main state machine loop to continue node enumeration</li>
<li>Called directly in unit tests</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if next node attempt was made, false if no current node exists</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Skips nodes already in RUNSTATE_RUN (already initialized) </dd>
<dd>
When end of list is reached, sets openlcb_node to NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - openlcb_node_get_next callback </dd>
<dd>
<a class="el" href="group__node__enum__keys.html#gaad373a5580bf74102fd15f057be715bf" title="Enumeration key used by login state machine.">OPENLCB_LOGIN_STATMACHINE_NODE_ENUMERATOR_INDEX</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a></dd></dl>
<p>Algorithm:</p><ol type="1">
<li>Checks if _statemachine_info.openlcb_node is not NULL</li>
<li>If NULL, returns false (no current node, can't get next)</li>
<li>Calls interface-&gt;openlcb_node_get_next() with enumerator index</li>
<li>If returns NULL (end of list reached):<ul>
<li>Returns true (done, enumeration complete)</li>
</ul>
</li>
<li>Checks if node-&gt;state.run_state &lt; RUNSTATE_RUN</li>
<li>If node needs initialization:<ul>
<li>Calls interface-&gt;process_login_statemachine()</li>
</ul>
</li>
<li>Returns true (next node handled)</li>
</ol>
<p>Node Iteration: This function advances the enumeration to the next node in the list. It is called repeatedly by the main loop to process each node that requires initialization.</p>
<p>End of List Detection: When get_next returns NULL, it indicates that all nodes have been examined. The function returns true to signal completion, allowing the main loop to restart enumeration on the next iteration if needed.</p>
<p>Automatic Node Skipping: Nodes already in RUNSTATE_RUN or higher are automatically skipped since the run_state check prevents calling the process function. This ensures only nodes requiring initialization are processed.</p>
<p>State Persistence: The _statemachine_info.openlcb_node pointer maintains the current position in the enumeration across multiple calls to the main loop. This allows the state machine to pause at any point and resume on the next iteration.</p>
<p>This function is exposed for unit testing but is normally called internally by the main state machine loop.</p>
<p>Use cases:</p><ul>
<li>Called in <a class="el" href="openlcb__login__statemachine_8c.html#a48302fcd398ed4abdc719d2c883b382d" title="Main state machine processing loop - call repeatedly from application loop.">OpenLcbLoginMainStatemachine_run()</a> to continue enumeration</li>
<li>Called directly in unit tests to verify next node logic</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if next node attempt was made, false if no current node exists</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily an internal function exposed for testing </dd>
<dd>
Skips nodes already in RUNSTATE_RUN (already initialized) </dd>
<dd>
When end of list is reached, openlcb_node remains pointing to last node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structinterface__openlcb__login__state__machine__t.html" title="Interface structure for login state machine callback functions.">interface_openlcb_login_state_machine_t</a> - openlcb_node_get_next callback </dd>
<dd>
<a class="el" href="group__node__enum__keys.html#gaad373a5580bf74102fd15f057be715bf" title="Enumeration key used by login state machine.">OPENLCB_LOGIN_STATMACHINE_NODE_ENUMERATOR_INDEX</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="group__node__login__states.html#gaf6eaeb155cdfde837a166bac521293a8" title="Normal operation mode - process messages from FIFO.">RUNSTATE_RUN</a> in <a class="el" href="openlcb__defines_8h.html" title="OpenLCB protocol constants and Message Type Indicators (MTI)">openlcb_defines.h</a> </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a0f3330b4f3d1fab79ca865ccca2ca9ef" title="Dispatches to appropriate handler based on node&#39;s run_state.">OpenLcbLoginStateMachine_process</a> - Processes the node </dd></dl>

</div>
</div>
<a id="aca5f902fc1cfc55ba719220fa39f3e84" name="aca5f902fc1cfc55ba719220fa39f3e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5f902fc1cfc55ba719220fa39f3e84">&#9670;&#160;</a></span>OpenLcbLoginStatemachine_get_statemachine_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenlcb__login__statemachine__info__t.html">openlcb_login_statemachine_info_t</a> * OpenLcbLoginStatemachine_get_statemachine_info </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to internal state machine info structure. </p>
<p>Provides access to the internal state machine info structure for debugging and unit testing purposes.</p>
<p>Use cases:</p><ul>
<li>Unit testing to verify internal state</li>
<li>Debugging to inspect current state machine status</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal state machine info structure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned pointer is to static memory - do not free </dd>
<dd>
Modifying the returned structure can cause undefined behavior</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Use only for testing and debugging</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily for unit testing </dd>
<dd>
The structure persists across all calls to the state machine</dd></dl>
<p>Provides read access to the internal state machine info structure. The structure contains:</p><ul>
<li>openlcb_node: Pointer to node currently being processed (NULL if none)</li>
<li>outgoing_msg_info: Message buffer and control flags<ul>
<li>msg_ptr: Pointer to message structure</li>
<li>valid: Flag indicating message is ready to send</li>
<li>enumerate: Flag indicating multi-message sequence in progress</li>
</ul>
</li>
</ul>
<p>Testing Usage: Unit tests can use this function to:</p><ul>
<li>Verify current node being processed</li>
<li>Check message buffer contents</li>
<li>Inspect control flags (valid, enumerate)</li>
<li>Validate state transitions</li>
</ul>
<p>Debugging Usage: Developers can use this function to:</p><ul>
<li>Monitor login progress</li>
<li>Inspect pending messages</li>
<li>Diagnose state machine issues</li>
</ul>
<p>Use cases:</p><ul>
<li>Unit testing to verify internal state</li>
<li>Debugging to inspect current state machine status</li>
<li>System monitoring for login progress tracking</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal state machine info structure</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned pointer is to static memory - do not free </dd>
<dd>
Modifying the returned structure can cause undefined behavior </dd>
<dd>
Do not call from interrupt context</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Use only for testing and debugging </dd>
<dd>
Read-only access recommended - modifications may break state machine</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is primarily for unit testing </dd>
<dd>
The structure persists across all calls to the state machine </dd>
<dd>
Structure contents are only valid after <a class="el" href="openlcb__login__statemachine_8c.html#a3f2b3309b14784eba7f14e9e87a0fe09" title="Initializes the login state machine with callback interface.">OpenLcbLoginStateMachine_initialize()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structopenlcb__login__statemachine__info__t.html" title="Login state machine context.">openlcb_login_statemachine_info_t</a> - Structure definition </dd>
<dd>
<a class="el" href="openlcb__login__statemachine_8c.html#a3f2b3309b14784eba7f14e9e87a0fe09" title="Initializes the login state machine with callback interface.">OpenLcbLoginStateMachine_initialize</a> - Initializes the structure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!doctype html>
<html>
    <body>
        <hr>
        <p style="margin-left: 10px; margin-right: 10px;">
            <b>Copyright (c)</b> 2026 Jim Kueneman all rights reserved. See the <a href="../licence.html">License</a>
        </p>
    </body>
</html>
